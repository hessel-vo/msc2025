id,language,reference,generated,generated_rci
2,python,"def is_datatype(cls, value: Any, datatype: str) -> bool:
    t = cls.get_type(datatype)
    if t is None:
        raise DatatypesException(f""Unsupported datatype: {datatype}"")
    return t[1](value)","def is_datatype(cls, value: Any, datatype: str) -> bool:
    if datatype not in cls.datatypes:
        raise DatatypesException(f""Unsupported datatype: '{datatype}'"")
    return cls.datatypes[datatype](value)","def is_datatype(cls, value: Any, datatype: str) -> bool:
    if datatype not in cls.datatypes:
        raise DatatypesException(f""Unsupported datatype: '{datatype}'"")
    return cls.datatypes[datatype](value)"
3,python,"def is_xintx(value: Any, signed: bool, bits: int):
    values = [value]
    if isinstance(value, list):
        values = value

    for v in values:
        if not isinstance(v, int):
            return False
        if not signed and v < 0:
            return False
        max = 2**bits - 1
        min = 0
        if signed:
            max = 2 ** (bits - 1) - 1
            min = -(2 ** (bits - 1))
        if not (v <= max and v >= min):
            return False
    return True","def is_xintx(value: Any, signed: bool, bits: int):
    if isinstance(value, list):
        for v in value:
            if not is_xintx(v, signed, bits):
                return False
        return True
    if not isinstance(value, int):
        return False
    if signed:
        max_val = 2**(bits - 1) - 1
        min_val = -(2**(bits - 1))
        return min_val <= value <= max_val
    else:
        max_val = 2**bits - 1
        return value <= max_val","def is_xintx(value: Any, signed: bool, bits: int):
    if isinstance(value, list):
        for v in value:
            if not is_xintx(v, signed, bits):
                return False
        return True
    if not isinstance(value, int):
        return False
    if signed:
        max_val = 2**(bits - 1) - 1
        min_val = -(2**(bits - 1))
        return min_val <= value <= max_val
    else:
        max_val = 2**bits - 1
        return value <= max_val"
5,python,"def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if not fqn:
        return {}
    fqn_namespaced_datatypes = {}
    for t in dynamic_datatypes:
        if fqn.startswith(t):
            continue

        if fqn.startswith(""."".join(t.split(""."")[:-1])):
            fqn_namespaced_datatypes[(t.split(""."")[-1])] = t

    if fqn_namespaced_datatypes:
        log.debug(f""Namespaced datatypes, {fqn=}, {fqn_namespaced_datatypes=}"")
    return fqn_namespaced_datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn:
        fqn_parts = fqn.split(""."")
        namespace = ""."".join(fqn_parts[:-1])
    else:
        namespace = None
    return {
        k: v
        for k, v in DATATYPES.items()
        if namespace is None or namespace in v[0]
    }","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn:
        fqn_parts = fqn.split(""."")
        namespace = ""."".join(fqn_parts[:-1])
    else:
        namespace = None
    return {
        k: v
        for k, v in DATATYPES.items()
        if namespace is None or namespace in v[0]
    }"
28,java,"public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
    mRootView = inflater.inflate(R.layout.card_fragment, container, false);
    mCardTitle = mRootView.findViewById(R.id.card_name);
    mCardIcon = mRootView.findViewById(R.id.card_icon);
    return mRootView;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View root = inflater.inflate(R.layout.card_fragment, container, false);
    mTitleView = root.findViewById(R.id.card_title);
    mIconView = root.findViewById(R.id.card_icon);
    return root;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View root = inflater.inflate(R.layout.card_fragment, container, false);
    mTitleView = root.findViewById(R.id.card_title);
    mIconView = root.findViewById(R.id.card_icon);
    return root;
}"
29,java,"private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent,
        ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageDrawable(buttonContent.getIcon());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageResource(buttonContent.iconResId);
        buttonView.setOnClickListener(buttonContent.listener);
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageResource(buttonContent.iconResId);
        buttonView.setOnClickListener(buttonContent.listener);
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}"
31,java,"public void updateHeaderView(CardHeader header) {
    requireActivity().runOnUiThread(() -> {
        mRootView.setVisibility(View.VISIBLE);
        mCardTitle.setText(header.getCardTitle());
        mCardIcon.setImageDrawable(header.getCardIcon());
    });
}","public void updateHeaderView(CardHeader header) {
    mHeaderView.post(() -> {
        mHeaderView.setVisibility(View.VISIBLE);
        mHeaderView.setTitle(header.getTitle());
        mHeaderView.setIcon(header.getIcon());
    });
}","public void updateHeaderView(CardHeader header) {
    mHeaderView.post(() -> {
        mHeaderView.setVisibility(View.VISIBLE);
        mHeaderView.setTitle(header.getTitle());
        mHeaderView.setIcon(header.getIcon());
    });
}"
53,cpp,"void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    (void)_subscription;
    if (dbusConnection_->isConnected())
        _listener(AvailabilityStatus::AVAILABLE);
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (connectionStatus_ == DBusConnectionStatus::AVAILABLE) {
        _listener.notify(AVAILABLE, _subscription);
    }
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (connectionStatus_ == DBusConnectionStatus::AVAILABLE) {
        _listener.notify(AVAILABLE, _subscription);
    }
}"
54,cpp,"void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (connections_.end() != connections_.find(conn)) {
        bool found(false);
        std::vector<std::thread*>::const_iterator it = threads_.begin();
        while (!found && it != threads_.end()) {
            found = (&t == *it++);
        }
        if (!found) {
            threads_.push_back(&t);
        }
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(joinMutex);
    if (conn != 0 && !joinThreads.count(conn)) {
        joinThreads[conn] = t;
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(joinMutex);
    if (conn != 0 && joinThreads.find(conn) == joinThreads.end()) {
        joinThreads[conn] = t;
    }
}"
58,cpp,"const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> itsLock(objectManagerGuard_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return dbusObjectManager_;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    static std::shared_ptr<DBusObjectManager> instance;
    if (!instance) {
        std::mutex mutex;
        std::lock_guard<std::mutex> lock(mutex);
        if (!instance) {
            instance = std::make_shared<DBusObjectManager>(*this);
        }
    }
    return instance;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    static std::shared_ptr<DBusObjectManager> instance;
    if (!instance) {
        std::mutex mutex;
        std::lock_guard<std::mutex> lock(mutex);
        if (!instance) {
            instance = std::make_shared<DBusObjectManager>(*this);
        }
    }
    return instance;
}"
78,c,"void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t positive_sid = UDS_SID_ECU_RESET + 0x40;

  uint8_t tx_data[] = {positive_sid, reset_type};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_POSITIVE_RESPONSE, reset_type};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_POSITIVE_RESPONSE, reset_type};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}"
79,c,"void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    return;
  }

  uint8_t reset_type = data[1];

  if (reset_type == UDS_RESET_TYPE_HARD) {
    send_positive_reset_response(UDS_RESET_TYPE_HARD);

    k_sleep(K_MSEC(100));

    LOG_DBG(""Hard reset\n"");
    sys_reboot(SYS_REBOOT_COLD);
  } else {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_SUBFUNCTION_NOT_SUPPORTED);
  }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    isotp_send(&send_ctx, can_dev,
               (uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_INVALID_PARAM},
               sizeof((uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_INVALID_PARAM}),
               &tx_addr, &rx_addr, send_complete_cb, NULL);
    return;
  }

  if (data[1] == UDS_NRC_HARD_RESET) {
    isotp_send(&send_ctx, can_dev,
               (uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_OK},
               sizeof((uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_OK}),
               &tx_addr, &rx_addr, send_complete_cb, NULL);
    system_reboot();
  } else {
    isotp_send(&send_ctx, can_dev,
               (uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_UNSUPPORTED_SERVICE},
               sizeof((uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_UNSUPPORTED_SERVICE}),
               &tx_addr, &rx_addr, send_complete_cb, NULL);
  }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    isotp_send(&send_ctx, can_dev,
               (uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_INVALID_PARAM},
               sizeof((uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_INVALID_PARAM}),
               &tx_addr, &rx_addr, send_complete_cb, NULL);
    return;
  }

  uint8_t reset_type = data[1];
  if (reset_type == UDS_NRC_HARD_RESET) {
    isotp_send(&send_ctx, can_dev,
               (uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_OK},
               sizeof((uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_OK}),
               &tx_addr, &rx_addr, send_complete_cb, NULL);
    system_reboot();
  } else {
    isotp_send(&send_ctx, can_dev,
               (uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_UNSUPPORTED_SERVICE},
               sizeof((uint8_t[]){UDS_SID_ECU_RESET, UDS_NRC_UNSUPPORTED_SERVICE}),
               &tx_addr, &rx_addr, send_complete_cb, NULL);
  }
}"
80,c,"void send_request_download_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_DOWNLOAD + 0x40;


  uint8_t tx_data[] = {
    positive_sid,
    0x20,  // positive response code
    0x00,
    0xD2,  // block size = 258 - 2
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_request_download_response() {
  int ret;
  uint8_t tx_data[] = {UDS_SID_REQUEST_DOWNLOAD_RESPONSE, 0x00, 0xD2, 0x00};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_request_download_response() {
  int ret;
  uint8_t tx_data[] = {UDS_SID_REQUEST_DOWNLOAD_RESPONSE, 0x00, 0xD2, 0x00};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}"
