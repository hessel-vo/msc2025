id,language,reference,generated,generated_rci,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
2,python,"def is_datatype(cls, value: Any, datatype: str) -> bool:
    t = cls.get_type(datatype)
    if t is None:
        raise DatatypesException(f""Unsupported datatype: {datatype}"")
    return t[1](value)","from typing import Any

def is_datatype(cls, value: Any, datatype: str) -> bool:
    supported_datatypes = {
        ""int"": lambda x: isinstance(x, int),
        ""str"": lambda x: isinstance(x, str),
        ""float"": lambda x: isinstance(x, float),
        ""bool"": lambda x: isinstance(x, bool),
        ""list"": lambda x: isinstance(x, list),
        ""tuple"": lambda x: isinstance(x, tuple),
        ""dict"": lambda x: isinstance(x, dict),
    }

    if datatype not in supported_datatypes:
        raise ValueError(f""Unsupported datatype: {datatype}"")

    validation_func = supported_datatypes[datatype]
    return validation_func(value)","from typing import Any

def is_datatype(cls, value: Any, datatype: str) -> bool:
    supported_datatypes = {
        ""int"": lambda x: isinstance(x, int),
        ""str"": lambda x: isinstance(x, str),
        ""float"": lambda x: isinstance(x, float),
        ""bool"": lambda x: isinstance(x, bool),
        ""list"": lambda x: isinstance(x, list),
        ""tuple"": lambda x: isinstance(x, tuple),
        ""dict"": lambda x: isinstance(x, dict),
    }

    if datatype not in supported_datatypes:
        raise ValueError(f""Unsupported datatype: {datatype}"")

    validation_func = supported_datatypes[datatype]
    return validation_func(value)",46.466660378498865,11.99163571560455,40.02885195223706,53.84615384615385,80.0
3,python,"def is_xintx(value: Any, signed: bool, bits: int):
    values = [value]
    if isinstance(value, list):
        values = value

    for v in values:
        if not isinstance(v, int):
            return False
        if not signed and v < 0:
            return False
        max = 2**bits - 1
        min = 0
        if signed:
            max = 2 ** (bits - 1) - 1
            min = -(2 ** (bits - 1))
        if not (v <= max and v >= min):
            return False
    return True","from typing import Any

def is_xintx(value: Any, signed: bool, bits: int):
    if not isinstance(value, int):
        return False

    if signed:
        lower_bound = -(2**(bits - 1))
        upper_bound = 2**(bits - 1) - 1
    else:
        lower_bound = 0
        upper_bound = 2**bits - 1

    return lower_bound <= value <= upper_bound","from typing import Any

def is_xintx(value: Any, signed: bool, bits: int):
    if not isinstance(value, int):
        return False

    if signed:
        lower_bound = -(2**(bits - 1))
        upper_bound = 2**(bits - 1) - 1
    else:
        lower_bound = 0
        upper_bound = 2**bits - 1

    return lower_bound <= value <= upper_bound",31.919939925589453,17.98964295311482,19.64292670205295,60.317460317460316,29.72972972972973
4,python,"def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
        for t in cls.types:
            if datatype == t[0]:
                return t
        return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_def in cls.type_definitions:
        if type_def[0] == datatype:
            return type_def
    return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_def in cls.type_definitions:
        if type_def[0] == datatype:
            return type_def
    return None",70.34186997887033,52.624397026344624,54.669008815062604,74.07407407407408,100.0
5,python,"def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if not fqn:
        return {}
    fqn_namespaced_datatypes = {}
    for t in dynamic_datatypes:
        if fqn.startswith(t):
            continue

        if fqn.startswith(""."".join(t.split(""."")[:-1])):
            fqn_namespaced_datatypes[(t.split(""."")[-1])] = t

    if fqn_namespaced_datatypes:
        log.debug(f""Namespaced datatypes, {fqn=}, {fqn_namespaced_datatypes=}"")
    return fqn_namespaced_datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn is None:
        return {}
    
    fqn_parts = fqn.split(""."")
    namespace = ""."".join(fqn_parts[:-1])
    
    datatypes = {}
    
    if namespace == """":
        return datatypes
    
    
    return datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn is None:
        return {}

    fqn_parts = fqn.split(""."")
    namespace = ""."".join(fqn_parts[:-1])

    datatypes = {}

    if namespace == """":
        return datatypes

    return datatypes",36.16600211060613,30.48650581891384,30.844169290177348,50.0,33.33333333333333
7,python,"def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    is_array = False
    apigear_type = None
    if t.endswith(""[]""):
        is_array = True
        t = t[0:-2]

    if t in [""int8"", ""int16"", ""int32"", ""uint8"", ""uint16"", ""uint32""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT32.value)
    elif t in [""int64"", ""uint64""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT64.value)
    elif t == ""float"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT32.value)
    elif t == ""double"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT64.value)
    elif t == ""boolean"":
        apigear_type = ApiGearType(ApiGearBasicType.BOOL.value)
    elif t == ""string"":
        apigear_type = ApiGearType(ApiGearBasicType.STRING.value)
    else:
        apigear_type = ApiGearType(t.replace(""."", ""_""))

    if is_array and apigear_type is not None:
        apigear_type.is_array = True

    return apigear_type","import typing
from apigear.types import ApiGearType

def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    t = t.strip()
    if t == ""integer"":
        return ApiGearType(name=""integer"", array=False)
    elif t == ""string"":
        return ApiGearType(name=""string"", array=False)
    elif t == ""boolean"":
        return ApiGearType(name=""boolean"", array=False)
    elif t == ""float"":
        return ApiGearType(name=""float"", array=False)
    elif t == ""date"":
        return ApiGearType(name=""date"", array=False)
    elif t == ""datetime"":
        return ApiGearType(name=""datetime"", array=False)
    elif t.endswith(""[]""):
        t = t[:-2]
        if t == ""integer"":
            return ApiGearType(name=""integer"", array=True)
        elif t == ""string"":
            return ApiGearType(name=""string"", array=True)
        elif t == ""boolean"":
            return ApiGearType(name=""boolean"", array=True)
        elif t == ""float"":
            return ApiGearType(name=""float"", array=True)
        elif t == ""date"":
            return ApiGearType(name=""date"", array=True)
        elif t == ""datetime"":
            return ApiGearType(name=""datetime"", array=True)
        else:
            return ApiGearType(name=t.replace(""."", ""_""), array=True)
    else:
        if ""."" in t:
            return ApiGearType(name=t.replace(""."", ""_""), array=False)
        else:
            return ApiGearType(name=t, array=False)","import typing
from apigear.types import ApiGearType

def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    t = t.strip()
    if t == ""integer"":
        return ApiGearType(name=""integer"", array=False)
    elif t == ""string"":
        return ApiGearType(name=""string"", array=False)
    elif t == ""boolean"":
        return ApiGearType(name=""boolean"", array=False)
    elif t == ""float"":
        return ApiGearType(name=""float"", array=False)
    elif t == ""date"":
        return ApiGearType(name=""date"", array=False)
    elif t == ""datetime"":
        return ApiGearType(name=""datetime"", array=False)
    elif t.endswith(""[]""):
        t = t[:-2]
        if t == ""integer"":
            return ApiGearType(name=""integer"", array=True)
        elif t == ""string"":
            return ApiGearType(name=""string"", array=True)
        elif t == ""boolean"":
            return ApiGearType(name=""boolean"", array=True)
        elif t == ""float"":
            return ApiGearType(name=""float"", array=True)
        elif t == ""date"":
            return ApiGearType(name=""date"", array=True)
        elif t == ""datetime"":
            return ApiGearType(name=""datetime"", array=True)
        else:
            return ApiGearType(name=t.replace(""."", ""_""), array=True)
    else:
        if ""."" in t:
            return ApiGearType(name=t.replace(""."", ""_""), array=False)
        else:
            return ApiGearType(name=t, array=False)",20.47837201668175,10.98601571852039,16.742066864382448,34.51327433628318,19.672131147540984
8,python,"def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    apigear_type = get_apigear_datatype(datatype)
    data = node.get_vss_data()

    if apigear_type is None:
        log.warning(f""Datatype {datatype} of node {node.name} currently not supported"")
        return None

    property = ApiGearProperty(apigear_type)
    if data.description != """":
        property.description = data.description
    return property","def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if datatype == ""string"":
        property_type = ApiGearPropertyType.STRING
    elif datatype == ""integer"":
        property_type = ApiGearPropertyType.INTEGER
    elif datatype == ""boolean"":
        property_type = ApiGearPropertyType.BOOLEAN
    elif datatype == ""float"":
        property_type = ApiGearPropertyType.FLOAT
    else:
        warning(f""Unsupported datatype: {datatype}"")
        return None

    property_ = ApiGearProperty(
        name=node.name,
        type=property_type,
        description=node.description,
    )
    return property_","def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if datatype == ""string"":
        property_type = ApiGearPropertyType.STRING
    elif datatype == ""integer"":
        property_type = ApiGearPropertyType.INTEGER
    elif datatype == ""boolean"":
        property_type = ApiGearPropertyType.BOOLEAN
    elif datatype == ""float"":
        property_type = ApiGearPropertyType.FLOAT
    else:
        warning(f""Unsupported datatype: {datatype}"")
        return None

    property_ = ApiGearProperty(
        name=node.name,
        type=property_type,
        description=node.description,
    )
    return property_",29.28313806255724,17.733737649366972,23.843259045306432,35.55555555555556,40.0
10,python,"def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    spec = None
    vspecs: list[VSpec] = []
    for s in specs:
        includes = [s.parent] + include_dirs
        vspecs.extend(get_vspecs(includes, s))
    pre = ""VSpecs""
    if identifier:
        pre += f"" ({identifier})""
    log.info(f""{pre} loaded, amount={len(vspecs)}"")
    for vspec in vspecs:
        log.debug(vspec)
        if spec is None:
            spec = vspec
        else:
            spec.update(vspec)
    if not spec:
        msg = f""Weird behavior. Could not load any spec: {specs}""
        log.error(msg)
        raise SpecException(msg)
    return spec","from pathlib import Path

class VSpec:
    def __init__(self):
        self.data = {}

def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    vspec = VSpec()
    loaded_files = 0

    for spec_path in specs:
        try:
            vspec.data.update(load_vspec_file(spec_path))
            loaded_files += 1
        except Exception:
            pass

    for include_dir in include_dirs:
        try:
            for file_path in find_vspec_files(include_dir):
                vspec.data.update(load_vspec_file(file_path))
                loaded_files += 1
        except Exception:
            pass

    if loaded_files == 0:
        raise Exception(""No VSpec files loaded"")

    return vspec

def load_vspec_file(file_path: Path) -> dict:
    data = {}
    with open(file_path, 'r') as f:
        for line in f:
            if ':' in line:
                key, value = line.strip().split(':', 1)
                data[key.strip()] = value.strip()
    return data

def find_vspec_files(dir_path: Path) -> list[Path]:
    files = []
    for file in dir_path.glob('*.vspec'):
        files.append(file)
    return files","from pathlib import Path

class VSpec:
    def __init__(self):
        self.data = {}

def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    vspec = VSpec()
    loaded_files = 0

    for spec_path in specs:
        try:
            vspec.data.update(load_vspec_file(spec_path))
            loaded_files += 1
        except Exception:
            pass

    for include_dir in include_dirs:
        try:
            for file_path in find_vspec_files(include_dir):
                vspec.data.update(load_vspec_file(file_path))
                loaded_files += 1
        except Exception:
            pass

    if loaded_files == 0:
        raise Exception(""No VSpec files loaded"")

    return vspec

def load_vspec_file(file_path: Path) -> dict:
    data = {}
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or ':' not in line:
                continue
            key, value = line.split(':', 1)
            data[key.strip()] = value.strip()
    return data

def find_vspec_files(dir_path: Path) -> list[Path]:
    files = []
    for file in dir_path.glob('*.vspec'):
        files.append(file)
    return files",35.03713714872047,13.156402355438338,23.400414973293657,47.77777777777778,55.81395348837209
11,python,"def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if isinstance(value, dict):
            if key in base and isinstance(base[key], dict):
                deep_update(base[key], value)
            else:
                base[key] = value
        else:
            base[key] = value","from typing import Any

def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if key in base and isinstance(base[key], dict) and isinstance(value, dict):
            deep_update(base[key], value)
        else:
            base[key] = value","from typing import Any

def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if key in base and isinstance(base[key], dict) and isinstance(value, dict):
            deep_update(base[key], value)
        else:
            base[key] = value",77.38377209757205,72.3104031756316,72.64135188132323,83.33333333333334,81.25
12,python,"def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return v
    pattern = r""^0x[0-9A-Fa-f]{8}$""
    assert bool(re.match(pattern, v)), f""'{v}' is not a valid 'constUID'""
    return v","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in '0123456789abcdefABCDEF' for c in v[2:]):
        return v
    return None","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in '0123456789abcdefABCDEF' for c in v[2:]):
        return v
    return None",53.00979747473712,39.801862783019985,50.2373271159285,52.0,70.0
13,python,"def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw(fqn=fqn, **data)
    try:
        model = resolve_vss_raw(model)
    except (ValidationError, ModelException):
        log.debug(f""'{fqn}', incomplete, initialized as '{model.__class__.__name__}'"")
        return model
    return model","def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw(data=data, fqn=fqn)
    try:
        model.resolve()
    except (ValidationError, ModelError):
        return VSSRaw(data=data, fqn=fqn)
    return model","def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw(data=data, fqn=fqn)
    try:
        model.resolve()
    except (ValidationError, ModelError):
        return model
    return model",54.544985458477704,46.71754291977546,48.962398914135335,42.5,80.0
14,python,"def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    datatypes = get_all_datatypes()
    for value in values:
        assert value in datatypes, f""Invalid datatype: '{value}'""
    return values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_datatypes = [""int"", ""float"", ""str"", ""bool""]
    result = []
    for value in values:
        if value in valid_datatypes:
            result.append(value)
        else:
            return values
    return result","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_datatypes = [""int"", ""float"", ""str"", ""bool""]
    for value in values:
        if value not in valid_datatypes:
            return values
    return values",46.67260373013848,32.141105530539434,37.88264272334785,50.0,66.66666666666666
15,python,"def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    tree_content_lines = []
    for pre, fill, node in RenderTree(tree):
        tree_content_lines.append(""%s%s"" % (pre, node.name))
        for attribute in attributes:
            content = getattr(node.data, attribute, None)
            if content is None:
                continue
            if isinstance(content, str):
                tree_content_lines.append(""%s%s='%s'"" % (fill, attribute, content))
            else:
                tree_content_lines.append(""%s%s=%s"" % (fill, attribute, content))
    return ""\n"".join(tree_content_lines)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    rendered_string = """"
    def traverse(node: VSSNode, indent: int = 0):
        nonlocal rendered_string
        rendered_string += ""  "" * indent + node.name
        if attributes:
            for attr in attributes:
                if hasattr(node, attr):
                    rendered_string += f"" ({getattr(node, attr)})""
        rendered_string += ""\n""
        for child in node.children:
            traverse(child, indent + 1)
    traverse(tree)
    return rendered_string","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    rendered_string = """"
    def traverse(node: VSSNode, indent: int = 0):
        nonlocal rendered_string
        rendered_string += ""  "" * indent + node.name
        if attributes:
            attr_strings = []
            for attr in attributes:
                if hasattr(node, attr):
                    attr_strings.append(str(getattr(node, attr)))
            if attr_strings:
                rendered_string += "" ("" + "", "".join(attr_strings) + "")""
        rendered_string += ""\n""
        for child in node.children:
            traverse(child, indent + 1)
    traverse(tree)
    return rendered_string",31.141471839397006,12.244388763967189,18.15145810779089,41.53846153846154,52.63157894736842
16,python,"def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not isinstance(self.data, VSSDataBranch):
        raise NoInstanceRootException()

    if not self.data.is_instance:
        return self, depth

    if self.parent is None:
        raise NoInstanceRootException()

    return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not self.is_branch():
        raise ValueError(""Starting node is not a branch"")
    if self.parent is None:
        return self, depth
    else:
        if self.parent.is_instance():
            return self.parent, depth + 1
        else:
            return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not self.is_branch():
        raise ValueError(""Starting node is not a branch"")
    if self.parent is None:
        return self, depth
    root, root_depth = self.parent.get_instance_root(depth + 1)
    if root.is_instance():
        return root, root_depth
    else:
        return root, root_depth",57.7767540585272,37.81992689475776,51.576563023561576,57.49999999999999,84.21052631578947
17,python,"def count_instance_children_depth(self) -> int:
    for child in self.children:
        if isinstance(child.data, VSSDataBranch):
            if child.data.is_instance:
                return 1 + child.count_instance_children_depth()
    return 0","def count_instance_children_depth(self) -> int:
    if not self.children:
        return 0
    for child in self.children:
        if isinstance(child, VSSDataBranch) and child.is_instance:
            return 1 + count_instance_children_depth(child)
    return 0","def count_instance_children_depth(self) -> int:
    if not self.children:
        return 0
    for child in self.children:
        if isinstance(child, VSSDataBranch) and child.is_instance:
            return 1 + count_instance_children_depth(child)
    return 0",47.76287801690429,32.077142814517714,42.825300930118075,30.434782608695656,85.71428571428571
18,python,"def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    ids = []
    for i in node_ids:
        if get_expected_parent(i) == name:
            ids.append(i)
    return ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        parts = node_id.split('_')
        if len(parts) > 1 and parts[0] == name:
            children_ids.append(node_id)
    return children_ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        parts = node_id.split('_')
        if len(parts) > 1 and parts[0] == name:
            children_ids.append(node_id)
    return children_ids",60.60297737657008,29.73199273805454,41.895603042735594,76.66666666666667,94.11764705882352
19,python,"def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    result = getattr(o, name, default)
    if result is None and default is not None:
        result = default
    return result","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        value = getattr(o, name)
        if value is None:
            return default
        return value
    except AttributeError:
        return default","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    value = getattr(o, name, default)
    return value",54.15179268798601,41.66026282550508,43.28024125977231,58.333333333333336,73.33333333333333
20,python,"def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    fd.write('syntax = ""proto3"";\n\n')

    imports = []
    for node in findall(tree, filter_=lambda n: isinstance(n.data, VSSDataDatatype)):
        datatype = node.data.datatype
        if ""."" not in datatype:
            continue
        struct_path = Path(node.data.datatype.replace(""."", ""/""))  # type: ignore
        imports.append(f""{struct_path.parent}/{struct_path.parent.name}.proto"")
    write_imports(fd, imports)

    # write proto messages to file
    for node in findall(tree, filter_=lambda node: isinstance(node.data, VSSDataBranch)):
        fd.write(f""message {node.get_fqn('')} {{"" + ""\n"")
        print_messages(node.children, fd, static_uid, add_optional)
        fd.write(""}\n\n"")","def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""complex"":
        fd.write(f""import {tree.name}pb3\n"")
    if tree.type == ""branch"":
        fd.write(f""{tree.name} = {tree.name}pb3.{tree.name}()\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)","def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""complex"":
        fd.write(f""import {tree.name}pb3\n"")
    if tree.type == ""branch"":
        fd.write(f""{tree.name} = {tree.name}pb3.{tree.name}()\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)",21.637941543039947,9.900945380552495,15.482435911882215,27.835051546391753,33.33333333333333
21,python,"def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    meta: dict[str, list[str]] = {}
    for node in PreOrderIter(root, filter_=lambda n: isinstance(n.data, VSSDataBranch) and n.data.is_instance):
        if any(c.data.is_instance for c in node.children if isinstance(c.data, VSSDataBranch)):
            continue
        instance_root, _ = node.get_instance_root()
        instance_root_fqn = instance_root.get_fqn()

        instance_name = node.get_fqn().removeprefix(instance_root_fqn + ""."")

        if instance_root_fqn in meta:
            meta[instance_root_fqn].append(instance_name)
        else:
            meta[instance_root_fqn] = [instance_name]
    return meta","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    stack = [(root, """")]
    while stack:
        node, prefix = stack.pop()
        if node.is_terminal():
            if prefix:
                if prefix not in instances:
                    instances[prefix] = []
                instances[prefix].append(node.name)
        else:
            for child in node.children:
                stack.append((child, f""{prefix}/{child.name}"" if prefix else child.name))
    return instances","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    stack = [(root, """")]
    while stack:
        node, prefix = stack.pop()
        if node.is_terminal():
            if prefix:
                if prefix not in instances:
                    instances[prefix] = []
                instances[prefix].append(node.name)
        else:
            for child in node.children:
                stack.append((child, f""{prefix}/{child.name}"" if prefix else child.name))
    return instances",29.318696186137032,11.450300750990431,12.650662740918717,48.275862068965516,44.89795918367347
22,python,"def is_VSS_leaf(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataDatatype):
        return True
    return False","def is_VSS_leaf(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataDatatype)","def is_VSS_leaf(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataDatatype)",53.95251422009305,34.1077254951379,31.7023313852343,50.0,100.0
23,python,"def is_VSS_branch(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataBranch):
        if not node.data.is_instance:
            return True
    return False","def is_VSS_branch(node: VSSNode) -> bool:
    return node.data == VSSDataBranch and not node.is_instance","def is_VSS_branch(node: VSSNode) -> bool:
    return node.data == VSSDataBranch and not node.is_instance",36.06308206012407,26.856510884721402,25.816869987353826,31.57894736842105,60.0
24,python,"def is_VSS_branch_instance(node: VSSNode) -> bool:
    if isinstance(node.data, VSSDataBranch):
        if node.data.is_instance:
            return True
    return False","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return node.data == ""VSSDataBranch"" and node.is_instance == True","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return node.data == ""VSSDataBranch"" and node.is_instance is True",37.665818253375164,29.126663049139573,28.203276631027762,33.33333333333333,60.0
25,python,"def fnv1_32_hash(identifier: bytes) -> int:
    id_hash = 2166136261
    for byte in identifier:
        id_hash = (id_hash * 16777619) & 0xFFFFFFFF
        id_hash ^= byte

    return id_hash","def fnv1_32_hash(identifier: bytes) -> int:
    hval = 0xcbf29ce484222325
    fnv_prime = 0x100000001b3
    for byte in identifier:
        hval ^= byte
        hval *= fnv_prime
    return hval","def fnv1_32_hash(identifier: bytes) -> int:
    hval = 0xcbf29ce484222325
    fnv_prime = 0x100000001b3
    for byte in identifier:
        hval ^= byte
        hval *= fnv_prime
        hval &= 0xFFFFFFFF
    return hval",33.64212519544857,26.613685332453084,30.586394396709615,47.368421052631575,30.0
28,java,"public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
    mRootView = inflater.inflate(R.layout.card_fragment, container, false);
    mCardTitle = mRootView.findViewById(R.id.card_name);
    mCardIcon = mRootView.findViewById(R.id.card_icon);
    return mRootView;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View root = inflater.inflate(R.layout.card_fragment, container, false);
    TextView titleView = root.findViewById(R.id.card_title);
    ImageView iconView = root.findViewById(R.id.card_icon);

    titleView.setText(""Card Title"");
    iconView.setImageResource(R.drawable.card_icon);

    return root;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View root = inflater.inflate(R.layout.card_fragment, container, false);
    TextView titleView = root.findViewById(R.id.card_title);
    ImageView iconView = root.findViewById(R.id.card_icon);

    if (titleView != null) {
        titleView.setText(""Card Title"");
    }
    if (iconView != null) {
        iconView.setImageResource(R.drawable.card_icon);
    }

    return root;
}",57.25201072979208,26.385937298217065,49.591802590648214,66.66666666666666,86.36363636363636
29,java,"private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent,
        ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageDrawable(buttonContent.getIcon());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
    if (buttonContent == null) {
        buttonView.setVisibility(View.GONE);
        return;
    }

    buttonView.setImageResource(buttonContent.getImage());
    buttonView.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            buttonContent.executeAction();
        }
    });
    buttonView.setVisibility(View.VISIBLE);
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
    if (buttonContent == null) {
        buttonView.setVisibility(View.GONE);
        return;
    }

    buttonView.setImageResource(buttonContent.getImage());
    buttonView.setOnClickListener(v -> buttonContent.executeAction());
    buttonView.setVisibility(View.VISIBLE);
}",68.65747115092363,46.86670913916292,47.118014174209016,80.64516129032258,100.0
30,java,"protected final View getDescriptiveTextOnlyLayoutView() {
    if (mDescriptiveTextOnlyLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.descriptive_text_layout);
        mDescriptiveTextOnlyLayoutView = stub.inflate();
        mDescriptiveTextOnlyTitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.primary_text);
        mDescriptiveTextOnlySubtitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.secondary_text);
        mDescriptiveTextOnlyOptionalImage = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.optional_image);
        mDescriptiveTextOnlyTapForMore = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.tap_for_more_text);
    }
    return mDescriptiveTextOnlyLayoutView;
}","protected final View getDescriptiveTextOnlyLayoutView() {
        if (this.descriptiveTextOnlyLayoutView == null) {
            this.descriptiveTextOnlyLayoutView = LayoutInflater.from(this.context).inflate(R.layout.descriptive_text_only, this, false);
            this.titleView = this.descriptiveTextOnlyLayoutView.findViewById(R.id.title);
            this.subtitleView = this.descriptiveTextOnlyLayoutView.findViewById(R.id.subtitle);
            this.imageView = this.descriptiveTextOnlyLayoutView.findViewById(R.id.image);
        }
        return this.descriptiveTextOnlyLayoutView;
    }","protected final View getDescriptiveTextOnlyLayoutView() {
        if (this.descriptiveTextOnlyLayoutView == null) {
            this.descriptiveTextOnlyLayoutView = LayoutInflater.from(this.context).inflate(R.layout.descriptive_text_only, this, false);
            this.titleView = this.descriptiveTextOnlyLayoutView.findViewById(R.id.title);
            this.subtitleView = this.descriptiveTextOnlyLayoutView.findViewById(R.id.subtitle);
            this.imageView = this.descriptiveTextOnlyLayoutView.findViewById(R.id.image);
        }
        return this.descriptiveTextOnlyLayoutView;
    }",31.76112784020524,18.128917150661877,20.279230573795438,38.63636363636363,50.0
31,java,"public void updateHeaderView(CardHeader header) {
    requireActivity().runOnUiThread(() -> {
        mRootView.setVisibility(View.VISIBLE);
        mCardTitle.setText(header.getCardTitle());
        mCardIcon.setImageDrawable(header.getCardIcon());
    });
}","public void updateHeaderView(CardHeader header) {
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            rootView.setVisibility(View.VISIBLE);
            cardTitle.setText(header.getTitle());
            cardIcon.setImageResource(header.getIcon());
        }
    });
}","public void updateHeaderView(CardHeader header) {
    runOnUiThread(new Runnable() {
        @Override
        public void run() {
            if (rootView != null) {
                rootView.setVisibility(View.VISIBLE);
            }
            if (cardTitle != null) {
                cardTitle.setText(header.getTitle());
            }
            if (cardIcon != null) {
                cardIcon.setImageResource(header.getIcon());
            }
        }
    });
}",53.80632392433209,11.092770141728163,36.27538269845734,67.85714285714286,100.0
32,java,"private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.text_block_layout);
        mTextBlockLayoutView = stub.inflate();
        mTextBlock = mTextBlockLayoutView.findViewById(R.id.text_block);
        mTextBlockTapForMore = mTextBlockLayoutView.findViewById(R.id.tap_for_more_text);
    }
    return mTextBlockLayoutView;
}","private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = LayoutInflater.from(getContext()).inflate(
                R.layout.text_block, this, true);
        mTextView = (TextView) mTextBlockLayoutView.findViewById(R.id.text_view);
        mTextView2 = (TextView) mTextBlockLayoutView.findViewById(R.id.text_view2);
    }
    return mTextBlockLayoutView;
}","private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = LayoutInflater.from(getContext()).inflate(
                R.layout.text_block, this, true);
        if (mTextBlockLayoutView != null) {
            mTextView = (TextView) mTextBlockLayoutView.findViewById(R.id.text_view);
            mTextView2 = (TextView) mTextBlockLayoutView.findViewById(R.id.text_view2);
        }
    }
    return mTextBlockLayoutView;
}",48.59543349499831,33.8225200211764,45.21830486790775,56.25,59.09090909090909
33,java,"static ComponentName getMediaSource(@NonNull PackageManager packageManager,
        @NonNull String packageName) {
    Intent mediaIntent = new Intent();
    mediaIntent.setPackage(packageName);
    mediaIntent.setAction(MediaBrowserService.SERVICE_INTERFACE);

    List<ResolveInfo> mediaServices = packageManager.queryIntentServices(mediaIntent,
            PackageManager.GET_RESOLVED_FILTER);

    if (mediaServices == null || mediaServices.isEmpty()) {
        return null;
    }
    String defaultService = mediaServices.get(0).serviceInfo.name;
    if (!TextUtils.isEmpty(defaultService)) {
        return new ComponentName(packageName, defaultService);
    }
    return null;
}","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {
        Intent intent = new Intent(MediaBrowserService.SERVICE_INTERFACE);
        intent.setPackage(packageName);

        ResolveInfo resolveInfo = packageManager.resolveService(intent, 0);
        if (resolveInfo != null) {
            return resolveInfo.getComponent();
        }

        return null;
    }","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {
        Intent intent = new Intent(MediaBrowserService.SERVICE_INTERFACE);
        intent.setPackage(packageName);

        ResolveInfo resolveInfo = packageManager.resolveService(intent, PackageManager.MATCH_DEFAULT);
        if (resolveInfo != null) {
            return resolveInfo.getComponent();
        }

        return null;
    }",34.28093339712993,25.580543580238263,28.65909297324104,47.16981132075472,35.714285714285715
34,java,"private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    switch (componentAppType) {
        case APP_TYPE_MEDIA_SERVICES:
            if (customMediaComponents.contains(componentName.flattenToString())
                    && (appTypesToShow & APP_TYPE_LAUNCHABLES) != 0) {
                return false;
            }
            return true;
        case APP_TYPE_LAUNCHABLES:
            return true;
        default:
            Log.e(TAG, ""Invalid componentAppType : "" + componentAppType);
            return false;
    }
}","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    if ((appTypesToShow & AppTypes.LAUNCHABLE) != 0
            && (componentAppType & AppTypes.MEDIA) != 0
            && customMediaComponents.contains(componentName.getClassName())) {
        return false;
    }
    return true;
}","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    if ((appTypesToShow & AppTypes.LAUNCHABLE) != 0
            && (componentAppType & AppTypes.MEDIA) != 0
            && customMediaComponents.contains(componentName.getClassName())) {
        return false;
    }
    return true;
}",61.86418183533259,48.03984716340054,50.21053097158059,63.49206349206349,85.71428571428571
35,java,"private static void selectMediaSourceAndFinish(Context context, ComponentName componentName,
        CarMediaManager carMediaManager) {
    try {
        carMediaManager.setMediaSource(componentName, CarMediaManager.MEDIA_SOURCE_MODE_BROWSE);
        if (context instanceof Activity) {
            ((Activity) context).finish();
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected"", e);
    }
}","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
    try {
        carMediaManager.setMediaSource(componentName);
        if (context instanceof Activity) {
            ((Activity) context).finish();
        }
    } catch (CarNotConnectedException e) {
        Log.e(""CarMedia"", ""Car service unavailable"", e);
    }
}","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
    try {
        carMediaManager.setMediaSource(componentName);
        if (context instanceof Activity) {
            ((Activity) context).finish();
        }
    } catch (CarNotConnectedException e) {
        Log.e(""CarMedia"", ""Car service unavailable"", e);
    }
}",75.18713502777621,72.30717871694607,73.60265171673943,54.83870967741935,100.0
36,java,"static boolean isActivityDistractionOptimized(
        CarPackageManager carPackageManager, String packageName, String activityName) {
    boolean isDistractionOptimized = false;
    try {
        if (carPackageManager != null) {
            isDistractionOptimized =
                    carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected when getting DO info"", e);
    }
    return isDistractionOptimized;
}","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
        if (carPackageManager == null) {
            Log.e(""CarDistraction"", ""CarPackageManager is null"");
            return false;
        }
        try {
            return carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        } catch (CarNotConnectedException e) {
            Log.e(""CarDistraction"", ""CarNotConnectedException: "" + e.getMessage());
            return false;
        }
    }","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
        if (carPackageManager == null) {
            Log.e(""CarDistraction"", ""CarPackageManager is null"");
            return false;
        }
        try {
            return carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        } catch (CarNotConnectedException e) {
            Log.e(""CarDistraction"", ""CarNotConnectedException: "" + e.getMessage());
            return false;
        }
    }",47.815641538206144,27.922337222454964,29.103775728399167,41.37931034482759,92.85714285714286
38,java,"private Intent getMapsIntent() {
    Intent defaultIntent =
            Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MAPS);
    PackageManager pm = getPackageManager();
    ComponentName defaultActivity = defaultIntent.resolveActivity(pm);

    for (String intentUri : getResources().getStringArray(
            R.array.config_homeCardPreferredMapActivities)) {
        Intent preferredIntent;
        try {
            preferredIntent = Intent.parseUri(intentUri, Intent.URI_ANDROID_APP_SCHEME);
        } catch (URISyntaxException se) {
            Log.w(TAG, ""Invalid intent URI in config_homeCardPreferredMapActivities"", se);
            continue;
        }

        if (defaultActivity != null && !defaultActivity.getPackageName().equals(
                preferredIntent.getPackage())) {
            continue;
        }

        if (preferredIntent.resolveActivityInfo(pm, /* flags= */ 0) != null) {
            return preferredIntent;
        }
    }
    return defaultIntent;
}","private Intent getMapsIntent() {
        Intent mapsIntent = null;
        List<ResolveInfo> resolveInfos = packageManager.getResolveInfo(new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=1"")), PackageManager.MATCH_DEFAULT_ONLY);
        for (ResolveInfo resolveInfo : resolveInfos) {
            String packageName = resolveInfo.activityInfo.packageName;
            if (mapsIntent == null) {
                mapsIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=1""));
                mapsIntent.setPackage(packageName);
            }
        }
        if (mapsIntent == null) {
            mapsIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=1""));
        }
        return mapsIntent;
    }","private Intent getMapsIntent() {
        Intent mapsIntent = null;
        List<ResolveInfo> resolveInfos = packageManager.getResolveInfo(new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=1"")), PackageManager.MATCH_DEFAULT_ONLY);
        for (ResolveInfo resolveInfo : resolveInfos) {
            String packageName = resolveInfo.activityInfo.packageName;
            if (mapsIntent == null) {
                mapsIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=1""));
                mapsIntent.setPackage(packageName);
            }
        }
        if (mapsIntent == null) {
            mapsIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=1""));
        }
        return mapsIntent;
    }",17.942007654747442,7.685900171694265,8.6708750360401,19.696969696969695,35.714285714285715
39,java,"private void initializeCards() {
    if (mHomeCardModules == null) {
        mHomeCardModules = new ArraySet<>();
        for (String providerClassName : getResources().getStringArray(
                R.array.config_homeCardModuleClasses)) {
            try {
                long reflectionStartTime = System.currentTimeMillis();
                HomeCardModule cardModule = (HomeCardModule) Class.forName(
                        providerClassName).newInstance();
                cardModule.setViewModelProvider(new ViewModelProvider( /* owner= */this));
                mHomeCardModules.add(cardModule);
                if (DEBUG) {
                    long reflectionTime = System.currentTimeMillis() - reflectionStartTime;
                    Log.d(TAG, ""Initialization of HomeCardModule class "" + providerClassName
                            + "" took "" + reflectionTime + "" ms"");
                }
            } catch (IllegalAccessException | InstantiationException |
                    ClassNotFoundException e) {
                Log.w(TAG, ""Unable to create HomeCardProvider class "" + providerClassName, e);
            }
        }
    }
    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    for (HomeCardModule cardModule : mHomeCardModules) {
        transaction.replace(cardModule.getCardResId(), cardModule.getCardView());
    }
    transaction.commitNow();
}","private void initializeCards() {
    for (String className : cardModuleConfigs) {
        try {
            Class<?> clazz = Class.forName(className);
            HomeCardModule module = (HomeCardModule) clazz.newInstance();
            fragmentTransaction.add(R.id.card_container, module.getCardView());
            cardModules.add(module);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}","private void initializeCards() {
    for (String className : cardModuleConfigs) {
        try {
            Class<?> clazz = Class.forName(className);
            HomeCardModule module = (HomeCardModule) clazz.newInstance();
            fragmentTransaction.add(R.id.card_container, module.getCardView());
            cardModules.add(module);
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}",18.823075748524705,3.0571629488075605,6.564810374961591,29.67032967032967,36.0
40,java,"private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
    ActivityTaskManager atm = ActivityTaskManager.getInstance();
    for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
        TaskInfo taskInfo = taskAppearedInfo.getTaskInfo();
        if (taskInfo.getWindowingMode() == WINDOWING_MODE_MULTI_WINDOW) {
            if (DBG) Slog.d(TAG, ""Found the dangling task, removing: "" + taskInfo.taskId);
            atm.removeTask(taskInfo.taskId);
        }
    }
}","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
    for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
        if (taskAppearedInfo.isMultiWindow()) {
            ActivityTaskManager.removeTask(taskAppearedInfo.taskId);
            Slog.w(""ActivityTaskManager"", ""Removing dangling task: "" + taskAppearedInfo.taskId);
        }
    }
}","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
    for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
        if (taskAppearedInfo.isMultiWindow()) {
            ActivityTaskManager.removeTask(taskAppearedInfo.taskId);
            Slog.w(""ActivityTaskManager"", ""Removing dangling task: "" + taskAppearedInfo.taskId);
        }
    }
}",34.682392179436995,26.443806118509777,30.46758078105638,50.0,31.818181818181817
41,java,"private void updateMode() {
    mMode = parseMode(getIntent());
    setTitle(mMode.mTitleStringId);
    CarUi.requireToolbar(this).setTitle(mMode.mTitleStringId);
}","private void updateMode() {
    if (currentIntent != null && currentIntent.hasExtra(Intent.EXTRA_MODE)) {
        int mode = currentIntent.getIntExtra(Intent.EXTRA_MODE, CarModeController.MODE_UNKNOWN);
        setTitle(mode);
    }
}

private void setTitle(int mode) {
    activityTitle = getResources().getString(getModeTitleResourceId(mode));
    toolbarTitle = getResources().getString(getModeTitleResourceId(mode));

    if (activity != null) {
        activity.setTitle(activityTitle);
    }

    if (carUiToolbar != null) {
        carUiToolbar.setTitle(toolbarTitle);
    }
}

private int getModeTitleResourceId(int mode) {
    switch (mode) {
        case CarModeController.MODE_DRIVING:
            return R.string.driving_mode;
        case CarModeController.MODE_NAVIGATION:
            return R.string.navigation_mode;
        case CarModeController.MODE_MEDIA:
            return R.string.media_mode;
        case CarModeController.MODE_PHONE:
            return R.string.phone_mode;
        case CarModeController.MODE_EMPTY:
            return R.string.empty_mode;
        default:
            return R.string.unknown_mode;
    }
}","private void updateMode() {
    if (currentIntent != null && currentIntent.hasExtra(Intent.EXTRA_MODE)) {
        int mode = currentIntent.getIntExtra(Intent.EXTRA_MODE, CarModeController.MODE_UNKNOWN);
        setTitle(mode);
    }
}

private void setTitle(int mode) {
    int titleResourceId = getModeTitleResourceId(mode);
    activityTitle = getResources().getString(titleResourceId);
    toolbarTitle = getResources().getString(titleResourceId);

    if (activity != null) {
        activity.setTitle(activityTitle);
    }

    if (carUiToolbar != null) {
        carUiToolbar.setTitle(toolbarTitle);
    }
}

private int getModeTitleResourceId(int mode) {
    switch (mode) {
        case CarModeController.MODE_DRIVING:
            return R.string.driving_mode;
        case CarModeController.MODE_NAVIGATION:
            return R.string.navigation_mode;
        case CarModeController.MODE_MEDIA:
            return R.string.media_mode;
        case CarModeController.MODE_PHONE:
            return R.string.phone_mode;
        case CarModeController.MODE_EMPTY:
            return R.string.empty_mode;
        default:
            return R.string.unknown_mode;
    }
}",34.70630116660837,3.04313793445871,31.02016197006999,38.095238095238095,66.66666666666666
42,java,"private Chronometer getChronometer() {
    if (mChronometer == null) {
        mChronometer = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer);
        mChronometerSeparator = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer_separator);
    }
    return mChronometer;
}","private Chronometer getChronometer() {
    Chronometer chronometer = (Chronometer) findViewById(R.id.chronometer);
    View separator = findViewById(R.id.separator);
    chronometer.setSeparatorView(separator);
    return chronometer;
}","private Chronometer getChronometer() {
    Chronometer chronometer = (Chronometer) findViewById(R.id.chronometer);
    View separator = findViewById(R.id.separator);
    if (chronometer != null && separator != null) {
        chronometer.setSeparatorView(separator);
    }
    return chronometer;
}",34.68545887126855,12.991916506579942,18.05761128618656,38.46153846153847,69.23076923076923
43,java,"private View getMediaLayoutView() {
    if (mMediaLayoutView == null) {
        ViewStub stub = getRootView().findViewById(R.id.media_layout);
        mMediaLayoutView = stub.inflate();
        mMediaTitle = mMediaLayoutView.findViewById(R.id.primary_text);
        mMediaSubtitle = mMediaLayoutView.findViewById(R.id.secondary_text);
        View mediaControlBarView = mMediaLayoutView.findViewById(
                R.id.media_playback_controls_bar);
        mPresenter.initializeControlsActionBar(mediaControlBarView);
    }
    return mMediaLayoutView;
}","private View getMediaLayoutView() {
    ViewStub viewStub = (ViewStub) findViewById(R.layout.media_stub);
    View inflatedView = viewStub.inflate();

    TextView titleView = (TextView) inflatedView.findViewById(R.id.media_title);
    TextView subtitleView = (TextView) inflatedView.findViewById(R.id.media_subtitle);

    MediaPlaybackControlsBarPresenter presenter = new MediaPlaybackControlsBarPresenter(this);
    View controlsBar = inflatedView.findViewById(R.id.media_controls);
    presenter.bind(controlsBar);

    return inflatedView;
}","private View getMediaLayoutView() {
    ViewStub viewStub = (ViewStub) findViewById(R.layout.media_stub);
    View inflatedView = viewStub.inflate();

    TextView titleView = (TextView) inflatedView.findViewById(R.id.media_title);
    TextView subtitleView = (TextView) inflatedView.findViewById(R.id.media_subtitle);

    MediaPlaybackControlsBarPresenter presenter = new MediaPlaybackControlsBarPresenter(this);
    View controlsBar = inflatedView.findViewById(R.id.media_controls);
    presenter.bind(controlsBar);

    return inflatedView;
}",35.6758140019517,9.261204717392419,10.907969494103243,60.46511627906976,62.06896551724138
44,java,"private void updateBackgroundImage(Drawable image) {
    if (image != null && getCardSize() != null) {
        int maxDimen = Math.max(getCardSize().getWidth(), getCardSize().getHeight());
        Size scaledSize = new Size(maxDimen, maxDimen);
        Bitmap imageBitmap = BitmapUtils.fromDrawable(image, scaledSize);
        Bitmap blurredBackground = ImageUtils.blur(getContext(), imageBitmap, scaledSize,
                mBlurRadius);

        getCardBackgroundImage().setImageBitmap(blurredBackground, /* showAnimation= */ true);
        getCardBackground().setVisibility(View.VISIBLE);
    }
}","private void updateBackgroundImage(Drawable image) {
        if (image == null || cardSize == 0) {
            return;
        }

        int size = Math.max(cardSize, cardSize);
        Bitmap scaledBitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(scaledBitmap);
        image.setBounds(0, 0, size, size);
        image.draw(canvas);

        Bitmap blurredBitmap = scaledBitmap.copy(Bitmap.Config.ARGB_8888, true);
        RenderScript rs = RenderScript.create(context);
        ScriptIntrinsicBlur blur = ScriptIntrinsicBlur.create(rs, blurredBitmap.getWidth(), blurredBitmap.getHeight());
        blur.setRadius(10);
        blur.setInput(rs, scaledBitmap);
        blur.forEach(rs);
        rs.sync(blurredBitmap);
        rs.destroy();

        cardBackground.setImageBitmap(blurredBitmap);
    }","private void updateBackgroundImage(Drawable image) {
        if (image == null || cardSize == 0) {
            return;
        }

        int size = Math.max(cardSize, cardSize);
        Bitmap scaledBitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(scaledBitmap);
        image.setBounds(0, 0, size, size);
        image.draw(canvas);

        Bitmap blurredBitmap = scaledBitmap.copy(Bitmap.Config.ARGB_8888, true);
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR1) {
            blurredBitmap = scaledBitmap.extractAlpha();
        }
        
        cardBackground.setImageBitmap(blurredBitmap);
    }",33.38899452900671,14.128129251952778,18.14579758202279,34.61538461538461,66.66666666666666
45,java,"private void updateMediaView(CharSequence title, CharSequence subtitle) {
    getMediaLayoutView().setVisibility(View.VISIBLE);
    mMediaTitle.setText(title);
    mMediaSubtitle.setText(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
    mediaLayoutView.setVisibility(View.VISIBLE);
    mediaLayoutView.setTitle(title);
    mediaLayoutView.setSubtitle(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
    mediaLayoutView.setVisibility(View.VISIBLE);
    mediaLayoutView.setTitle(title);
    mediaLayoutView.setSubtitle(subtitle);
}",70.842490254843,59.004687263928076,61.207379018601806,63.1578947368421,100.0
46,java,"private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        getChronometer().setVisibility(View.VISIBLE);
        getChronometer().setBase(content.getStartTime());
        getChronometer().start();
        mChronometerSeparator.setVisibility(View.VISIBLE);
    } else {
        getChronometer().setVisibility(View.GONE);
        mChronometerSeparator.setVisibility(View.GONE);
    }
}","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        Chronometer chronometer = new Chronometer();
        Separator separator = new Separator();

        chronometer.setBaseTime(content.getStartTime());
        chronometer.start();

        chronometer.setVisible(true);
        separator.setVisible(true);
    } else {
        Chronometer chronometer = new Chronometer();
        Separator separator = new Separator();

        chronometer.setVisible(false);
        separator.setVisible(false);
    }
}","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        Chronometer chronometer = new Chronometer();
        Separator separator = new Separator();

        chronometer.setBaseTime(content.getStartTime());
        chronometer.start();

        chronometer.setVisible(true);
        separator.setVisible(true);
    } else {
        Chronometer chronometer = new Chronometer();
        Separator separator = new Separator();

        chronometer.setVisible(false);
        separator.setVisible(false);
    }
}",44.90822102508646,26.135466160433346,55.164084606579166,33.33333333333333,65.0
47,java,"public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(mCallback);
    }
}","public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(this);
    }
}","public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(this);
    }
}",74.36357747171822,79.10665071754359,79.88612070779082,38.46153846153847,100.0
48,java,"public void onCallRemoved(Call call) {
    mCurrentCall = null;
    mCardContent = null;
    mPresenter.onModelUpdated(this);
    if (call != null) {
        call.unregisterCallback(mCallback);
    }
}","public void onCallRemoved(Call call) {
        call.clearCurrentCall();
        call.clearCardContent();
        presenter.onModelUpdated();
        call.unregisterCallback(this);
    }","public void onCallRemoved(Call call) {
        call.clearCurrentCall();
        call.clearCardContent();
        presenter.onModelUpdated();
        call.unregisterCallback(this);
    }",27.14916922548058,15.124760523215706,20.61477352156375,30.0,42.857142857142854
49,java,"void updateModelWithPhoneNumber(String number) {
    String formattedNumber = TelecomUtils.getFormattedNumber(mContext, number);
    mCardContent = new DescriptiveTextWithControlsView(null, formattedNumber,
            mOngoingCallSubtitle, mElapsedTimeClock.millis(), mMuteButton, mEndCallButton,
            mDialpadButton);
    mPresenter.onModelUpdated(this);
}","void updateModelWithPhoneNumber(String number) {
        DescriptiveTextWithControlsView view = new DescriptiveTextWithControlsView(number);
        presenter.onModelUpdated(view);
    }","void updateModelWithPhoneNumber(String number) {
        DescriptiveTextWithControlsView view = new DescriptiveTextWithControlsView(number);
        presenter.onModelUpdated(view);
    }",14.306789336892923,11.682950752097785,15.6830954843628,11.11111111111111,18.75
50,java,"private void initializeAudioControls() {
    mMuteButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_mic_off),
            v -> {
                mInCallService.setMuted(mMuteCallToggle);
                mMuteCallToggle = !mMuteCallToggle;
            });
    mEndCallButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_call_end_button),
            v -> mCurrentCall.disconnect());
    mDialpadButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_dialpad), this::onClick);
}","private void initializeAudioControls() {
    muteButton.setIcon(muteIcon);
    muteButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            toggleMute();
        }
    });

    endCallButton.setIcon(endCallIcon);
    endCallButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            endCall();
        }
    });

    dialpadButton.setIcon(dialpadIcon);
    dialpadButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            showDialpad();
        }
    });
}","private void initializeAudioControls() {
    muteButton.setIcon(muteIcon);
    muteButton.setOnClickListener(v -> toggleMute());

    endCallButton.setIcon(endCallIcon);
    endCallButton.setOnClickListener(v -> endCall());

    dialpadButton.setIcon(dialpadIcon);
    dialpadButton.setOnClickListener(v -> showDialpad());
}",15.438458894904795,6.814190323744593,8.950340443040359,13.636363636363635,32.35294117647059
53,cpp,"void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    (void)_subscription;
    if (dbusConnection_->isConnected())
        _listener(AvailabilityStatus::AVAILABLE);
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (dbusConnectionActive()) {
        _listener.notify(AVAILABLE);
    }
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (dbusConnectionActive()) {
        _listener.notify(AVAILABLE);
    }
}",53.34236306735555,54.37427682227519,61.16908849062524,47.82608695652174,50.0
54,cpp,"void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (connections_.end() != connections_.find(conn)) {
        bool found(false);
        std::vector<std::thread*>::const_iterator it = threads_.begin();
        while (!found && it != threads_.end()) {
            found = (&t == *it++);
        }
        if (!found) {
            threads_.push_back(&t);
        }
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(exit_mutex);
    if (conn_active(conn) && exit_threads.find(conn) == exit_threads.end()) {
        exit_threads.insert(conn);
        t.joinable();
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(exit_mutex);
    if (conn_active(conn) && exit_threads.find(conn) == exit_threads.end()) {
        exit_threads.insert(conn);
    }
}",26.835115926637226,14.435318690471046,20.015119440630293,43.47826086956522,29.411764705882355
56,cpp,"void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (NULL == static_cast<WatchContext*>(data)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data (WatchContext) == NULL"");
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));
    if (dbusWatch != NULL) {
        if(dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
        }
        dbus_watch_set_data(libdbusWatch, NULL, NULL);
    }
}","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    libdbusWatch->stopMonitoring();
    DBusObject* object = static_cast<DBusObject*>(data);
    object->removeWatch(libdbusWatch);
}","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    libdbusWatch->stopMonitoring();
    DBusObject* object = static_cast<DBusObject*>(data);
    object->removeWatch(libdbusWatch);
}",33.467651534678275,7.5287191398645685,14.372190029151557,48.333333333333336,63.63636363636363
57,cpp,"void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    WatchContext* watchContext = static_cast<WatchContext*>(data);

    if (NULL == watchContext) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""watchContext == NULL"");
        return;
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));

    if (dbusWatch == NULL) {
        DBusWatch* dbusWatch = new DBusWatch(libdbusWatch, watchContext->mainLoopContext_, watchContext->dbusConnection_);
        dbusWatch->addDependentDispatchSource(watchContext->dispatchSource_);
        dbus_watch_set_data(libdbusWatch, dbusWatch, NULL);

        if (dbusWatch->isReadyToBeWatched()) {
            dbusWatch->startWatching();
        }
    } else {
        if (!dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
            dbus_watch_set_data(libdbusWatch, NULL, NULL);
        } else {
            dbusWatch->startWatching();
        }
    }
}","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    DBusWatchWrapper* wrapper = static_cast<DBusWatchWrapper*>(data);
    if (!wrapper->watch) {
        wrapper->watch = libdbusWatch;
        wrapper->ready = true;
    }

    if (wrapper->ready) {
        dbus_watch_acquire(wrapper->watch);
    } else {
        dbus_watch_release(wrapper->watch);
    }
}","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    DBusWatchWrapper* wrapper = static_cast<DBusWatchWrapper*>(data);
    if (!wrapper->watch) {
        wrapper->watch = libdbusWatch;
        wrapper->ready = true;
    }

    if (wrapper->ready) {
        dbus_watch_acquire(wrapper->watch);
    } else {
        dbus_watch_release(wrapper->watch);
    }
}",24.64069013721395,8.076989524606365,11.814442352920768,36.36363636363637,42.30769230769231
58,cpp,"const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> itsLock(objectManagerGuard_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return dbusObjectManager_;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!objectManager_) {
        std::lock_guard<std::mutex> lock(objectManagerMutex_);
        if (!objectManager_) {
            objectManager_ = std::make_shared<DBusObjectManager>();
        }
    }
    return objectManager_;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!objectManager_) {
        std::lock_guard<std::mutex> lock(objectManagerMutex_);
        if (!objectManager_) {
            objectManager_ = std::make_shared<DBusObjectManager>();
        }
    }
    return objectManager_;
}",50.7044328105981,28.655154863609056,29.931807148014112,69.23076923076923,75.0
59,cpp,"bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    DBusError dbusError;
    bool isServiceNameReleased = false;
    std::lock_guard<std::recursive_mutex> dbusConnectionLock(connectionGuard_);
    auto conIter = connectionNameCount_.find(serviceName);
    if (conIter != connectionNameCount_.end()) {
        if (conIter->second == 1) {
            const int libdbusStatus = dbus_bus_release_name(connection_,
                            serviceName.c_str(),
                            &dbusError.libdbusError_);
            isServiceNameReleased = (libdbusStatus == DBUS_RELEASE_NAME_REPLY_RELEASED);
            if (isServiceNameReleased) {
                connectionNameCount_.erase(conIter);
            }
        } else {
            conIter->second--;
            isServiceNameReleased = true;
        }
    }
    return isServiceNameReleased;
}","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    std::lock_guard<std::mutex> lock(serviceNameLocks_);
    auto it = serviceNameCounts_.find(serviceName);
    if (it == serviceNameCounts_.end()) {
        return false;
    }

    it->second--;
    if (it->second == 0) {
        serviceNameCounts_.erase(it);
        bus_->releaseName(serviceName);
    }

    return true;
}","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    std::lock_guard<std::mutex> lock(serviceNameLocks_);
    auto it = serviceNameCounts_.find(serviceName);
    if (it == serviceNameCounts_.end()) {
        return false;
    }

    if (it->second == 0) {
        return false;
    }

    it->second--;
    if (it->second == 0) {
        serviceNameCounts_.erase(it);
        bus_->releaseName(serviceName);
    }

    return true;
}",31.332124789674275,11.262871934359715,12.637055795765937,61.42857142857143,40.0
60,cpp,"DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (NULL == _libdbusPendingCall) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""_libdbusPendingCall == NULL"");
        return DBusMessage();
    }

    ::DBusMessage* libdbusMessage = dbus_pending_call_steal_reply(_libdbusPendingCall);
    const bool increaseLibdbusMessageReferenceCount = false;
    DBusMessage dbusMessage(libdbusMessage, increaseLibdbusMessageReferenceCount);

    return dbusMessage;
}","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (!_libdbusPendingCall) {
        return DBusMessage();
    }

    DBusMessage reply = DBusMessage::createReply(_libdbusPendingCall->reply);
    return reply;
}","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (!_libdbusPendingCall) {
        return DBusMessage();
    }

    DBusMessage reply(DBusMessage( _libdbusPendingCall->reply));
    return reply;
}",32.68015752678748,13.270396118241926,17.450233988908003,33.33333333333333,66.66666666666666
61,cpp,"void DBusConnection::deleteAsyncHandlers() {
    std::vector<DBusMessageReplyAsyncHandler*> asyncHandlers;
    {
        std::lock_guard<std::mutex> asyncHandlersLock(asyncHandlersToDeleteMutex_);
        asyncHandlers = asyncHandlersToDelete_;
        asyncHandlersToDelete_.clear();
    }

    auto it = asyncHandlers.begin();
    while(it != asyncHandlers.end()) {
        delete *it;
        it = asyncHandlers.erase(it);
    }
}","void DBusConnection::deleteAsyncHandlers() {
    std::vector<AsyncHandler*> handlers = async_handlers;
    std::lock_guard<std::mutex> lock(async_handlers_mutex);
    async_handlers.clear();
    for (AsyncHandler* handler : handlers) {
        delete handler;
    }
}","void DBusConnection::deleteAsyncHandlers() {
    std::vector<AsyncHandler*> handlers = async_handlers;
    std::lock_guard<std::mutex> lock(async_handlers_mutex);
    async_handlers.clear();
    for (AsyncHandler* handler : handlers) {
        delete handler;
    }
}",27.347121190612437,5.000133233031591,5.578827719894365,57.14285714285714,41.66666666666667
62,cpp,"void DBusConnection::handleSignalStates() {
    std::map<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>, std::set<uint32_t>> tmpHandlers;
    {
        std::lock_guard<std::mutex> itsLock(signalStateHandlersMutex_);
        tmpHandlers = signalStateHandlers_;
    }
    for (auto itsHandler : tmpHandlers) {
        for (uint32_t tag : itsHandler.second) {
            itsHandler.first->onSpecificError(CommonAPI::CallStatus::SUCCESS, tag);
        }
    }
}","void DBusConnection::handleSignalStates() {
    lock.lock();
    for (auto& signalHandler : signalHandlers) {
        signalHandler.onSpecificError(SUCCESS, signalHandler.signalTag);
    }
    lock.unlock();
}","void DBusConnection::handleSignalStates() {
    std::lock_guard<std::mutex> lock(lock);
    for (auto& signalHandler : signalHandlers) {
        signalHandler.onSpecificError(SUCCESS, signalHandler.signalTag);
    }
}",19.907925780017983,3.7665624286663175,5.212966778362145,45.65217391304348,25.0
63,cpp,"void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::recursive_mutex> itsConnectionGuard(connectionsMutex_);
    auto itsConnection = connections_.find(_connectionId);

    if (itsConnection != connections_.end()) {
        connections_.erase(_connectionId);
    }
}","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> lock(mutex_);
    connections_.erase(_connectionId);
}","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}",64.2130571570321,34.11488281065382,35.237345817474555,100.0,87.5
64,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.hasMemberName(""InterfacesAdded"")) {
        instanceAvblStatusEvent_->onInterfacesAddedSignal(dbusMessage);
    } else if (dbusMessage.hasMemberName(""InterfacesRemoved"")) {
        instanceAvblStatusEvent_->onInterfacesRemovedSignal(dbusMessage);
   }
}","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.member() == ""InterfacesAdded"") {
        InterfacesAddedHandler(dbusMessage);
    } else if (dbusMessage.member() == ""InterfacesRemoved"") {
        InterfacesRemovedHandler(dbusMessage);
    }
}","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.member() == ""InterfacesAdded"") {
        InterfacesAddedHandler(dbusMessage);
    } else if (dbusMessage.member() == ""InterfacesRemoved"") {
        InterfacesRemovedHandler(dbusMessage);
    }
}",47.81387645409231,32.28213880040185,42.09025013285051,45.45454545454545,71.42857142857143
65,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(
        CommonAPI::CallStatus &_status,
        std::vector<DBusAddress> &_availableServiceInstances) {

    _availableServiceInstances.clear();
    DBusObjectManagerStub::DBusObjectPathAndInterfacesDict itsAvailableServiceInstances;
    registry_->getAvailableServiceInstances(proxy_.getDBusAddress().getService(),
            proxy_.getDBusAddress().getObjectPath(),
            itsAvailableServiceInstances);

    _status = CommonAPI::CallStatus::SUCCESS;
    translate(itsAvailableServiceInstances, _availableServiceInstances);
}","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    _availableServiceInstances.clear();
    std::vector<std::shared_ptr<DBusServiceInstance>> serviceInstances = m_registry->getAvailableServiceInstances();
    for (const auto& instance : serviceInstances) {
        _availableServiceInstances.push_back(DBusAddress(instance->getAddress()));
    }
    _status = CommonAPI::CallStatus::OK;
}","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    _availableServiceInstances.clear();
    if (m_registry) {
        std::vector<std::shared_ptr<DBusServiceInstance>> serviceInstances = m_registry->getAvailableServiceInstances();
        for (const auto& instance : serviceInstances) {
            _availableServiceInstances.push_back(DBusAddress(instance->getAddress()));
        }
        _status = CommonAPI::CallStatus::OK;
    } else {
        _status = CommonAPI::CallStatus::ERROR;
    }
}",47.658790789303175,12.480006420394119,24.259052840714684,68.18181818181817,85.71428571428571
66,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(
        const std::string &_instance,
        CallStatus &_callStatus,
        AvailabilityStatus &_availabilityStatus) {

    CommonAPI::Address itsAddress(""local"", observedCapiInterfaceName_, _instance);
    DBusAddress itsDBusAddress;
    DBusAddressTranslator::get()->translate(itsAddress, itsDBusAddress);

    _availabilityStatus = AvailabilityStatus::NOT_AVAILABLE;
    if (registry_->isServiceInstanceAlive(
            itsDBusAddress.getInterface(),
            itsDBusAddress.getService(),
            itsDBusAddress.getObjectPath())) {
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
    }
    _callStatus = CallStatus::SUCCESS;
}","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    std::string dbusAddress = _instance;
    try {
        DBus::Connection connection;
        DBus::ObjectProxy object = connection.getObject(DBus::Path(""/""), ""org.freedesktop.DBus"");
        DBus::MethodCall method = object.methodCall(""NameOwner"");
        method.append(dbusAddress);
        DBus::Response response = connection.call(method);
        std::string owner = response.value<std::string>();
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
        _callStatus = CallStatus::SUCCESS;
    } catch (DBus::Error& e) {
        _availabilityStatus = AvailabilityStatus::UNAVAILABLE;
        _callStatus = CallStatus::FAILURE;
    }
}","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    std::string dbusAddress = _instance;
    try {
        DBus::Connection connection;
        DBus::ObjectProxy object = connection.getObject(DBus::Path(""/""), ""org.freedesktop.DBus"");
        DBus::MethodCall method = object.methodCall(""NameOwner"");
        method.append(dbusAddress);
        DBus::Response response = connection.call(method);
        std::string owner = response.value<std::string>();
        if (!owner.empty()) {
            _availabilityStatus = AvailabilityStatus::AVAILABLE;
        } else {
            _availabilityStatus = AvailabilityStatus::UNAVAILABLE;
        }
        _callStatus = CallStatus::SUCCESS;
    } catch (DBus::Error& e) {
        _availabilityStatus = AvailabilityStatus::UNAVAILABLE;
        _callStatus = CallStatus::FAILURE;
    }
}",49.929466119001376,20.398135375875512,38.470055897515586,68.62745098039215,72.22222222222221
67,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    DBusInputStream dbusInputStream(_message);
    std::string dbusObjectPath;
    std::vector<std::string> dbusInterfaceNames;

    dbusInputStream >> dbusObjectPath;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read object path"");
    }

    dbusInputStream >> dbusInterfaceNames;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read interface names"");
    }

    for (const auto& dbusInterfaceName : dbusInterfaceNames) {
        if(auto itsProxy = proxyWeakPtr_.lock() &&
                dbusInterfaceName == observedDbusInterfaceName_ &&
                removeInterface(dbusObjectPath, dbusInterfaceName)) {
            (void)itsProxy;
            notifyInterfaceStatusChanged(dbusObjectPath, dbusInterfaceName, AvailabilityStatus::NOT_AVAILABLE);
        }
    }
}","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    std::vector<std::string> object_paths;
    std::vector<std::string> interface_names;

    if (!_message.get_interface_names(interface_names) || !_message.get_object_paths(object_paths)) {
        return;
    }

    for (const std::string& interface_name : interface_names) {
        if (interface_name == observed_interface_) {
            for (const std::string& object_path : object_paths) {
                listeners_.notifyListeners(object_path, ""NOT_AVAILABLE"");
            }
        }
    }
}","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    std::vector<std::string> object_paths;
    std::vector<std::string> interface_names;

    if (!_message.get_interface_names(interface_names) || !_message.get_object_paths(object_paths)) {
        return;
    }

    if (observed_interface_.empty()) {
        return;
    }

    for (const std::string& interface_name : interface_names) {
        if (interface_name == observed_interface_) {
            for (const std::string& object_path : object_paths) {
                listeners_.notifyListeners(object_path, ""NOT_AVAILABLE"");
            }
        }
    }
}",29.94809608173663,9.1167402000756,10.675644126870925,46.15384615384615,53.84615384615385
68,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(
        const std::string &_objectPath,
        const std::string &_interfaceName,
        const AvailabilityStatus &_availability) {
    CommonAPI::Address itsAddress;
    DBusAddress itsDBusAddress(proxy_.getDBusAddress().getService(),
                               _objectPath,
                               _interfaceName);

    DBusAddressTranslator::get()->translate(itsDBusAddress, itsAddress);

    notifyListeners(itsAddress.getAddress(), _availability);
}","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    CommonAPIAddress address(_objectPath, _interfaceName);
    emit interfaceStatusChanged(address, _availability);
}","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    CommonAPIAddress address(_objectPath, _interfaceName);
    emit interfaceStatusChanged(address, _availability);
}",47.62943537458409,38.524611244291904,40.24146728286929,39.02439024390244,72.72727272727273
69,cpp,"void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener,
                                           const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);

   std::weak_ptr<DBusProxy> itsdbusProxy = dbusProxy_->shared_from_this();
    dbusProxy_->getDBusConnection()->proxyPushFunctionToMainLoop<DBusConnection>(
            DBusProxy::notifySpecificListener,
            itsdbusProxy,
            _listener,
            _subscription);
}","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    QMetaObject::invokeMethod(this,
                               ""scheduleListenerNotification"",
                               Qt::QueuedConnection,
                               Q_ARG(const Listener &, _listener),
                               Q_ARG(const Subscription &, _subscription));
}

void DBusProxyStatusEvent::scheduleListenerNotification(const Listener &listener, const Subscription subscription) {
    Q_EMIT listenerAddedSignal(listener, subscription);
}","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    QMetaObject::invokeMethod(this,
                               ""scheduleListenerNotification"",
                               Qt::QueuedConnection,
                               Q_ARG(const Listener &, _listener),
                               Q_ARG(const Subscription &, _subscription));
}

void DBusProxyStatusEvent::scheduleListenerNotification(const Listener &listener, const Subscription subscription) {
    emit listenerAddedSignal(listener, subscription);
}",46.27866311077531,21.63255018246934,38.4821022606319,25.0,100.0
70,cpp,"void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener,
                                             const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);
    (void)_listener;
    auto listenerIt = listeners_.begin();
    while(listenerIt != listeners_.end()) {
        if(listenerIt->first == _subscription)
            listenerIt = listeners_.erase(listenerIt);
        else
            ++listenerIt;
    }
}","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> lock(mutex_);
    listeners_.erase(std::remove_if(listeners_.begin(), listeners_.end(),
                                     [&](const Listener& listener) {
                                         return listener.subscription == _subscription;
                                     }),
                     listeners_.end());
}","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> lock(mutex_);
    listeners_.erase(std::remove_if(listeners_.begin(), listeners_.end(),
                                     [&](const Listener& listener) {
                                         return listener.subscription == _subscription;
                                     }));
}",36.894520392485376,24.638371203706452,25.915900842425525,54.166666666666664,42.857142857142854
71,cpp,"void DBusProxyBase::addSignalStateHandler(
            std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler,
            const uint32_t _subscription) {
    connection_->addSignalStateHandler(_handler, _subscription);
}","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    m_connection->addSignalStateHandler(_handler, _subscription);
}","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    m_connection->addSignalStateHandler(_handler, _subscription);
}",71.38713623153023,42.268392163412415,43.28015276270854,100.0,100.0
72,cpp,"void
DBusProxyManager::instancesAsyncCallback(
        std::shared_ptr<Proxy> _proxy,
        const CommonAPI::CallStatus &_status,
        const std::vector<DBusAddress> &_availableServiceInstances,
        GetAvailableInstancesCallback &_call) {
    (void)_proxy;
    std::vector<std::string> itsAvailableInstances;
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        translate(_availableServiceInstances, itsAvailableInstances);
    }
    _call(_status, itsAvailableInstances);
}","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::Success) {
        std::vector<std::string> serviceInstances;
        for (const auto& address : _availableServiceInstances) {
            serviceInstances.push_back(address.ToString());
        }
        _call(CommonAPI::CallStatus::Success, serviceInstances);
    } else {
        _call(_status, {});
    }
}","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::Success) {
        std::vector<std::string> serviceInstances;
        for (const auto& address : _availableServiceInstances) {
            serviceInstances.push_back(address.ToString());
        }
        _call(CommonAPI::CallStatus::Success, serviceInstances);
    } else {
        _call(_status, std::vector<std::string>());
    }
}",58.58796162262071,30.189707990356624,43.606582944570675,68.88888888888889,91.66666666666666
73,cpp,"bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    const char* objectPath = dbusMessage.getObjectPath();
    const char* interfaceName = dbusMessage.getInterface();

    if (NULL == objectPath) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" objectPath == NULL"");
    }
    if (NULL == interfaceName) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" interfaceName == NULL"");
    }

    DBusInterfaceHandlerPath handlerPath(objectPath, interfaceName);

    std::unique_lock<std::recursive_mutex> itsLock(objectPathLock_);

    auto handlerIterator = dbusRegisteredObjectsTable_.find(handlerPath);
    const bool foundDBusInterfaceHandler = handlerIterator != dbusRegisteredObjectsTable_.end();
    bool dbusMessageHandled = false;

    if (foundDBusInterfaceHandler) {
        std::shared_ptr<DBusInterfaceHandler> dbusStubAdapterBase = handlerIterator->second.front();
        itsLock.unlock();
        dbusMessageHandled = dbusStubAdapterBase->onInterfaceDBusMessage(dbusMessage);
        return dbusMessageHandled;
    } else if (dbusMessage.hasInterfaceName(""org.freedesktop.DBus.Introspectable"")) {
        dbusMessageHandled = onIntrospectableInterfaceDBusMessage(dbusMessage);
    }

    return dbusMessageHandled;
}","bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.isMethodCall()) {
        const std::string& objectPath = dbusMessage.getInterface();
        const std::string& interface = dbusMessage.getMethodName();

        auto it = handlers_.find(objectPath);
        if (it != handlers_.end()) {
            auto& handlerMap = it->second;
            auto handlerIt = handlerMap.find(interface);
            if (handlerIt != handlerMap.end()) {
                return handlerIt->second(dbusMessage);
            }
        }

        if (interface == ""Introspectable"") {
            return handleIntrospectionRequest(dbusMessage);
        }
    } else if (dbusMessage.isError()) {
        logError(""Received error message: %s"", dbusMessage.getMessage());
    } else {
        logWarning(""Received unexpected message type: %s"", dbusMessage.getTypeString());
    }

    return false;
}","bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.isMethodCall()) {
        const std::string& objectPath = dbusMessage.getObjectPath();
        const std::string& interface = dbusMessage.getInterface();
        const std::string& methodName = dbusMessage.getMethodName();

        auto it = handlers_.find(objectPath);
        if (it != handlers_.end()) {
            auto& handlerMap = it->second;
            auto handlerIt = handlerMap.find(interface);
            if (handlerIt != handlerMap.end()) {
                return handlerIt->second(dbusMessage);
            }
        }

        if (interface == ""Introspectable"") {
            return handleIntrospectionRequest(dbusMessage);
        }
    } else if (dbusMessage.isError()) {
        logError(""Received error message: %s"", dbusMessage.getMessage());
    } else {
        logWarning(""Received unexpected message type: %s"", dbusMessage.getTypeString());
    }

    return false;
}",28.894131276583927,11.985921576236537,12.953537893033543,39.285714285714285,51.35135135135135
74,cpp,"bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath,
                                                std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    const auto& dbusRegisteredObjectsTableIter = dbusRegisteredObjectsTable_.find(dbusInterfaceHandlerPath);
    const bool isDBusInterfaceHandlerAlreadyAdded = (dbusRegisteredObjectsTableIter != dbusRegisteredObjectsTable_.end());

    if (isDBusInterfaceHandlerAlreadyAdded) {

        auto handler = find(dbusRegisteredObjectsTableIter->second.begin(), dbusRegisteredObjectsTableIter->second.end(), dbusInterfaceHandler);
        if (handler != dbusRegisteredObjectsTableIter->second.end()) {
            if (dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.ObjectManager"" ||
                    dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.Properties"") {
                return true;
            }
            return false;
        }
    }

    auto insertSuccess = addToRegisteredObjectsTable(dbusInterfaceHandlerPath, dbusInterfaceHandler);
    return insertSuccess;
}","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = handlers_.find(dbusInterfaceHandlerPath);
    if (it != handlers_.end()) {
        if (dbusInterfaceHandlerPath.interface == ""org.freedesktop.DBus.Introspectable"" ||
            dbusInterfaceHandlerPath.interface == ""org.freedesktop.DBus.ObjectManager"" ||
            dbusInterfaceHandlerPath.interface == ""org.freedesktop.DBus.Properties"") {
            return true;
        }
        return false;
    }
    handlers_[dbusInterfaceHandlerPath] = std::move(dbusInterfaceHandler);
    return true;
}","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = handlers_.find(dbusInterfaceHandlerPath);
    if (it != handlers_.end()) {
        return false;
    }
    if (dbusInterfaceHandlerPath.interface == ""org.freedesktop.DBus.Introspectable"" ||
        dbusInterfaceHandlerPath.interface == ""org.freedesktop.DBus.ObjectManager"" ||
        dbusInterfaceHandlerPath.interface == ""org.freedesktop.DBus.Properties"") {
        handlers_[dbusInterfaceHandlerPath] = std::move(dbusInterfaceHandler);
        return true;
    }
    handlers_[dbusInterfaceHandlerPath] = std::move(dbusInterfaceHandler);
    return true;
}",41.47072046190799,19.798032906802966,20.4896108455909,54.166666666666664,71.42857142857143
75,cpp,"bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    auto handlerRecord = dbusRegisteredObjectsTable_.find(ifpath);
    if (handlerRecord == dbusRegisteredObjectsTable_.end()) {
        dbusRegisteredObjectsTable_.insert({
            ifpath,
            std::vector<std::shared_ptr<DBusInterfaceHandler>>({handler})
        });
    }
    else {
        std::vector<std::shared_ptr<DBusInterfaceHandler>> handlerList = handlerRecord->second;
        auto adapter = find(handlerList.begin(), handlerList.end(), handler);
        if (adapter != handlerList.end()) {
            return false;
        }
        else {
            handlerList.push_back(handler);
            handlerRecord->second = handlerList;
        }
    }
    return true;
}","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    if (registeredObjectsTable.find(ifpath) != registeredObjectsTable.end()) {
        return false;
    }
    registeredObjectsTable[ifpath] = handler;
    return true;
}","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    if (registeredObjectsTable.count(ifpath) > 0) {
        return false;
    }
    registeredObjectsTable[ifpath] = handler;
    return true;
}",20.51965591887299,9.252937312255671,17.066650218657976,39.75903614457831,16.0
78,c,"void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t positive_sid = UDS_SID_ECU_RESET + 0x40;

  uint8_t tx_data[] = {positive_sid, reset_type};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_positive_reset_response(uint8_t reset_type) {
    uint8_t data[2];
    data[0] = 0x33;
    data[1] = reset_type;

    uint8_t tx_data[2];
    tx_data[0] = 0x33;
    tx_data[1] = reset_type;

    if (can_transmit(tx_data, 2) != CAN_OK) {
        log_error(""Failed to transmit positive reset response"");
    }
}","void send_positive_reset_response(uint8_t reset_type) {
    uint8_t data[2];
    data[0] = 0x33;
    data[1] = reset_type;

    if (iso_tp_transmit(0x33, data, 2) != CAN_OK) {
        log_error(""Failed to transmit positive reset response"");
    }
}",11.785196340098313,6.678694379891939,7.841770124886338,9.090909090909092,23.52941176470588
79,c,"void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    return;
  }

  uint8_t reset_type = data[1];

  if (reset_type == UDS_RESET_TYPE_HARD) {
    send_positive_reset_response(UDS_RESET_TYPE_HARD);

    k_sleep(K_MSEC(100));

    LOG_DBG(""Hard reset\n"");
    sys_reboot(SYS_REBOOT_COLD);
  } else {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_SUBFUNCTION_NOT_SUPPORTED);
  }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
    if (len != 2) {
        send_negative_response();
        return;
    }

    uint8_t sub_function = data[1];

    if (sub_function == 0x01) {
        send_positive_response();
        system_reboot();
    } else {
        send_negative_response();
    }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
    if (len != 2) {
        send_negative_response();
        return;
    }

    uint8_t sub_function = data[1];

    if (sub_function == 0x01) {
        send_positive_response();
        system_reboot();
    } else {
        send_negative_response();
    }
}",43.786582690981376,40.61398531981548,42.28428342860616,25.581395348837212,66.66666666666666
80,c,"void send_request_download_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_DOWNLOAD + 0x40;


  uint8_t tx_data[] = {
    positive_sid,
    0x20,  // positive response code
    0x00,
    0xD2,  // block size = 258 - 2
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_request_download_response() {
    uint8_t response[4] = {0x01, 0x00, 0xD2, 0x00};
    
    if (can_send_message(CAN_ID_REQUEST_DOWNLOAD_RESPONSE, response, 4) != CAN_OK) {
        log_error(""Failed to send Request Download response"");
    }
}","void send_request_download_response() {
    uint8_t response[4] = {0x01, 0x00, 0xD2, 0x00};
    
    if (can_send_message(CAN_ID_REQUEST_DOWNLOAD_RESPONSE, response, 4) != CAN_OK) {
        log_error(""Failed to send Request Download response"");
    }
}",6.034382587881448,1.7185282591626243,2.8356687590298373,6.25,13.333333333333334
81,c,"static void send_transfer_data_response(uint8_t block_sequence_counter) {
  int ret;
  uint8_t positive_sid = UDS_SID_TRANSFER_DATA + 0x40;

  uint8_t tx_data[] = {positive_sid, block_sequence_counter};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
    uint8_t sid = 0x7E;
    uint8_t response[2];
    response[0] = sid;
    response[1] = block_sequence_counter;

    if (CAN_Transmit(response, 2) != CAN_OK) {
        Error_Handler();
    }
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
    uint8_t sid = 0x7E;
    uint8_t response[2];
    response[0] = sid;
    response[1] = block_sequence_counter;

    if (CAN_Transmit(response, 2) != CAN_OK) {
        Error_Handler();
    }
}",15.357231839233275,9.0619356815352,11.190521087162603,11.76470588235294,29.411764705882355
82,c,"static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
  int ret;
  uint8_t positive_sid = UDS_SID_ROUTINE_CONTROL + 0x40;

  uint8_t tx_data[] = {positive_sid, 0x1, (routine_id >> 8) & 0xFF,
                       routine_id & 0xFF, result};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
    uint8_t uds_response[5];
    uds_response[0] = 0x7E;
    uds_response[1] = 0x04;
    uds_response[2] = 0x10;
    uds_response[3] = (uint8_t)(routine_id >> 8);
    uds_response[4] = (uint8_t)routine_id;

    if (can_iso_tp_send(uds_response, 5) != 0) {
        error_log(""CAN ISO-TP transmission failed"");
    }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
    uint8_t uds_response[5];
    uds_response[0] = 0x7E;
    uds_response[1] = 0x04;
    uds_response[2] = 0x10;
    uds_response[3] = (uint8_t)(routine_id >> 8);
    uds_response[4] = (uint8_t)routine_id;
    uds_response[4] = result;

    if (can_iso_tp_send(uds_response, 5) != 0) {
        error_log(""CAN ISO-TP transmission failed"");
    }
}",24.729853648501688,12.269673361321901,13.572818155761762,23.076923076923077,50.0
83,c,"static void send_transer_exit_positive_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_TRANSFER_EXIT + 0x40;

  uint8_t tx_data[] = {positive_sid};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transer_exit_positive_response() {
    uint8_t data[1];
    uint8_t sid = request_sid;
    data[0] = sid | 0x40;

    if (can_transmit(CAN_ID_RESPONSE, data, 1) != CAN_OK) {
        log_error(""Failed to transmit Transfer Exit positive response"");
    }
}","static void send_transer_exit_positive_response() {
    uint8_t data[1];
    uint8_t sid = request_sid;
    data[0] = sid | 0x40;

    if (can_transmit(CAN_ID_RESPONSE, data, 1) != CAN_OK) {
        log_error(""Failed to transmit Transfer Exit positive response"");
    }
}",12.03613602503381,7.623801394039263,8.399530584883854,12.121212121212121,20.0
85,c,"static inline uint8_t map_from_can_id(uint32_t can_id) {
  for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
    if (id_mapping[i] == can_id) {
      return i;
    }
  }

  return 0xff;
}","static inline uint8_t map_from_can_id(uint32_t can_id) {
    uint8_t i;
    for (i = 0; i < sizeof(id_mapping) / sizeof(id_mapping[0]); i++) {
        if (id_mapping[i] == can_id) {
            return i;
        }
    }
    return 0xff;
}","static inline uint8_t map_from_can_id(uint32_t can_id) {
    uint8_t i;
    for (i = 0; i < sizeof(id_mapping) / sizeof(id_mapping[0]); i++) {
        if (id_mapping[i] == can_id) {
            return i;
        }
    }
    return 0xff;
}",62.38283718567769,65.82199215756273,74.18554706133851,66.66666666666666,42.857142857142854
86,c,"static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
  struct lin2can_data *data = dev->data;

 if (filter_id == TRANSLATABLE_ADDRESSES_LEN) {
    for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
      data->incoming_callbacks[i].callback = 0;
    }

    return;
  }

  if (filter_id >= TRANSLATABLE_ADDRESSES_LEN) {
    return;
  }
  data->incoming_callbacks[filter_id].callback = 0;
}","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can *lin2can = dev->data;
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(lin2can->rx_filters); i++) {
			lin2can->rx_filters[i].cb = NULL;
		}
	} else if (filter_id < ARRAY_SIZE(lin2can->rx_filters)) {
		lin2can->rx_filters[filter_id].cb = NULL;
	}
}","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can *lin2can = dev->data;
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(lin2can->rx_filters); i++) {
			lin2can->rx_filters[i].cb = NULL;
		}
	} else if (filter_id >= 0 && filter_id < ARRAY_SIZE(lin2can->rx_filters)) {
		lin2can->rx_filters[filter_id].cb = NULL;
	}
}",40.385231249671605,30.945677410518524,35.15011301259853,47.61904761904761,47.82608695652174
87,c,"static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  struct lin2can_data *data = dev->data;
  struct k_msgq *outgoing_frame_buffer = data->outgoing_frame_queue;

  struct lin2can_outgoing_frame_t outgoing;
  if (k_msgq_get(outgoing_frame_buffer, &outgoing, K_NO_WAIT)) {
    return false;
  }

  memcpy(frame, &outgoing.frame, sizeof(*frame));

  LOG_DBG(""Calling can tx callback"");

  outgoing.callback(dev, 0, outgoing.user_data);

  return true;
}","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
    struct lin_message *msg;
    int ret;

    msg = lin_message_queue_get(user_data);
    if (!msg) {
        return false;
    }

    ret = frame->copy(frame->priv, msg->data, msg->len);
    if (ret < 0) {
        lin_message_queue_free(msg);
        return false;
    }

    ret = frame->complete(frame->priv, msg->len);
    lin_message_queue_free(msg);

    if (ret < 0) {
        return false;
    }

    return true;
}","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
    struct lin_message *msg;
    int ret;

    msg = lin_message_queue_get(user_data);
    if (!msg) {
        return false;
    }

    ret = frame->copy(frame->priv, msg->data, msg->len);
    if (ret < 0) {
        lin_message_queue_free(msg);
        return false;
    }

    ret = frame->complete(frame->priv, msg->len);
    lin_message_queue_free(msg);

    if (ret < 0) {
        return false;
    }

    return true;
}",34.99720763215715,21.133252857297926,22.476267326503095,41.37931034482759,55.00000000000001
88,c,"static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  const struct lin2can_data *data = dev->data;

 uint8_t mapped_id = frame->data[0] >> 6;

  __ASSERT(mapped_id < TRANSLATABLE_ADDRESSES_LEN, ""Unexpected LIN-ID: %x"",
           mapped_id);

  LOG_DBG(""Incoming can frame with can id %x"", id_mapping[mapped_id]);

 if (!data->incoming_callbacks[mapped_id].callback) {
    return;
  }

  struct can_frame translated = {
    .id = id_mapping[mapped_id],
    .dlc = 8,
  };
  memcpy(translated.data, frame->data, frame->len);

  translated.data[0] = frame->data[0] & 0x3f;

  LOG_DBG(""Calling according can callback"");

  data->incoming_callbacks[mapped_id].callback(
      dev, &translated, data->incoming_callbacks[mapped_id].user_data);
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
    uint8_t index = (frame->data[0] >> 6) & 0x03;
    uint32_t can_id;

    switch (index) {
        case 0:
            can_id = 0x123;
            break;
        case 1:
            can_id = 0x456;
            break;
        case 2:
            can_id = 0x789;
            break;
        case 3:
            can_id = 0xABC;
            break;
        default:
            can_id = 0x000;
            break;
    }

    struct can_frame can_frame;
    can_frame.id = can_id;
    can_frame.dlc = frame->dlc - 1;
    memcpy(can_frame.data, frame->data + 1, can_frame.dlc);

    auto handler = (void (*)(struct can_frame))user_data;
    if (handler) {
        handler(can_frame);
    }
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
    uint8_t index = (frame->data[0] >> 6) & 0x03;
    uint32_t can_id;

    switch (index) {
        case 0:
            can_id = 0x123;
            break;
        case 1:
            can_id = 0x456;
            break;
        case 2:
            can_id = 0x789;
            break;
        case 3:
            can_id = 0xABC;
            break;
        default:
            can_id = 0x000;
            break;
    }

    struct can_frame can_frame;
    can_frame.id = can_id;
    can_frame.dlc = frame->dlc - 1;
    if (can_frame.dlc > 8) {
        can_frame.dlc = 8;
    }
    memcpy(can_frame.data, frame->data + 1, can_frame.dlc);

    auto handler = (void (*)(struct can_frame))user_data;
    if (handler) {
        handler(can_frame);
    }
}",25.134947535858466,12.080392656908085,14.378937716410814,39.08045977011494,35.0
89,c,"static int hv_shield_init(const struct device* dev) {
  const struct hv_shield_config_t* config = dev->config;
  struct hv_shield_data_t* data = dev->data;

  int err = gpio_pin_configure_dt(&config->oe_gpio_spec, GPIO_OUTPUT_INACTIVE);
  if (err) {
    LOG_ERR(""Error setting up Output enable pin (%d)"", err);
    return err;
  }

  memset(&data->registers, 0, sizeof(data->registers));

  err = _hv_shield_update(dev);
  if (err) {
    LOG_ERR(""Error writing registers (%d)"", err);
    return err;
  }

  err = gpio_pin_set_dt(&config->oe_gpio_spec, 1);
  if (err) {
    LOG_ERR(""Error setting enabling output (%d)"", err);
  }

  return err;
}","static int hv_shield_init(const struct device* dev) {
    int ret;

    ret = gpio_request(dev->config->oe_gpio, ""hv_shield_oe"");
    if (ret) {
        dev_err(dev, ""Failed to request OE GPIO: %d\n"", ret);
        return ret;
    }

    ret = gpio_direction_output(dev->config->oe_gpio, 0);
    if (ret) {
        dev_err(dev, ""Failed to set OE GPIO direction: %d\n"", ret);
        gpio_free(dev->config->oe_gpio);
        return ret;
    }

    memset(dev->config->reg_base, 0, dev->config->reg_size);

    ret = ioremap(dev->config->reg_base, dev->config->reg_size);
    if (ret) {
        dev_err(dev, ""Failed to ioremap registers: %d\n"", ret);
        gpio_free(dev->config->oe_gpio);
        return ret;
    }

    gpio_set_value(dev->config->oe_gpio, 1);

    return 0;
}","static int hv_shield_init(const struct device* dev) {
    int ret;

    ret = gpio_request(dev->config->oe_gpio, ""hv_shield_oe"");
    if (ret) {
        dev_err(dev, ""Failed to request OE GPIO: %d\n"", ret);
        return ret;
    }

    ret = gpio_direction_output(dev->config->oe_gpio, 0);
    if (ret) {
        dev_err(dev, ""Failed to set OE GPIO direction: %d\n"", ret);
        gpio_free(dev->config->oe_gpio);
        return ret;
    }

    void *regs = ioremap(dev->config->reg_base, dev->config->reg_size);
    if (!regs) {
        dev_err(dev, ""Failed to ioremap registers\n"");
        gpio_free(dev->config->oe_gpio);
        return -ENOMEM;
    }

    memset(regs, 0, dev->config->reg_size);

    gpio_set_value(dev->config->oe_gpio, 1);

    iounmap(regs);

    return 0;
}",24.949957196569926,10.454077423493677,11.832894887797716,42.028985507246375,35.483870967741936
90,c,"static int hvs_set_dac_gain(const struct device* dev,
                            uint8_t dac,
                            enum hv_shield_dac_gains_t gain) {
  if (dac > 1) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;
  switch (dac) {
    case 0:
      data->registers.dac0 = gain;
      break;
    case 1:
      data->registers.dac1 = gain;
      break;
    default:
      return -EINVAL;
  }

  return _hv_shield_update(dev);
}","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
    if (dac != 0 && dac != 1) {
        return -EINVAL;
    }

    dev->hvs_dac_gains[dac] = gain;
    hvs_update_hw(dev);

    return 0;
}","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
    if (dac != 0 && dac != 1) {
        return -EINVAL;
    }

    dev->hvs_dac_gains[dac] = gain;
    hvs_update_hw(dev);

    return 0;
}",37.43375248916691,32.70794266268155,35.44811992556507,50.0,31.57894736842105
91,c,"static int hvs_set_gpio_output_enable(const struct device* dev,
                                      uint8_t index,
                                      bool enable) {
  if (index > 31) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;

  if (index % 8 < 4) {
    index += 4;
  } else {
    index -= 4;
  }

  if (enable) {
    data->registers.gpio_output |= 1 << index;
  } else {
    data->registers.gpio_output &= ~(1 << index);
  }

  return _hv_shield_update(dev);
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
    if (index > 31) {
        return -EINVAL;
    }

    uint8_t remapped_index = (index >> 4) | ((index & 0x0F) << 4);
    static uint8_t cached_register = 0;

    if (enable) {
        cached_register |= (1 << remapped_index);
    } else {
        cached_register &= ~(1 << remapped_index);
    }

    hvs_write_register(dev, HVS_GPIO_OUTPUT_ENABLE_REG, cached_register);

    return 0;
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
    if (index > 31) {
        return -EINVAL;
    }

    uint8_t remapped_index = (index >> 4) | ((index & 0x0F) << 4);
    static uint8_t cached_register = 0;

    if (enable) {
        cached_register |= (1 << remapped_index);
    } else {
        cached_register &= ~(1 << remapped_index);
    }

    hvs_write_register(dev, HVS_GPIO_OUTPUT_ENABLE_REG, cached_register);

    return 0;
}",39.55071032347305,33.952365235609726,34.62783454884848,39.62264150943396,50.0
92,c,"static void can_router_frame_cb(const struct device *dev,
                                struct can_frame *frame,
                                void *user_data) {
  const struct device *to = user_data;

  const int err = can_send(to, frame, K_NO_WAIT, can_router_tx_cb, NULL);
  if (err) {
    LOG_WRN(""Can send failed (%d)"", err);
    return;
  }

  LOG_DBG(""Routed frame from %s to %s"", dev->name, to->name);
}","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
    int ret;
    char debug_msg[64];

    snprintf(debug_msg, sizeof(debug_msg), ""Forwarding CAN frame: ID 0x%X"", frame->id);
    printk(debug_msg, frame->id);

    ret = can_transmit(user_data, frame, 0);

    if (ret == 0) {
        printk(""CAN frame successfully queued for transmission\n"");
    } else {
        printk(""Warning: Failed to queue CAN frame for transmission\n"");
    }
}","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
    int ret;
    char debug_msg[64];

    snprintf(debug_msg, sizeof(debug_msg), ""Forwarding CAN frame: ID 0x%X"", frame->id);
    printk(debug_msg, frame->id);

    ret = can_transmit(user_data, frame, 0);

    if (ret == 0) {
        printk(""CAN frame successfully queued for transmission\n"");
    } else {
        printk(""Warning: Failed to queue CAN frame for transmission\n"");
    }
}",46.703150453099305,22.449398371191094,28.52987010787279,52.5,83.33333333333334
93,c,"int can_router_register(const struct can_router_entry_t *entries,
                        int entry_count) {
  LOG_DBG(""Registering %d can router entries"", entry_count);
  for (int i = 0; i < entry_count; i++) {
    const int err =
        can_add_rx_filter(*entries[i].from, can_router_frame_cb,
                          (void *)*entries[i].to, &entries[i].filter);
    if (err) {
      return err;
    }
  }

  LOG_DBG(""Registered %d can router entries"", entry_count);

  return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
    int i;
    for (i = 0; i < entry_count; i++) {
        if (can_interface_add_receive_filter(entries[i].source_interface,
                                             entries[i].can_id,
                                             entries[i].callback,
                                             entries[i].mask) != 0) {
            return -1;
        }
    }
    return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
    int i;
    for (i = 0; i < entry_count; i++) {
        if (can_interface_add_receive_filter(entries[i].source_interface,
                                             entries[i].can_id,
                                             entries[i].callback,
                                             entries[i].mask) != 0) {
            return -1;
        }
    }
    return 0;
}",40.52657778536438,28.9885526563602,33.0033420091248,36.95652173913043,63.1578947368421
94,c,"static int can_router_sysinit() {
  LOG_DBG(""Initializing can router"");

  STRUCT_SECTION_FOREACH (can_router_table_t, table) {
    int err = can_router_register(table->entries, table->entry_count);
    if (err) {
      LOG_ERR(""could not register can router"");
      return err;
    }
  }

  return 0;
}","static int can_router_sysinit() {
    extern const struct can_route_entry *__attribute__((section("".can_routes"")) const struct can_route_entry *routes);
    const struct can_route_entry *current_route = routes;
    int error = 0;

    while (current_route->dest != 0) {
        if (can_route_register(current_route) != 0) {
            error = -1;
            break;
        }
        current_route++;
    }

    return error;
}","static int can_router_sysinit() {
    extern const struct can_route_entry *__attribute__((section("".can_routes"")) const struct can_route_entry *routes);
    const struct can_route_entry *current_route = routes;
    int error = 0;

    while (current_route->dest != 0) {
        if (can_route_register(current_route) != 0) {
            error = -1;
            break;
        }
        current_route++;
    }

    return error;
}",32.62257026860475,7.841770124886338,11.728970719647583,27.586206896551722,83.33333333333334
95,c,"static int hvs_set_masked_raw(const struct device* port,
                              gpio_port_pins_t mask,
                              gpio_port_value_t value) {
  const struct hv_shield_gpio_config_t* config = port->config;

  for (int i = 0; i < config->lv_gpios_count; i++) {
    if (!(mask & BIT(i))) continue;

    int ret = gpio_pin_set(config->lv_gpios[i].port, config->lv_gpios[i].pin,
                           !!(value & BIT(i)));
    if (ret < 0) {
      LOG_ERR(""Error settings gpio %d (error %d)"", i, ret);
      return ret;
    }
  }

  return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
    int i;
    int ret;
    gpio_port_pins_t pins = mask;

    for (i = 0; i < 32; i++) {
        if ((pins & (1 << i)) != 0) {
            ret = gpio_set_pin(port, i, (value & (1 << i)) ? GPIO_PIN_SET : GPIO_PIN_RESET);
            if (ret < 0) {
                LOG_ERROR(""Failed to set GPIO pin %d: %d\n"", i, ret);
                return ret;
            }
        }
    }

    return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
    int i;
    int ret;

    for (i = 0; i < 32; i++) {
        if ((mask & (1 << i)) != 0) {
            ret = gpio_set_pin(port, i, (value & (1 << i)) ? GPIO_PIN_SET : GPIO_PIN_RESET);
            if (ret < 0) {
                LOG_ERROR(""Failed to set GPIO pin %d: %d\n"", i, ret);
                return ret;
            }
        }
    }

    return 0;
}",41.81411429415599,37.20581488739988,43.54477527488249,28.8135593220339,57.692307692307686
96,c,"static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
  struct abstract_lin_data *data = dev->data;

  if (free_slots == NULL) {
    return -EINVAL;
  }

  *free_slots = CONFIG_ABSTRACT_LIN_MAX_FRAME_COUNT - data->used_callbacks;

  return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
    if (free_slots == NULL) {
        return -EINVAL;
    }

    *free_slots = al_max_cb_slots - al_used_cb_slots;
    return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
    if (free_slots == NULL) {
        return -EINVAL;
    }

    *free_slots = al_max_cb_slots - al_used_cb_slots;
    return 0;
}",57.26267781676262,60.562229523054434,61.82181507732941,66.66666666666666,40.0
97,c,"static int al_register_incoming_cb(const struct device *dev,
                                   abstract_lin_incoming_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = INCOMING;
  data->callbacks[free_index].incoming_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
        return -EINVAL;
    }

    if (!callback) {
        return -EINVAL;
    }

    static uint8_t next_callback_slot = 0;
    static struct incoming_callback callbacks[MAX_CALLBACKS];

    if (next_callback_slot >= MAX_CALLBACKS) {
        return -ENOMEM;
    }

    callbacks[next_callback_slot].frame_id = frame_id;
    callbacks[next_callback_slot].frame_size = frame_size;
    callbacks[next_callback_slot].callback = callback;
    callbacks[next_callback_slot].user_data = user_data;

    next_callback_slot++;

    return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
        return -EINVAL;
    }

    if (!callback) {
        return -EINVAL;
    }

    static uint8_t next_callback_slot = 0;
    static struct incoming_callback callbacks[MAX_CALLBACKS];

    if (next_callback_slot >= MAX_CALLBACKS) {
        return -ENOMEM;
    }

    callbacks[next_callback_slot].frame_id = frame_id;
    callbacks[next_callback_slot].frame_size = frame_size;
    callbacks[next_callback_slot].callback = callback;
    callbacks[next_callback_slot].user_data = user_data;

    next_callback_slot++;

    return 0;
}",46.44485595037279,45.00207833689593,46.51964238336274,32.35294117647059,61.904761904761905
98,c,"static int al_register_outgoing_cb(const struct device *dev,
                                   abstract_lin_outgoing_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = OUTGOING;
  data->callbacks[free_index].outgoing_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
        return -EINVAL;
    }

    if (!callback) {
        return -EINVAL;
    }

    int slot = -1;
    for (int i = 0; i < ARRAY_SIZE(outgoing_callbacks); ++i) {
        if (!outgoing_callbacks[i].callback) {
            slot = i;
            break;
        }
    }

    if (slot == -1) {
        return -ENOMEM;
    }

    outgoing_callbacks[slot].callback = callback;
    outgoing_callbacks[slot].frame_id = frame_id;
    outgoing_callbacks[slot].frame_size = frame_size;
    outgoing_callbacks[slot].user_data = user_data;

    return 0;
}","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
        return -EINVAL;
    }

    if (!callback) {
        return -EINVAL;
    }

    for (int i = 0; i < ARRAY_SIZE(outgoing_callbacks); ++i) {
        if (!outgoing_callbacks[i].callback) {
            outgoing_callbacks[i].callback = callback;
            outgoing_callbacks[i].frame_id = frame_id;
            outgoing_callbacks[i].frame_size = frame_size;
            outgoing_callbacks[i].user_data = user_data;
            return 0;
        }
    }

    return -ENOMEM;
}",47.39436323729909,47.15020163388299,48.16954823408086,32.35294117647059,61.904761904761905
99,c,"int abstract_lin_scheduler_set_active_table(
    abstract_lin_scheduler_handle_t sched, size_t table_index) {
  if (table_index >= sched->table_count) {
    return -ENOENT;
  }

  bool active_before = sched->current_table != -1;

  if (active_before) {
    k_sem_take(&sched->active, K_FOREVER);
  }

  sched->current_table = table_index;
  sched->current_table_entry = 0;  // start from the beginning again.

  k_sem_give(&sched->active);

  return 0;
}","int abstract_lin_scheduler_set_active_table(struct abstract_lin_scheduler *scheduler, int table_index) {
    if (table_index < 0 || table_index >= scheduler->num_tables) {
        return -1;
    }

    sem_wait(&scheduler->scheduler_lock);

    scheduler->active_table_index = table_index;
    scheduler->entry_pointer = scheduler->table_start_addresses[table_index];

    sem_post(&scheduler->scheduler_lock);

    return 0;
}","int abstract_lin_scheduler_set_active_table(struct abstract_lin_scheduler *scheduler, int table_index) {
    if (table_index < 0 || table_index >= scheduler->num_tables) {
        return -1;
    }

    sem_wait(&scheduler->scheduler_lock);

    scheduler->active_table_index = table_index;
    scheduler->entry_pointer = scheduler->table_start_addresses[table_index];

    sem_post(&scheduler->scheduler_lock);

    return 0;
}",30.751960024872048,9.74720907864249,11.155367862950985,42.10526315789473,60.0
100,c,"void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
  if (sched->current_table == -1) {
    return;  // already stopped.
  }

  k_sem_take(&sched->active, K_FOREVER);

  sched->current_table = -1;
}","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
    if (sched->stopped) {
        return;
    }

    sem_wait(&sched->completion_sem);
    sched->active_schedule_table_index = -1;
    sched->stopped = true;
}","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
    if (sched->stopped) {
        return;
    }

    sem_wait(&sched->completion_sem);
    sched->active_schedule_table_index = -1;
    sched->stopped = true;
}",51.16177453360028,24.18725281766432,25.45984531673679,55.00000000000001,100.0
