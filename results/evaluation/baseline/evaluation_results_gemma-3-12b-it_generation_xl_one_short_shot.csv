id,language,reference,generated,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
1,python,"def is_subtype_of(cls, check: str, base: str) -> bool:
    check_type = cls.get_type(check)
    if not check_type:
        raise DatatypesException(f""Not a valid type: '{check}'"")
    base_type = cls.get_type(base)
    if not base_type:
        raise DatatypesException(f""Not a valid type: '{base}'"")
    return check in base_type[2] or check == base","def is_subtype_of(cls, check: str, base: str) -> bool:
    return check in base",0.1843235182564807,0.07283079467746288,0.20374899263417415,0.175,0.2857142857142857
2,python,"def is_datatype(cls, value: Any, datatype: str) -> bool:
    t = cls.get_type(datatype)
    if t is None:
        raise DatatypesException(f""Unsupported datatype: {datatype}"")
    return t[1](value)","from typing import Any

def is_datatype(cls, value: Any, datatype: str) -> bool:
    if datatype == ""int"":
        return isinstance(value, int)
    elif datatype == ""float"":
        return isinstance(value, float)
    elif datatype == ""str"":
        return isinstance(value, str)
    elif datatype == ""bool"":
        return isinstance(value, bool)
    elif datatype == ""list"":
        return isinstance(value, list)
    elif datatype == ""tuple"":
        return isinstance(value, tuple)
    elif datatype == ""dict"":
        return isinstance(value, dict)
    elif datatype == ""set"":
        return isinstance(value, set)
    else:
        return False",0.371611529750151,0.0974150876536819,0.35826180057769114,0.23076923076923078,0.8
3,python,"def is_xintx(value: Any, signed: bool, bits: int):
    values = [value]
    if isinstance(value, list):
        values = value

    for v in values:
        if not isinstance(v, int):
            return False
        if not signed and v < 0:
            return False
        max = 2**bits - 1
        min = 0
        if signed:
            max = 2 ** (bits - 1) - 1
            min = -(2 ** (bits - 1))
        if not (v <= max and v >= min):
            return False
    return True","from typing import Any

def is_xintx(value: Any, signed: bool, bits: int):
    if isinstance(value, list):
        return all(is_xintx(v, signed, bits) for v in value)

    if not isinstance(value, int):
        return False

    if signed:
        lower_bound = -(2**(bits - 1))
        upper_bound = 2**(bits - 1) - 1
    else:
        lower_bound = 0
        upper_bound = 2**bits - 1

    return lower_bound <= value <= upper_bound",0.3866337406779282,0.2245985503451338,0.23227532270548928,0.6031746031746031,0.4864864864864865
4,python,"def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
        for t in cls.types:
            if datatype == t[0]:
                return t
        return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_def in cls.__dict__.get('types', []):
        if type_def[0] == datatype:
            return type_def
    return None",0.6518280095423702,0.5016993910962959,0.546690088150626,0.7407407407407407,0.8181818181818182
5,python,"def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if not fqn:
        return {}
    fqn_namespaced_datatypes = {}
    for t in dynamic_datatypes:
        if fqn.startswith(t):
            continue

        if fqn.startswith(""."".join(t.split(""."")[:-1])):
            fqn_namespaced_datatypes[(t.split(""."")[-1])] = t

    if fqn_namespaced_datatypes:
        log.debug(f""Namespaced datatypes, {fqn=}, {fqn_namespaced_datatypes=}"")
    return fqn_namespaced_datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    datatypes = {}
    if fqn:
        parts = fqn.split(""."")
        namespace = ""."".join(parts[:-1])
        type_name = parts[-1]
        if namespace:
            for name, dtype in datatypes.items():
                if name == type_name:
                    datatypes[fqn] = dtype
        else:
            for name, dtype in datatypes.items():
                if name == type_name:
                    datatypes[fqn] = dtype
    return datatypes",0.3627985583917708,0.20225393599221494,0.29870881609338673,0.46875,0.48148148148148145
6,python,"def populate_unique_node_names(node_names_dict: dict[str, Any], vss_node: VSSNode) -> None:
    if not node_names_dict.get(vss_node.name):
        node_names_dict.__setitem__(vss_node.name, {""counter"": 1, ""vss_paths"": [vss_node.get_fqn()]})
    else:
        node_names_dict[vss_node.name][""counter""] += 1  # type: ignore
        node_names_dict[vss_node.name][""vss_paths""].append(vss_node.get_fqn())  # type: ignore

    if vss_node.children and len(vss_node.children) > 0:
        for vss_child_node in vss_node.children:
            populate_unique_node_names(node_names_dict, vss_child_node)","def populate_unique_node_names(node_names_dict: dict[str, Any], vss_node: VSSNode) -> None:
    node_name = vss_node.name
    if node_name not in node_names_dict:
        node_names_dict[node_name] = {""count"": 0, ""paths"": []}
    node_names_dict[node_name][""count""] += 1
    node_names_dict[node_name][""paths""].append(vss_node.get_fully_qualified_path())
    for child in vss_node.children:
        populate_unique_node_names(node_names_dict, child)",0.35651237396462787,0.22805382335229785,0.246889136222117,0.5373134328358209,0.41379310344827586
7,python,"def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    is_array = False
    apigear_type = None
    if t.endswith(""[]""):
        is_array = True
        t = t[0:-2]

    if t in [""int8"", ""int16"", ""int32"", ""uint8"", ""uint16"", ""uint32""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT32.value)
    elif t in [""int64"", ""uint64""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT64.value)
    elif t == ""float"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT32.value)
    elif t == ""double"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT64.value)
    elif t == ""boolean"":
        apigear_type = ApiGearType(ApiGearBasicType.BOOL.value)
    elif t == ""string"":
        apigear_type = ApiGearType(ApiGearBasicType.STRING.value)
    else:
        apigear_type = ApiGearType(t.replace(""."", ""_""))

    if is_array and apigear_type is not None:
        apigear_type.is_array = True

    return apigear_type","def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    if t == ""string"":
        return ApiGearType.STRING
    elif t == ""integer"":
        return ApiGearType.INTEGER
    elif t == ""number"":
        return ApiGearType.NUMBER
    elif t == ""boolean"":
        return ApiGearType.BOOLEAN
    elif t == ""array"":
        return ApiGearType.ARRAY
    elif t == ""object"":
        return ApiGearType.OBJECT
    else:
        return None",0.19000619421757173,0.09762533530807715,0.1320062890886858,0.3008849557522124,0.22950819672131148
8,python,"def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    apigear_type = get_apigear_datatype(datatype)
    data = node.get_vss_data()

    if apigear_type is None:
        log.warning(f""Datatype {datatype} of node {node.name} currently not supported"")
        return None

    property = ApiGearProperty(apigear_type)
    if data.description != """":
        property.description = data.description
    return property","def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if not node or not datatype:
        return None

    property = ApiGearProperty()
    property.name = node.name
    property.datatype = datatype

    if node.units:
        property.units = node.units

    if node.description:
        property.description = node.description

    return property",0.3581010477602219,0.2967410038449152,0.31344096497375,0.4222222222222222,0.4
9,python,"def get_vspecs(includes: list[Path], spec: Path, prefix: str | None = None) -> list[VSpec]:
    vspecs: list[VSpec] = []
    vspec = VSpec(spec, prefix)
    vspecs.append(vspec)

    for include in vspec.includes:
        include_spec = include.resolve_path(includes + [vspec.source.parent])
        vspecs.extend(get_vspecs(includes, include_spec, include.prefix))

    return vspecs","from pathlib import Path

class VSpec:
    def __init__(self, path: Path, content: str, prefix: str | None):
        self.path = path
        self.content = content
        self.prefix = prefix

def get_vspecs(includes: list[Path], spec: Path, prefix: str | None = None) -> list[VSpec]:
    vspecs = []
    content = """"
    try:
        with open(spec, ""r"") as f:
            content = f.read()
    except FileNotFoundError:
        return []

    vspecs.append(VSpec(spec, content, prefix))

    for include_path in includes:
        try:
            with open(include_path, ""r"") as f:
                include_content = f.read()
            vspecs.append(VSpec(include_path, include_content, prefix))
        except FileNotFoundError:
            pass

    return vspecs",0.44155985794250907,0.1686983476906617,0.41163653357992946,0.5094339622641509,0.6764705882352942
10,python,"def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    spec = None
    vspecs: list[VSpec] = []
    for s in specs:
        includes = [s.parent] + include_dirs
        vspecs.extend(get_vspecs(includes, s))
    pre = ""VSpecs""
    if identifier:
        pre += f"" ({identifier})""
    log.info(f""{pre} loaded, amount={len(vspecs)}"")
    for vspec in vspecs:
        log.debug(vspec)
        if spec is None:
            spec = vspec
        else:
            spec.update(vspec)
    if not spec:
        msg = f""Weird behavior. Could not load any spec: {specs}""
        log.error(msg)
        raise SpecException(msg)
    return spec","from pathlib import Path

class VSpec:
    def __init__(self):
        self.data = {}

    def merge(self, other):
        for key, value in other.data.items():
            self.data[key] = value

def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    vspec = VSpec()
    for spec_path in specs:
        try:
            with open(spec_path, 'r') as f:
                lines = f.readlines()
                spec_data = {}
                for line in lines:
                    if '=' in line:
                        key, value = line.strip().split('=', 1)
                        spec_data[key.strip()] = value.strip()
                vspec.merge(VSpec().data)
                vspec.data.update(spec_data)
        except FileNotFoundError:
            print(f""Warning: File not found: {spec_path}"")
    return vspec",0.306624651215366,0.1795185508902815,0.20511958885490328,0.4,0.4418604651162791
11,python,"def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if isinstance(value, dict):
            if key in base and isinstance(base[key], dict):
                deep_update(base[key], value)
            else:
                base[key] = value
        else:
            base[key] = value","def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if isinstance(value, dict) and key in base and isinstance(base[key], dict):
            deep_update(base[key], value)
        else:
            base[key] = value",0.8135131094692399,0.7652003015664524,0.7701021363105075,0.8125,0.90625
12,python,"def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return v
    pattern = r""^0x[0-9A-Fa-f]{8}$""
    assert bool(re.match(pattern, v)), f""'{v}' is not a valid 'constUID'""
    return v","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if not isinstance(v, str):
        return None
    if len(v) != 8:
        return None
    try:
        int(v, 16)
    except ValueError:
        return None
    return v",0.5055735832975432,0.4037469867061998,0.5185473464839729,0.4,0.7
13,python,"def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw(fqn=fqn, **data)
    try:
        model = resolve_vss_raw(model)
    except (ValidationError, ModelException):
        log.debug(f""'{fqn}', incomplete, initialized as '{model.__class__.__name__}'"")
        return model
    return model","def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw()
    model.from_dict(data)
    if not model.resolve(fqn):
        return model
    return model",0.5042336568418039,0.4284619504382953,0.455139343595587,0.4,0.7333333333333333
14,python,"def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    datatypes = get_all_datatypes()
    for value in values:
        assert value in datatypes, f""Invalid datatype: '{value}'""
    return values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_values = []
    for value in values:
        try:
            cls(value)
            valid_values.append(value)
        except ValueError:
            pass
    return valid_values",0.47388463673751674,0.33932908025428205,0.3478761333624517,0.4583333333333333,0.75
15,python,"def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    tree_content_lines = []
    for pre, fill, node in RenderTree(tree):
        tree_content_lines.append(""%s%s"" % (pre, node.name))
        for attribute in attributes:
            content = getattr(node.data, attribute, None)
            if content is None:
                continue
            if isinstance(content, str):
                tree_content_lines.append(""%s%s='%s'"" % (fill, attribute, content))
            else:
                tree_content_lines.append(""%s%s=%s"" % (fill, attribute, content))
    return ""\n"".join(tree_content_lines)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    def render_node(node: VSSNode, attributes: tuple[str], indent: str) -> str:
        rendered = indent + str(node.name) + ""\n""
        for attribute in attributes:
            try:
                value = getattr(node, attribute)
                rendered += indent + ""  "" + attribute + "": "" + str(value) + ""\n""
            except AttributeError:
                pass
        for child in node.children:
            rendered += render_node(child, attributes, indent + ""  "")
        return rendered

    return render_node(tree, attributes, """")",0.282991526051849,0.1267206471683073,0.18864626675568782,0.36923076923076925,0.4473684210526316
16,python,"def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not isinstance(self.data, VSSDataBranch):
        raise NoInstanceRootException()

    if not self.data.is_instance:
        return self, depth

    if self.parent is None:
        raise NoInstanceRootException()

    return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if self.parent is None:
        return self, depth
    else:
        return self.parent.get_instance_root(depth + 1)",0.509090059046418,0.4505992343458631,0.4568136334187565,0.55,0.5789473684210527
17,python,"def count_instance_children_depth(self) -> int:
    for child in self.children:
        if isinstance(child.data, VSSDataBranch):
            if child.data.is_instance:
                return 1 + child.count_instance_children_depth()
    return 0","def count_instance_children_depth(self) -> int:
    count = 0
    current = self
    while current.parent:
        current = current.parent
        count += 1
    return count",0.2598395407760285,0.1378592993183041,0.14062929856841858,0.2608695652173913,0.5
18,python,"def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    ids = []
    for i in node_ids:
        if get_expected_parent(i) == name:
            ids.append(i)
    return ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        if node_id.startswith(name + '_'):
            children_ids.append(node_id)
    return children_ids",0.6422545578221317,0.4064458257395656,0.42923907221562774,0.7333333333333333,1.0
19,python,"def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    result = getattr(o, name, default)
    if result is None and default is not None:
        result = default
    return result","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        value = getattr(o, name)
        if value is None:
            return default
        return value
    except AttributeError:
        return default",0.5428198999477352,0.4405262339943716,0.4307533657965687,0.5,0.8
20,python,"def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    fd.write('syntax = ""proto3"";\n\n')

    imports = []
    for node in findall(tree, filter_=lambda n: isinstance(n.data, VSSDataDatatype)):
        datatype = node.data.datatype
        if ""."" not in datatype:
            continue
        struct_path = Path(node.data.datatype.replace(""."", ""/""))  # type: ignore
        imports.append(f""{struct_path.parent}/{struct_path.parent.name}.proto"")
    write_imports(fd, imports)

    # write proto messages to file
    for node in findall(tree, filter_=lambda node: isinstance(node.data, VSSDataBranch)):
        fd.write(f""message {node.get_fqn('')} {{"" + ""\n"")
        print_messages(node.children, fd, static_uid, add_optional)
        fd.write(""}\n\n"")","def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.name == ""signal"":
        fd.write(f"".proto\n"")
        fd.write(f""  message {tree.name} {{\n"")
        if static_uid:
            fd.write(f""    uint64 static_id = 1;\n"")
        fd.write(f""    {tree.data_type} value = 2;\n"")
        fd.write(f""  }}\n"")
    elif tree.name == ""message"":
        fd.write(f"".proto\n"")
        fd.write(f""  message {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(f""  }}\n"")
    elif tree.name == ""enumeration"":
        fd.write(f"".proto\n"")
        fd.write(f""  enum {tree.name} {{\n"")
        for child in tree.children:
            fd.write(f""    {child.name} = {child.value};\n"")
        fd.write(f""  }}\n"")
    elif tree.name == ""array"":
        fd.write(f"".proto\n"")
        fd.write(f""  repeated {tree.data_type} {tree.name};\n"")
    elif tree.name == ""choice"":
        fd.write(f"".proto\n"")
        fd.write(f""  oneof {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(f""  }}\n"")
    elif tree.name == ""group"":
        fd.write(f"".proto\n"")
        fd.write(f""  message {tree.name} {{\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
        fd.write(f""  }}\n"")",0.19451872100688455,0.08675679451705107,0.17222683330582886,0.27835051546391754,0.24074074074074073
21,python,"def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    meta: dict[str, list[str]] = {}
    for node in PreOrderIter(root, filter_=lambda n: isinstance(n.data, VSSDataBranch) and n.data.is_instance):
        if any(c.data.is_instance for c in node.children if isinstance(c.data, VSSDataBranch)):
            continue
        instance_root, _ = node.get_instance_root()
        instance_root_fqn = instance_root.get_fqn()

        instance_name = node.get_fqn().removeprefix(instance_root_fqn + ""."")

        if instance_root_fqn in meta:
            meta[instance_root_fqn].append(instance_name)
        else:
            meta[instance_root_fqn] = [instance_name]
    return meta","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances_meta = {}
    for node in root.get_leaf_vss_nodes():
        branch_name = node.branch_definition.fully_qualified_name
        if branch_name not in instances_meta:
            instances_meta[branch_name] = []
        instances_meta[branch_name].append(node.name)
    return instances_meta",0.27291153048891104,0.12167211618074669,0.17217902571390759,0.47126436781609193,0.32653061224489793
22,python,"def is_VSS_leaf(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataDatatype):
        return True
    return False","def is_VSS_leaf(node: VSSNode) -> bool:
    if node.data_type == ""leaf"":
        return True
    else:
        return False",0.6339761403752637,0.43242270754632145,0.532053282526162,0.5714285714285714,1.0
23,python,"def is_VSS_branch(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataBranch):
        if not node.data.is_instance:
            return True
    return False","def is_VSS_branch(node: VSSNode) -> bool:
    return node.is_branch and not node.is_instance",0.35828021085847317,0.25916266987614406,0.25816869987353824,0.3157894736842105,0.6
24,python,"def is_VSS_branch_instance(node: VSSNode) -> bool:
    if isinstance(node.data, VSSDataBranch):
        if node.data.is_instance:
            return True
    return False","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return node.is_branch_instance",0.30783772350574135,0.23671529472186087,0.2613022659677713,0.3333333333333333,0.4
25,python,"def fnv1_32_hash(identifier: bytes) -> int:
    id_hash = 2166136261
    for byte in identifier:
        id_hash = (id_hash * 16777619) & 0xFFFFFFFF
        id_hash ^= byte

    return id_hash","def fnv1_32_hash(identifier: bytes) -> int:
    hval = 0x01000193
    fnv_prime = 0x01000193
    for byte in identifier:
        hval ^= byte
        hval *= fnv_prime
        hval &= 0xFFFFFFFF
    return hval",0.41142125195448565,0.26613685332453085,0.30586394396709615,0.47368421052631576,0.6
26,java,"public CardPresenter getCardPresenter() {
    if (mAudioCardPresenter == null) {
        mAudioCardPresenter = new HomeAudioCardPresenter();
        if (mViewModelProvider == null) {
            Log.w(TAG, ""No ViewModelProvider set. Cannot get MediaViewModel"");
            mAudioCardPresenter.setModels(
                    Collections.unmodifiableList(Collections.singletonList(
                            new InCallModel(SystemClock.elapsedRealtimeClock()))));
        } else {
            mAudioCardPresenter.setModels(Collections.unmodifiableList(Arrays.asList(
                    mViewModelProvider.get(MediaViewModel.class),
                    new InCallModel(SystemClock.elapsedRealtimeClock()))));
        }
    }
    return mAudioCardPresenter;
}","public CardPresenter getCardPresenter() {
        if (cardPresenter == null) {
            cardPresenter = new CardPresenter(mediaModel, inCallStatusModel);
        }
        return cardPresenter;
    }",0.16659177134758335,0.09091087264494198,0.14390859369777237,0.14583333333333334,0.2857142857142857
27,java,"public HomeCardFragment getCardView() {
    if (mAudioCardView == null) {
        mAudioCardView = new AudioFragment();
        getCardPresenter().setView(mAudioCardView);
        mAudioCardView.setPresenter(getCardPresenter());
    }
    return mAudioCardView;
}","public HomeCardFragment getCardView() {
        if (cardView == null) {
            cardView = new HomeCardFragment();
        }
        return cardView;
    }",0.3795879077684105,0.3088448141335011,0.3226020550353789,0.4583333333333333,0.42857142857142855
28,java,"public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
    mRootView = inflater.inflate(R.layout.card_fragment, container, false);
    mCardTitle = mRootView.findViewById(R.id.card_name);
    mCardIcon = mRootView.findViewById(R.id.card_icon);
    return mRootView;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_card, container, false);
        return view;
    }",0.43321025003235925,0.3924500924677672,0.41278148005224197,0.5185185185185185,0.4090909090909091
29,java,"private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent,
        ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageDrawable(buttonContent.getIcon());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
        if (buttonContent != null && buttonContent.getIcon() != null) {
            buttonView.setIcon(buttonContent.getIcon());
            buttonView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    buttonContent.executeAction();
                }
            });
            buttonView.setVisibility(View.VISIBLE);
        } else {
            buttonView.setVisibility(View.GONE);
        }
    }",0.7538138702573456,0.4331017716700228,0.7757020964561335,0.8064516129032258,1.0
30,java,"protected final View getDescriptiveTextOnlyLayoutView() {
    if (mDescriptiveTextOnlyLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.descriptive_text_layout);
        mDescriptiveTextOnlyLayoutView = stub.inflate();
        mDescriptiveTextOnlyTitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.primary_text);
        mDescriptiveTextOnlySubtitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.secondary_text);
        mDescriptiveTextOnlyOptionalImage = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.optional_image);
        mDescriptiveTextOnlyTapForMore = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.tap_for_more_text);
    }
    return mDescriptiveTextOnlyLayoutView;
}","protected final View getDescriptiveTextOnlyLayoutView() {
        View view = mDescriptiveTextOnlyLayoutView;
        if (view == null) {
            mDescriptiveTextOnlyLayoutView = createDescriptiveTextOnlyLayoutView();
            view = mDescriptiveTextOnlyLayoutView;
        }
        return view;
    }",0.15410240083509083,0.15312892961228738,0.1798582138350278,0.13636363636363635,0.14705882352941177
31,java,"public void updateHeaderView(CardHeader header) {
    requireActivity().runOnUiThread(() -> {
        mRootView.setVisibility(View.VISIBLE);
        mCardTitle.setText(header.getCardTitle());
        mCardIcon.setImageDrawable(header.getCardIcon());
    });
}","public void updateHeaderView(CardHeader header) {
    header.setTitle(newTitle);
    header.setIcon(newIcon);
    displayHeader(header);
}

private void displayHeader(CardHeader header) {
    headerView.setText(header.getTitle());
    headerView.setIcon(header.getIcon());
}",0.5176148608977814,0.23287896954139942,0.3375804740497263,0.5,1.0
32,java,"private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.text_block_layout);
        mTextBlockLayoutView = stub.inflate();
        mTextBlock = mTextBlockLayoutView.findViewById(R.id.text_block);
        mTextBlockTapForMore = mTextBlockLayoutView.findViewById(R.id.tap_for_more_text);
    }
    return mTextBlockLayoutView;
}","private View getTextBlockLayoutView() {
    return LayoutInflater.from(this).inflate(R.layout.text_block_layout, null);
}",0.35070661879078574,0.04032605336266308,0.11250042180047988,0.25,0.0
33,java,"static ComponentName getMediaSource(@NonNull PackageManager packageManager,
        @NonNull String packageName) {
    Intent mediaIntent = new Intent();
    mediaIntent.setPackage(packageName);
    mediaIntent.setAction(MediaBrowserService.SERVICE_INTERFACE);

    List<ResolveInfo> mediaServices = packageManager.queryIntentServices(mediaIntent,
            PackageManager.GET_RESOLVED_FILTER);

    if (mediaServices == null || mediaServices.isEmpty()) {
        return null;
    }
    String defaultService = mediaServices.get(0).serviceInfo.name;
    if (!TextUtils.isEmpty(defaultService)) {
        return new ComponentName(packageName, defaultService);
    }
    return null;
}","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setPackage(packageName);
        ResolveInfo resolveInfo = packageManager.resolveActivity(intent, PackageManager.MATCH_DEFAULT);
        if (resolveInfo != null) {
            return resolveInfo.activityInfo.componentName;
        }
        return null;
    }",0.3286583905750729,0.25580543580238263,0.2865909297324104,0.41509433962264153,0.35714285714285715
34,java,"private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    switch (componentAppType) {
        case APP_TYPE_MEDIA_SERVICES:
            if (customMediaComponents.contains(componentName.flattenToString())
                    && (appTypesToShow & APP_TYPE_LAUNCHABLES) != 0) {
                return false;
            }
            return true;
        case APP_TYPE_LAUNCHABLES:
            return true;
        default:
            Log.e(TAG, ""Invalid componentAppType : "" + componentAppType);
            return false;
    }
}","boolean isLaunchable(@NonNull String packageName) {
    if (hideList == null || hideList.isEmpty()) {
        return true;
    }

    if (hideList.contains(packageName)) {
        return false;
    }

    Set<String> uniqueMediaServices = new HashSet<>();
    for (ResolveInfo resolveInfo : mediaServices) {
        uniqueMediaServices.add(resolveInfo.serviceName);
    }

    if (uniqueMediaServices.size() != mediaServices.size()) {
        return false;
    }

    return true;
}",0.3306696086133986,0.14045846543746202,0.15047393727010075,0.4126984126984127,0.6190476190476191
35,java,"private static void selectMediaSourceAndFinish(Context context, ComponentName componentName,
        CarMediaManager carMediaManager) {
    try {
        carMediaManager.setMediaSource(componentName, CarMediaManager.MEDIA_SOURCE_MODE_BROWSE);
        if (context instanceof Activity) {
            ((Activity) context).finish();
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected"", e);
    }
}","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
        carMediaManager.selectMediaSource(componentName);
        ((Activity) context).finish();
    }",0.3535190002533488,0.1875370708668024,0.3039582849853027,0.3225806451612903,0.6
36,java,"static boolean isActivityDistractionOptimized(
        CarPackageManager carPackageManager, String packageName, String activityName) {
    boolean isDistractionOptimized = false;
    try {
        if (carPackageManager != null) {
            isDistractionOptimized =
                    carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected when getting DO info"", e);
    }
    return isDistractionOptimized;
}","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
        try {
            CarPackage carPackage = carPackageManager.getCarPackage(packageName);
            if (carPackage != null) {
                Activity activity = carPackage.getActivity(activityName);
                if (activity != null) {
                    return activity.isDistractionOptimized();
                }
            }
            return false;
        } catch (Exception e) {
            return false;
        }
    }",0.33890851556273605,0.19667768384043363,0.20575440796716085,0.3103448275862069,0.6428571428571429
37,java,"private void setUpTaskView(ViewGroup parent) {
    mTaskViewManager = new TaskViewManager(this,
            new HandlerExecutor(getMainThreadHandler()));
    mTaskViewManager.createTaskView(taskView -> {
        taskView.setListener(getMainExecutor(), mTaskViewListener);
        parent.addView(taskView);
        mTaskView = taskView;
    });
}","private void setUpTaskView(ViewGroup parent) {
    new Handler().postDelayed(() -> {
        TaskView taskView = new TaskView(context);
        taskView.configure(taskData);
        parent.addView(taskView);
    }, 200);
}",0.26805753595185466,0.22292017291021057,0.2401145685983576,0.27586206896551724,0.3333333333333333
38,java,"private Intent getMapsIntent() {
    Intent defaultIntent =
            Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MAPS);
    PackageManager pm = getPackageManager();
    ComponentName defaultActivity = defaultIntent.resolveActivity(pm);

    for (String intentUri : getResources().getStringArray(
            R.array.config_homeCardPreferredMapActivities)) {
        Intent preferredIntent;
        try {
            preferredIntent = Intent.parseUri(intentUri, Intent.URI_ANDROID_APP_SCHEME);
        } catch (URISyntaxException se) {
            Log.w(TAG, ""Invalid intent URI in config_homeCardPreferredMapActivities"", se);
            continue;
        }

        if (defaultActivity != null && !defaultActivity.getPackageName().equals(
                preferredIntent.getPackage())) {
            continue;
        }

        if (preferredIntent.resolveActivityInfo(pm, /* flags= */ 0) != null) {
            return preferredIntent;
        }
    }
    return defaultIntent;
}","private Intent getMapsIntent() {
        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=current location""));
        if (intent.resolveActivity(getPackageManager()) != null) {
            return intent;
        }

        intent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0""));
        if (intent.resolveActivity(getPackageManager()) != null) {
            return intent;
        }

        return null;
    }",0.15926310368468516,0.07263380254965987,0.10770865547912403,0.24242424242424243,0.21428571428571427
39,java,"private void initializeCards() {
    if (mHomeCardModules == null) {
        mHomeCardModules = new ArraySet<>();
        for (String providerClassName : getResources().getStringArray(
                R.array.config_homeCardModuleClasses)) {
            try {
                long reflectionStartTime = System.currentTimeMillis();
                HomeCardModule cardModule = (HomeCardModule) Class.forName(
                        providerClassName).newInstance();
                cardModule.setViewModelProvider(new ViewModelProvider( /* owner= */this));
                mHomeCardModules.add(cardModule);
                if (DEBUG) {
                    long reflectionTime = System.currentTimeMillis() - reflectionStartTime;
                    Log.d(TAG, ""Initialization of HomeCardModule class "" + providerClassName
                            + "" took "" + reflectionTime + "" ms"");
                }
            } catch (IllegalAccessException | InstantiationException |
                    ClassNotFoundException e) {
                Log.w(TAG, ""Unable to create HomeCardProvider class "" + providerClassName, e);
            }
        }
    }
    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    for (HomeCardModule cardModule : mHomeCardModules) {
        transaction.replace(cardModule.getCardResId(), cardModule.getCardView());
    }
    transaction.commitNow();
}","private void initializeCards() {
    try {
        ResourceBundle config = ResourceBundle.getBundle(""homecards"");
        List<String> cardDefinitions = new ArrayList<>();
        Enumeration<String> keys = config.getKeys();
        while (keys.hasMoreElements()) {
            String key = keys.nextElement();
            if (key.startsWith(""card."")) {
                cardDefinitions.add(config.getString(key));
            }
        }

        for (String definition : cardDefinitions) {
            String[] parts = definition.split("","");
            if (parts.length == 3) {
                String className = parts[0].trim();
                String title = parts[1].trim();
                String data = parts[2].trim();

                try {
                    Class<?> cardClass = Class.forName(className);
                    HomeCard card = (HomeCard) cardClass.newInstance();
                    card.setTitle(title);
                    card.setData(data);
                    cardPanel.add(card);
                } catch (ClassNotFoundException e) {
                    System.err.println(""Card class not found: "" + className);
                } catch (InstantiationException e) {
                    System.err.println(""Failed to instantiate card: "" + className);
                } catch (IllegalAccessException e) {
                    System.err.println(""Failed to access card constructor: "" + className);
                }
            } else {
                System.err.println(""Invalid card definition: "" + definition);
            }
        }
    } catch (Exception e) {
        System.err.println(""Error initializing cards: "" + e.getMessage());
    }
}",0.22691651716731254,0.060730226649812945,0.08429847938207459,0.3626373626373626,0.4
40,java,"private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
    ActivityTaskManager atm = ActivityTaskManager.getInstance();
    for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
        TaskInfo taskInfo = taskAppearedInfo.getTaskInfo();
        if (taskInfo.getWindowingMode() == WINDOWING_MODE_MULTI_WINDOW) {
            if (DBG) Slog.d(TAG, ""Found the dangling task, removing: "" + taskInfo.taskId);
            atm.removeTask(taskInfo.taskId);
        }
    }
}","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
        if (taskAppearedInfos == null || taskAppearedInfos.isEmpty()) {
            return;
        }

        List<TaskAppearedInfo> tasksToRemove = new ArrayList<>();
        for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
            if (taskAppearedInfo.isMultiWindow() && taskAppearedInfo.isRemoved()) {
                tasksToRemove.add(taskAppearedInfo);
            }
        }

        taskAppearedInfos.removeAll(tasksToRemove);
    }",0.2960267895320259,0.26885451044577097,0.29151527394495885,0.3055555555555556,0.3181818181818182
41,java,"private void updateMode() {
    mMode = parseMode(getIntent());
    setTitle(mMode.mTitleStringId);
    CarUi.requireToolbar(this).setTitle(mMode.mTitleStringId);
}","private void updateMode() {
    String mode = getIntent().getStringExtra(""mode"");
    if (mode != null && !mode.isEmpty()) {
        setTitle(""Mode: "" + mode);
    } else {
        setTitle(""Mode: Default"");
    }
}",0.23352366272246866,0.10008350737965103,0.31020161970069987,0.19047619047619047,0.3333333333333333
42,java,"private Chronometer getChronometer() {
    if (mChronometer == null) {
        mChronometer = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer);
        mChronometerSeparator = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer_separator);
    }
    return mChronometer;
}","private Chronometer getChronometer() {
    return chronometer;
}",0.3289633504148476,0.06157676086268324,0.1388920254120917,0.11538461538461539,0.0
43,java,"private View getMediaLayoutView() {
    if (mMediaLayoutView == null) {
        ViewStub stub = getRootView().findViewById(R.id.media_layout);
        mMediaLayoutView = stub.inflate();
        mMediaTitle = mMediaLayoutView.findViewById(R.id.primary_text);
        mMediaSubtitle = mMediaLayoutView.findViewById(R.id.secondary_text);
        View mediaControlBarView = mMediaLayoutView.findViewById(
                R.id.media_playback_controls_bar);
        mPresenter.initializeControlsActionBar(mediaControlBarView);
    }
    return mMediaLayoutView;
}","private View getMediaLayoutView() {
        int width = (int) (this.mCardElevation * 1.5f);
        int height = (int) (this.mCardElevation * 1.5f);
        Bitmap blurredBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(blurredBitmap);
        Paint paint = new Paint();
        paint.setFilterBitmap(true);
        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
        paint.setMaskFilter(new BlurMaskFilter(8, BlurMaskFilter.Blur.NORMAL));
        canvas.drawBitmap(this.mImageDrawable.getBitmap(), 0.0f, 0.0f, paint);
        Bitmap scaledBitmap = Bitmap.createScaledBitmap(blurredBitmap, this.mWidth, this.mHeight, true);
        ImageView imageView = new ImageView(this.mContext);
        imageView.setImageBitmap(scaledBitmap);
        imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);
        return imageView;
    }",0.2307942305716426,0.047912155681418565,0.09900173533009175,0.5348837209302325,0.2413793103448276
44,java,"private void updateBackgroundImage(Drawable image) {
    if (image != null && getCardSize() != null) {
        int maxDimen = Math.max(getCardSize().getWidth(), getCardSize().getHeight());
        Size scaledSize = new Size(maxDimen, maxDimen);
        Bitmap imageBitmap = BitmapUtils.fromDrawable(image, scaledSize);
        Bitmap blurredBackground = ImageUtils.blur(getContext(), imageBitmap, scaledSize,
                mBlurRadius);

        getCardBackgroundImage().setImageBitmap(blurredBackground, /* showAnimation= */ true);
        getCardBackground().setVisibility(View.VISIBLE);
    }
}","private void updateBackgroundImage(Drawable image) {
    if (image == null) {
        return;
    }

    int width = getWidth();
    int height = getHeight();

    image.setBounds(0, 0, width, height);

    Blur.blur(image, null, 8, true);

    image.draw(new Canvas(new Bitmap(width, height, Bitmap.Config.ARGB_8888)));
}",0.2227158137365325,0.15080705296474956,0.17025563218081052,0.38461538461538464,0.18518518518518517
45,java,"private void updateMediaView(CharSequence title, CharSequence subtitle) {
    getMediaLayoutView().setVisibility(View.VISIBLE);
    mMediaTitle.setText(title);
    mMediaSubtitle.setText(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
    mediaView.setVisibility(View.VISIBLE);
    mediaView.setTitle(title);
    mediaView.setSubtitle(subtitle);
}",0.7084249025484299,0.5900468726392808,0.612073790186018,0.631578947368421,1.0
46,java,"private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        getChronometer().setVisibility(View.VISIBLE);
        getChronometer().setBase(content.getStartTime());
        getChronometer().start();
        mChronometerSeparator.setVisibility(View.VISIBLE);
    } else {
        getChronometer().setVisibility(View.GONE);
        mChronometerSeparator.setVisibility(View.GONE);
    }
}","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        content.startChronometer();
    } else {
        content.hideChronometer();
    }
}",0.38507720500534787,0.5275568628444888,0.5516408460657917,0.3111111111111111,0.15
47,java,"public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(mCallback);
    }
}","public void onCallAdded(Call call) {
}",0.44901864169012223,0.2476498688229712,0.3176554671682869,0.23076923076923078,0.0
48,java,"public void onCallRemoved(Call call) {
    mCurrentCall = null;
    mCardContent = null;
    mPresenter.onModelUpdated(this);
    if (call != null) {
        call.unregisterCallback(mCallback);
    }
}","public void onCallRemoved(Call call) {
        resetState();
        unregisterCallback();
    }

    private void resetState() {
    }

    private void unregisterCallback() {
    }",0.2485149146074121,0.20234254014710829,0.21314568971111159,0.15,0.42857142857142855
49,java,"void updateModelWithPhoneNumber(String number) {
    String formattedNumber = TelecomUtils.getFormattedNumber(mContext, number);
    mCardContent = new DescriptiveTextWithControlsView(null, formattedNumber,
            mOngoingCallSubtitle, mElapsedTimeClock.millis(), mMuteButton, mEndCallButton,
            mDialpadButton);
    mPresenter.onModelUpdated(this);
}","void updateModelWithPhoneNumber(String number) {
    String formattedNumber = formatPhoneNumber(number);
    viewModel.setPhoneNumber(formattedNumber);
    viewModel.setShowDialpad(true);
    viewModel.setShowAddContact(true);
}",0.22621422988898343,0.2518505111746181,0.2918952972702044,0.1111111111111111,0.25
50,java,"private void initializeAudioControls() {
    mMuteButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_mic_off),
            v -> {
                mInCallService.setMuted(mMuteCallToggle);
                mMuteCallToggle = !mMuteCallToggle;
            });
    mEndCallButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_call_end_button),
            v -> mCurrentCall.disconnect());
    mDialpadButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_dialpad), this::onClick);
}","private void initializeAudioControls() {
        muteButton = findViewById(R.id.mute_button);
        endCallButton = findViewById(R.id.end_call_button);
        dialpadButton = findViewById(R.id.dialpad_button);

        muteButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                toggleMute();
            }
        });

        endCallButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                endCall();
            }
        });

        dialpadButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showDialpad();
            }
        });
    }",0.22593778885931914,0.057399950473749316,0.09367740817208346,0.3409090909090909,0.4117647058823529
51,cpp,"bool DBusConnection::sendDBusMessage(const DBusMessage &_message) const {
    if (!_message) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message == NULL"");
        return false;
    }
    if (!isConnected()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""not connected"");
        return false;
    }

    dbus_uint32_t dbusSerial;
    const bool result = (0 != dbus_connection_send(connection_, _message.message_, &dbusSerial));
    return result;
}","bool DBusConnection::sendDBusMessage(const DBusMessage &_message) const {
    return connection->send(_message);
}",0.1465746181838144,0.02251731429046933,0.13333925991778328,0.2765957446808511,0.15384615384615385
52,cpp,"DBusMessage DBusClientId::createMessage(const std::string objectPath, const std::string interfaceName, const std::string signalName) const
{
    DBusMessage returnMessage = DBusMessage::createSignal(objectPath, interfaceName, signalName);
    returnMessage.setDestination(dbusId_.c_str());

    return (returnMessage);
}","DBusMessage DBusClientId::createMessage(const std::string objectPath, const std::string interfaceName, const std::string signalName) const {
    DBusMessage message = DBusMessage(DBusMessage::SIGNAL);
    message.set_path(objectPath);
    message.set_interface(interfaceName);
    message.set_member(signalName);
    return message;
}",0.6832969929099489,0.588934620997652,0.6109200173088104,0.5333333333333333,1.0
53,cpp,"void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    (void)_subscription;
    if (dbusConnection_->isConnected())
        _listener(AvailabilityStatus::AVAILABLE);
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (m_connectionStatus == ConnectionStatus::Connected) {
        _listener.listenerCallback(true);
    }
}",0.5036825931760862,0.4682568791024402,0.6116908849062525,0.43478260869565216,0.5
54,cpp,"void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (connections_.end() != connections_.find(conn)) {
        bool found(false);
        std::vector<std::thread*>::const_iterator it = threads_.begin();
        while (!found && it != threads_.end()) {
            found = (&t == *it++);
        }
        if (!found) {
            threads_.push_back(&t);
        }
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(connectionMutexes[conn]);
    if (connectionThreads.find(conn) == connectionThreads.end() || connectionThreads[conn].find(&t) == connectionThreads[conn].end()) {
        connectionThreads[conn].insert(&t);
    }
}",0.29630817361291306,0.1553412146617404,0.19783691883509522,0.42028985507246375,0.4117647058823529
55,cpp,"void DBusConnection::onWakeupMainContext(void* data) {
    std::weak_ptr<MainLoopContext>* mainloop = static_cast<std::weak_ptr<MainLoopContext>*>(data);

    if (!mainloop) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""mainloop == nullptr"");
    } else if(auto lockedContext = mainloop->lock()) {
        lockedContext->wakeup();
    }
}","void DBusConnection::onWakeupMainContext(void* data) {
    DBusConnection* connection = static_cast<DBusConnection*>(data);
    if (connection->mainContext_) {
        connection->mainContext_->wakeup();
    }
}",0.3096361736064114,0.10664497964286719,0.13189971478277843,0.2857142857142857,0.7142857142857143
56,cpp,"void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (NULL == static_cast<WatchContext*>(data)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data (WatchContext) == NULL"");
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));
    if (dbusWatch != NULL) {
        if(dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
        }
        dbus_watch_set_data(libdbusWatch, NULL, NULL);
    }
}","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch) {
        libdbusWatch->unwatch();
        delete libdbusWatch;
    }
    if (data) {
        delete data;
    }
}",0.27959086363288205,0.16707856240018681,0.2134061042525535,0.2833333333333333,0.45454545454545453
57,cpp,"void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    WatchContext* watchContext = static_cast<WatchContext*>(data);

    if (NULL == watchContext) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""watchContext == NULL"");
        return;
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));

    if (dbusWatch == NULL) {
        DBusWatch* dbusWatch = new DBusWatch(libdbusWatch, watchContext->mainLoopContext_, watchContext->dbusConnection_);
        dbusWatch->addDependentDispatchSource(watchContext->dispatchSource_);
        dbus_watch_set_data(libdbusWatch, dbusWatch, NULL);

        if (dbusWatch->isReadyToBeWatched()) {
            dbusWatch->startWatching();
        }
    } else {
        if (!dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
            dbus_watch_set_data(libdbusWatch, NULL, NULL);
        } else {
            dbusWatch->startWatching();
        }
    }
}","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch->isReady()) {
        libdbusWatch->start();
    } else {
        libdbusWatch->stop();
    }
}",0.1683177476235252,0.02372786059738577,0.11185859221217735,0.3838383838383838,0.15384615384615385
58,cpp,"const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> itsLock(objectManagerGuard_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return dbusObjectManager_;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    std::shared_ptr<DBusObjectManager> manager;
    if (!objectManager_) {
        std::lock_guard<std::mutex> lock(objectManagerMutex_);
        if (!objectManager_) {
            objectManager_ = std::make_shared<DBusObjectManager>(connection_);
        }
    }
    return objectManager_;
}",0.5216715033785375,0.19464521962073486,0.22537412722674852,0.6666666666666666,1.0
59,cpp,"bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    DBusError dbusError;
    bool isServiceNameReleased = false;
    std::lock_guard<std::recursive_mutex> dbusConnectionLock(connectionGuard_);
    auto conIter = connectionNameCount_.find(serviceName);
    if (conIter != connectionNameCount_.end()) {
        if (conIter->second == 1) {
            const int libdbusStatus = dbus_bus_release_name(connection_,
                            serviceName.c_str(),
                            &dbusError.libdbusError_);
            isServiceNameReleased = (libdbusStatus == DBUS_RELEASE_NAME_REPLY_RELEASED);
            if (isServiceNameReleased) {
                connectionNameCount_.erase(conIter);
            }
        } else {
            conIter->second--;
            isServiceNameReleased = true;
        }
    }
    return isServiceNameReleased;
}","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    if (!connection) {
        return false;
    }

    try {
        return connection->release_name(serviceName);
    } catch (const DBusError& e) {
        std::cerr << ""Error releasing service name: "" << e.getName() << std::endl;
        return false;
    }
}",0.21725044319867298,0.09938783873139406,0.11247107692044064,0.35714285714285715,0.3
60,cpp,"DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (NULL == _libdbusPendingCall) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""_libdbusPendingCall == NULL"");
        return DBusMessage();
    }

    ::DBusMessage* libdbusMessage = dbus_pending_call_steal_reply(_libdbusPendingCall);
    const bool increaseLibdbusMessageReferenceCount = false;
    DBusMessage dbusMessage(libdbusMessage, increaseLibdbusMessageReferenceCount);

    return dbusMessage;
}","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    DBusMessage reply = _libdbusPendingCall->GetDBusMessage();
    _libdbusPendingCall->Release();
    return reply;
}",0.20943165403115144,0.051757497462117004,0.08725116994454003,0.28205128205128205,0.4166666666666667
61,cpp,"void DBusConnection::deleteAsyncHandlers() {
    std::vector<DBusMessageReplyAsyncHandler*> asyncHandlers;
    {
        std::lock_guard<std::mutex> asyncHandlersLock(asyncHandlersToDeleteMutex_);
        asyncHandlers = asyncHandlersToDelete_;
        asyncHandlersToDelete_.clear();
    }

    auto it = asyncHandlers.begin();
    while(it != asyncHandlers.end()) {
        delete *it;
        it = asyncHandlers.erase(it);
    }
}","void DBusConnection::deleteAsyncHandlers() {
    std::lock_guard<std::mutex> lock(async_mutex_);
    while (!async_handlers_.empty()) {
        AsyncHandler* handler = async_handlers_.back();
        async_handlers_.pop_back();
        delete handler;
    }
}",0.20545685317689355,0.046651380406589726,0.05578827719894365,0.46938775510204084,0.25
62,cpp,"void DBusConnection::handleSignalStates() {
    std::map<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>, std::set<uint32_t>> tmpHandlers;
    {
        std::lock_guard<std::mutex> itsLock(signalStateHandlersMutex_);
        tmpHandlers = signalStateHandlers_;
    }
    for (auto itsHandler : tmpHandlers) {
        for (uint32_t tag : itsHandler.second) {
            itsHandler.first->onSpecificError(CommonAPI::CallStatus::SUCCESS, tag);
        }
    }
}","void DBusConnection::handleSignalStates() {
    QHash<uint, QList<SignalHandler*> >::iterator i = signalHandlersByTag.begin();
    while (i != signalHandlersByTag.end()) {
        uint tag = i.key();
        QList<SignalHandler*> handlers = i.value();
        QList<SignalHandler*> handlersToSend;
        for (SignalHandler *handler : handlers) {
            if (handler->state() == SignalHandler::Ready) {
                handlersToSend.append(handler);
            }
        }
        if (!handlersToSend.isEmpty()) {
            for (SignalHandler *handler : handlersToSend) {
                handler->reportSuccess();
            }
        }
        i++;
    }
}",0.1813856282159382,0.03266387074270991,0.062443859512347225,0.13043478260869565,0.5
63,cpp,"void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::recursive_mutex> itsConnectionGuard(connectionsMutex_);
    auto itsConnection = connections_.find(_connectionId);

    if (itsConnection != connections_.end()) {
        connections_.erase(_connectionId);
    }
}","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}",0.6421305715703209,0.3411488281065382,0.3523734581747456,1.0,0.875
64,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.hasMemberName(""InterfacesAdded"")) {
        instanceAvblStatusEvent_->onInterfacesAddedSignal(dbusMessage);
    } else if (dbusMessage.hasMemberName(""InterfacesRemoved"")) {
        instanceAvblStatusEvent_->onInterfacesRemovedSignal(dbusMessage);
   }
}","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.type() == DBusMessage::Signal) {
        const std::string& signalName = dbusMessage.interface();
        if (signalName == ""org.freedesktop.DBus"") {
            if (dbusMessage.member() == ""NameOwnerChanged"") {
                handleNameOwnerChanged(dbusMessage);
            } else if (dbusMessage.member() == ""NameLost"") {
                handleNameLost(dbusMessage);
            }
        }
    }
}",0.5119277565057266,0.17226307014894687,0.42090250132850504,0.45454545454545453,1.0
65,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(
        CommonAPI::CallStatus &_status,
        std::vector<DBusAddress> &_availableServiceInstances) {

    _availableServiceInstances.clear();
    DBusObjectManagerStub::DBusObjectPathAndInterfacesDict itsAvailableServiceInstances;
    registry_->getAvailableServiceInstances(proxy_.getDBusAddress().getService(),
            proxy_.getDBusAddress().getObjectPath(),
            itsAvailableServiceInstances);

    _status = CommonAPI::CallStatus::SUCCESS;
    translate(itsAvailableServiceInstances, _availableServiceInstances);
}","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    _status = CommonAPI::CallStatus::OK;
    _availableServiceInstances = m_availableServiceInstances;
}",0.2496793784426745,0.1557657840928714,0.1708738075999045,0.38636363636363635,0.2857142857142857
66,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(
        const std::string &_instance,
        CallStatus &_callStatus,
        AvailabilityStatus &_availabilityStatus) {

    CommonAPI::Address itsAddress(""local"", observedCapiInterfaceName_, _instance);
    DBusAddress itsDBusAddress;
    DBusAddressTranslator::get()->translate(itsAddress, itsDBusAddress);

    _availabilityStatus = AvailabilityStatus::NOT_AVAILABLE;
    if (registry_->isServiceInstanceAlive(
            itsDBusAddress.getInterface(),
            itsDBusAddress.getService(),
            itsDBusAddress.getObjectPath())) {
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
    }
    _callStatus = CallStatus::SUCCESS;
}","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    _callStatus = CallStatus::NotCalled;
    _availabilityStatus = AvailabilityStatus::Unknown;

    DBusError error;
    DBusConnection *connection = dbus_bus_get(DBUS_BUS_SESSION, &error);

    if (error.name != NULL) {
        _callStatus = CallStatus::Failed;
        return;
    }

    DBusMessage *msg = dbus_message_new_method_call(connection, ""org.freedesktop.DBus"", ""/"", ""NameOwner"");
    if (msg == NULL) {
        dbus_connection_unref(connection);
        _callStatus = CallStatus::Failed;
        return;
    }

    dbus_message_append_args(msg, DBUS_TYPE_STRING, _instance.c_str(), DBUS_TYPE_STRING, NULL);

    DBusMessage *reply = dbus_connection_send_with_reply_and_block(connection, msg, -1, &error);
    if (error.name != NULL) {
        dbus_message_unref(msg);
        dbus_connection_unref(connection);
        _callStatus = CallStatus::Failed;
        return;
    }

    if (reply == NULL) {
        dbus_message_unref(msg);
        dbus_connection_unref(connection);
        _callStatus = CallStatus::Failed;
        return;
    }

    if (dbus_message_get_reply_error(reply, &error)) {
        dbus_message_unref(reply);
        dbus_message_unref(msg);
        dbus_connection_unref(connection);
        _callStatus = CallStatus::Failed;
        return;
    }

    char *owner = NULL;
    if (dbus_message_get_args(reply, DBUS_TYPE_STRING, &owner, NULL) == TRUE) {
        if (owner != NULL) {
            _availabilityStatus = AvailabilityStatus::Available;
        } else {
            _availabilityStatus = AvailabilityStatus::Unavailable;
        }
        free(owner);
    } else {
        _availabilityStatus = AvailabilityStatus::Unknown;
    }

    dbus_message_unref(reply);
    dbus_message_unref(msg);
    dbus_connection_unref(connection);

    _callStatus = CallStatus::Success;
}",0.34997621638857207,0.058537654135334245,0.2465959695888886,0.7058823529411765,0.3888888888888889
67,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    DBusInputStream dbusInputStream(_message);
    std::string dbusObjectPath;
    std::vector<std::string> dbusInterfaceNames;

    dbusInputStream >> dbusObjectPath;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read object path"");
    }

    dbusInputStream >> dbusInterfaceNames;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read interface names"");
    }

    for (const auto& dbusInterfaceName : dbusInterfaceNames) {
        if(auto itsProxy = proxyWeakPtr_.lock() &&
                dbusInterfaceName == observedDbusInterfaceName_ &&
                removeInterface(dbusObjectPath, dbusInterfaceName)) {
            (void)itsProxy;
            notifyInterfaceStatusChanged(dbusObjectPath, dbusInterfaceName, AvailabilityStatus::NOT_AVAILABLE);
        }
    }
}","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    emit serviceUnavailable();
}",0.2995829583157579,0.0003391107040731756,0.05696708153331731,0.14102564102564102,0.0
68,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(
        const std::string &_objectPath,
        const std::string &_interfaceName,
        const AvailabilityStatus &_availability) {
    CommonAPI::Address itsAddress;
    DBusAddress itsDBusAddress(proxy_.getDBusAddress().getService(),
                               _objectPath,
                               _interfaceName);

    DBusAddressTranslator::get()->translate(itsDBusAddress, itsAddress);

    notifyListeners(itsAddress.getAddress(), _availability);
}","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    for (auto& listener : listeners) {
        listener->onInterfaceStatusChanged(_objectPath, _interfaceName, _availability);
    }
}",0.4869334558793834,0.3831079904852088,0.39832871551569504,0.43902439024390244,0.7272727272727273
69,cpp,"void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener,
                                           const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);

   std::weak_ptr<DBusProxy> itsdbusProxy = dbusProxy_->shared_from_this();
    dbusProxy_->getDBusConnection()->proxyPushFunctionToMainLoop<DBusConnection>(
            DBusProxy::notifySpecificListener,
            itsdbusProxy,
            _listener,
            _subscription);
}","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    m_listeners.append(_listener);
    m_subscriptions.append(_subscription);
    emit proxyStatusChanged(m_listeners, m_subscriptions);
}",0.5074570072323796,0.3450070063231997,0.384821022606319,0.3,1.0
70,cpp,"void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener,
                                             const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);
    (void)_listener;
    auto listenerIt = listeners_.begin();
    while(listenerIt != listeners_.end()) {
        if(listenerIt->first == _subscription)
            listenerIt = listeners_.erase(listenerIt);
        else
            ++listenerIt;
    }
}","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> lock(mutex_);
    listeners_.erase(std::remove_if(listeners_.begin(), listeners_.end(),
                                     [&](const Listener& listener) {
                                         return listener == _listener && listener.subscription == _subscription;
                                     }),
                     listeners_.end());
}",0.4598108194785868,0.25270331710913974,0.25915900842425527,0.5416666666666666,0.7857142857142857
71,cpp,"void DBusProxyBase::addSignalStateHandler(
            std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler,
            const uint32_t _subscription) {
    connection_->addSignalStateHandler(_handler, _subscription);
}","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    m_connection->addSignalStateHandler(_handler, _subscription);
}",0.7138713623153023,0.42268392163412416,0.4328015276270854,1.0,1.0
72,cpp,"void
DBusProxyManager::instancesAsyncCallback(
        std::shared_ptr<Proxy> _proxy,
        const CommonAPI::CallStatus &_status,
        const std::vector<DBusAddress> &_availableServiceInstances,
        GetAvailableInstancesCallback &_call) {
    (void)_proxy;
    std::vector<std::string> itsAvailableInstances;
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        translate(_availableServiceInstances, itsAvailableInstances);
    }
    _call(_status, itsAvailableInstances);
}","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::Success) {
        std::vector<std::string> addresses;
        for (const auto& address : _availableServiceInstances) {
            addresses.push_back(address.ToString());
        }
        _call(addresses);
    } else {
        _call({});
    }
}",0.5676960528003197,0.3156448552143068,0.4329171337647494,0.6888888888888889,0.8333333333333334
73,cpp,"bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    const char* objectPath = dbusMessage.getObjectPath();
    const char* interfaceName = dbusMessage.getInterface();

    if (NULL == objectPath) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" objectPath == NULL"");
    }
    if (NULL == interfaceName) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" interfaceName == NULL"");
    }

    DBusInterfaceHandlerPath handlerPath(objectPath, interfaceName);

    std::unique_lock<std::recursive_mutex> itsLock(objectPathLock_);

    auto handlerIterator = dbusRegisteredObjectsTable_.find(handlerPath);
    const bool foundDBusInterfaceHandler = handlerIterator != dbusRegisteredObjectsTable_.end();
    bool dbusMessageHandled = false;

    if (foundDBusInterfaceHandler) {
        std::shared_ptr<DBusInterfaceHandler> dbusStubAdapterBase = handlerIterator->second.front();
        itsLock.unlock();
        dbusMessageHandled = dbusStubAdapterBase->onInterfaceDBusMessage(dbusMessage);
        return dbusMessageHandled;
    } else if (dbusMessage.hasInterfaceName(""org.freedesktop.DBus.Introspectable"")) {
        dbusMessageHandled = onIntrospectableInterfaceDBusMessage(dbusMessage);
    }

    return dbusMessageHandled;
}","bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.type() == DBusMessage::MethodCall) {
        const std::string& interface = dbusMessage.interface();
        const std::string& member = dbusMessage.member();

        if (interface == ""org.freedesktop.DBus.Introspectable"") {
            if (member == ""Introspect"") {
                return handleIntrospect(dbusMessage);
            }
        }

        auto it = handlers_.find(interface);
        if (it != handlers_.end()) {
            auto& handlers = it->second;
            auto handler_it = handlers.find(member);
            if (handler_it != handlers.end()) {
                return handler_it->second(dbusMessage);
            }
        }
    }

    return false;
}",0.27060291204018916,0.07091666031501634,0.07809730444805674,0.39285714285714285,0.5405405405405406
74,cpp,"bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath,
                                                std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    const auto& dbusRegisteredObjectsTableIter = dbusRegisteredObjectsTable_.find(dbusInterfaceHandlerPath);
    const bool isDBusInterfaceHandlerAlreadyAdded = (dbusRegisteredObjectsTableIter != dbusRegisteredObjectsTable_.end());

    if (isDBusInterfaceHandlerAlreadyAdded) {

        auto handler = find(dbusRegisteredObjectsTableIter->second.begin(), dbusRegisteredObjectsTableIter->second.end(), dbusInterfaceHandler);
        if (handler != dbusRegisteredObjectsTableIter->second.end()) {
            if (dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.ObjectManager"" ||
                    dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.Properties"") {
                return true;
            }
            return false;
        }
    }

    auto insertSuccess = addToRegisteredObjectsTable(dbusInterfaceHandlerPath, dbusInterfaceHandler);
    return insertSuccess;
}","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    if (dbusInterfaceHandlerMap_.count(dbusInterfaceHandlerPath)) {
        if (dbusInterfaceHandlerMap_[dbusInterfaceHandlerPath] == dbusInterfaceHandler) {
            return true;
        } else {
            return false;
        }
    }

    dbusInterfaceHandlerMap_[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
    return true;
}",0.2778700452581687,0.16093145629167904,0.20848523267750385,0.3611111111111111,0.38095238095238093
75,cpp,"bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    auto handlerRecord = dbusRegisteredObjectsTable_.find(ifpath);
    if (handlerRecord == dbusRegisteredObjectsTable_.end()) {
        dbusRegisteredObjectsTable_.insert({
            ifpath,
            std::vector<std::shared_ptr<DBusInterfaceHandler>>({handler})
        });
    }
    else {
        std::vector<std::shared_ptr<DBusInterfaceHandler>> handlerList = handlerRecord->second;
        auto adapter = find(handlerList.begin(), handlerList.end(), handler);
        if (adapter != handlerList.end()) {
            return false;
        }
        else {
            handlerList.push_back(handler);
            handlerRecord->second = handlerList;
        }
    }
    return true;
}","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    if (registeredObjectsTable_.count(ifpath)) {
        return false;
    }

    registeredObjectsTable_[ifpath] = handler;
    return true;
}",0.20161042832259587,0.07818484965802054,0.17066650218657975,0.39759036144578314,0.16
76,c,"void send_negative_response(enum UDS_SID request_sid,
                            enum UDS_NRC response_code) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_NEGATIVE_RESPONSE, request_sid, response_code};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_negative_response(enum UDS_SID request_sid, enum UDS_NRC response_code) {
    
}",0.3428787561715827,0.020337705843951965,0.16935913702419686,0.18181818181818182,0.0
77,c,"static void send_session_control_response(enum UdsSessionState session_type,
                                          uint16_t p2_timeout_ms,
                                          uint16_t p2_star_timeout_ms) {
  int ret;
  uint8_t positive_sid = UDS_SID_DIAGNOSTIC_SESSION_CONTROL + 0x40;

  uint8_t tx_data[] = {
    positive_sid,
    session_type,
    (p2_timeout_ms >> 8) & 0xFF,
    p2_timeout_ms & 0xFF,
    ((p2_star_timeout_ms / 10) >> 8) & 0xFF,
    (p2_star_timeout_ms / 10) & 0xFF,
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_session_control_response(enum UdsSessionState session_type, uint16_t p2_timeout_ms, uint16_t p2_star_timeout_ms) {
    uint8_t response[8];
    uint8_t i = 0;

    response[i++] = 0x31;
    response[i++] = (uint8_t)session_type;
    response[i++] = (uint8_t)(p2_timeout_ms >> 8);
    response[i++] = (uint8_t)(p2_timeout_ms & 0xFF);
    response[i++] = (uint8_t)(p2_star_timeout_ms >> 8);
    response[i++] = (uint8_t)(p2_star_timeout_ms & 0xFF);
    response[i++] = 0x00;
    response[i++] = 0x00;

    uds_send(response, i);
}",0.2985954571334911,0.13413546494300832,0.14542826243745127,0.30612244897959184,0.6086956521739131
78,c,"void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t positive_sid = UDS_SID_ECU_RESET + 0x40;

  uint8_t tx_data[] = {positive_sid, reset_type};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_positive_reset_response(uint8_t reset_type) {
    uint8_t response[8];
    response[0] = 0x10;
    response[1] = reset_type;
    response[2] = 0x00;
    response[3] = 0x00;
    response[4] = 0x00;
    response[5] = 0x00;
    response[6] = 0x00;
    response[7] = 0x00;

    send_uds_message(response, 8);
}",0.12786478117386277,0.06170166677243975,0.06473071995509684,0.09090909090909091,0.29411764705882354
79,c,"void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    return;
  }

  uint8_t reset_type = data[1];

  if (reset_type == UDS_RESET_TYPE_HARD) {
    send_positive_reset_response(UDS_RESET_TYPE_HARD);

    k_sleep(K_MSEC(100));

    LOG_DBG(""Hard reset\n"");
    sys_reboot(SYS_REBOOT_COLD);
  } else {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_SUBFUNCTION_NOT_SUPPORTED);
  }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
    if (len == 1 && data[0] == 0x01) {
        volatile int dummy = 1;
        while (dummy);
    }
}",0.27184997436595737,0.20171869238152726,0.22289050740788358,0.16279069767441862,0.5
80,c,"void send_request_download_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_DOWNLOAD + 0x40;


  uint8_t tx_data[] = {
    positive_sid,
    0x20,  // positive response code
    0x00,
    0xD2,  // block size = 258 - 2
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_request_download_response() {
}",0.2703084863795179,5.857930039127716e-07,0.018733359725067695,0.0625,0.0
81,c,"static void send_transfer_data_response(uint8_t block_sequence_counter) {
  int ret;
  uint8_t positive_sid = UDS_SID_TRANSFER_DATA + 0x40;

  uint8_t tx_data[] = {positive_sid, block_sequence_counter};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
    uint8_t response[2];
    response[0] = 0x53;
    response[1] = block_sequence_counter;
    uds_send(response, 2);
}",0.12262632286391009,0.04328964575265184,0.09427446923240031,0.11764705882352941,0.23529411764705882
82,c,"static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
  int ret;
  uint8_t positive_sid = UDS_SID_ROUTINE_CONTROL + 0x40;

  uint8_t tx_data[] = {positive_sid, 0x1, (routine_id >> 8) & 0xFF,
                       routine_id & 0xFF, result};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
    uds_message_t msg;
    iso_tp_message_t iso_tp_msg;

    uds_message_init(&msg, UDS_POSITIVE_RESPONSE);
    msg.service_id = UDS_ROUTINE_CONTROL_SERVICE_ID;
    msg.result_code = result;
    msg.session_id = 0;

    iso_tp_msg.address = 0x7DF;
    iso_tp_msg.destination = 0x01;
    iso_tp_msg.message_length = uds_message_get_length(&msg);
    iso_tp_msg.message_data = (uint8_t *)uds_message_get_data(&msg);

    iso_tp_send_message(&iso_tp_msg);
}",0.19997917270177962,0.10165168943580866,0.11749577060207901,0.23076923076923078,0.35
83,c,"static void send_transer_exit_positive_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_TRANSFER_EXIT + 0x40;

  uint8_t tx_data[] = {positive_sid};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transer_exit_positive_response() {
    uint8_t response[8];
    response[0] = 0x7F;
    response[1] = 0x03;
    response[2] = 0x01;
    response[3] = 0x00;
    response[4] = 0x00;
    response[5] = 0x00;
    response[6] = 0x00;
    response[7] = 0x00;

    iso_tp_send(response, 8);
}",0.13936792272441612,0.06360003209533147,0.06962923455990878,0.09090909090909091,0.3333333333333333
84,c,"static int hvs_dac_convert_gain(int raw_gain,
                                enum hv_shield_dac_gains_t* gain) {
  switch (raw_gain) {
    case 1:
      *gain = HV_SHIELD_DAC_GAIN_1;
      return 0;
    case 2:
      *gain = HV_SHIELD_DAC_GAIN_2;
      return 0;
    case 4:
      *gain = HV_SHIELD_DAC_GAIN_4;
      return 0;
    case 8:
      *gain = HV_SHIELD_DAC_GAIN_8;
      return 0;
    case 16:
      *gain = HV_SHIELD_DAC_GAIN_16;
      return 0;
    default:
      return -ENOTSUP;
  }
}","static int hvs_dac_convert_gain(int raw_gain, enum hv_shield_dac_gains_t* gain) {
    switch (raw_gain) {
        case 0:
            *gain = HV_SHIELD_DAC_GAIN_0DB;
            return 0;
        case 1:
            *gain = HV_SHIELD_DAC_GAIN_2DB;
            return 0;
        case 2:
            *gain = HV_SHIELD_DAC_GAIN_4DB;
            return 0;
        case 3:
            *gain = HV_SHIELD_DAC_GAIN_6DB;
            return 0;
        case 4:
            *gain = HV_SHIELD_DAC_GAIN_8DB;
            return 0;
        case 5:
            *gain = HV_SHIELD_DAC_GAIN_10DB;
            return 0;
        case 6:
            *gain = HV_SHIELD_DAC_GAIN_12DB;
            return 0;
        case 7:
            *gain = HV_SHIELD_DAC_GAIN_14DB;
            return 0;
        case 8:
            *gain = HV_SHIELD_DAC_GAIN_16DB;
            return 0;
        case 9:
            *gain = HV_SHIELD_DAC_GAIN_18DB;
            return 0;
        case 10:
            *gain = HV_SHIELD_DAC_GAIN_20DB;
            return 0;
        default:
            return -1;
    }
}",0.6911509906787312,0.33239047096706986,0.6273354429673671,0.8048780487804879,1.0
85,c,"static inline uint8_t map_from_can_id(uint32_t can_id) {
  for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
    if (id_mapping[i] == can_id) {
      return i;
    }
  }

  return 0xff;
}","static inline uint8_t map_from_can_id(uint32_t can_id) {
    uint8_t i;
    uint32_t id;

    for (i = 0; i < CAN_ID_MAPPING_SIZE; i++) {
        id = can_id_mapping[i];
        if (id == can_id) {
            return i;
        }
    }

    return UINT8_MAX;
}",0.4711087778100904,0.43470212306642175,0.5449710834120352,0.47619047619047616,0.42857142857142855
86,c,"static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
  struct lin2can_data *data = dev->data;

 if (filter_id == TRANSLATABLE_ADDRESSES_LEN) {
    for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
      data->incoming_callbacks[i].callback = 0;
    }

    return;
  }

  if (filter_id >= TRANSLATABLE_ADDRESSES_LEN) {
    return;
  }
  data->incoming_callbacks[filter_id].callback = 0;
}","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev->data;
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			data->rx_filters[i].callback = NULL;
		}
	} else {
		if (filter_id < ARRAY_SIZE(data->rx_filters)) {
			data->rx_filters[filter_id].callback = NULL;
		}
	}
}",0.4432106581382237,0.392541831207609,0.42584945558959225,0.47619047619047616,0.4782608695652174
87,c,"static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  struct lin2can_data *data = dev->data;
  struct k_msgq *outgoing_frame_buffer = data->outgoing_frame_queue;

  struct lin2can_outgoing_frame_t outgoing;
  if (k_msgq_get(outgoing_frame_buffer, &outgoing, K_NO_WAIT)) {
    return false;
  }

  memcpy(frame, &outgoing.frame, sizeof(*frame));

  LOG_DBG(""Calling can tx callback"");

  outgoing.callback(dev, 0, outgoing.user_data);

  return true;
}","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
    struct lin_context *ctx = (struct lin_context *)user_data;
    struct list_head *list = &ctx->tx_queue;
    struct lin_frame *tx_frame = container_of(frame, struct lin_frame, list);

    list_del(&tx_frame->list);

    tx_frame->completion_callback(tx_frame->completion_data);

    return true;
}",0.33148471056284545,0.16625732759710068,0.19588841120600523,0.41379310344827586,0.55
88,c,"static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  const struct lin2can_data *data = dev->data;

 uint8_t mapped_id = frame->data[0] >> 6;

  __ASSERT(mapped_id < TRANSLATABLE_ADDRESSES_LEN, ""Unexpected LIN-ID: %x"",
           mapped_id);

  LOG_DBG(""Incoming can frame with can id %x"", id_mapping[mapped_id]);

 if (!data->incoming_callbacks[mapped_id].callback) {
    return;
  }

  struct can_frame translated = {
    .id = id_mapping[mapped_id],
    .dlc = 8,
  };
  memcpy(translated.data, frame->data, frame->len);

  translated.data[0] = frame->data[0] & 0x3f;

  LOG_DBG(""Calling according can callback"");

  data->incoming_callbacks[mapped_id].callback(
      dev, &translated, data->incoming_callbacks[mapped_id].user_data);
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
    struct can_frame can_frame;
    can_frame.id = frame->id;
    can_frame.dlc = frame->dlc;
    memcpy(can_frame.data, frame->data, frame->dlc);

    if (user_data != NULL) {
        ((void (*)(struct can_frame *))user_data)(&can_frame);
    }
}",0.2318961346229028,0.0685982955098319,0.12967589815419303,0.3793103448275862,0.35
89,c,"static int hv_shield_init(const struct device* dev) {
  const struct hv_shield_config_t* config = dev->config;
  struct hv_shield_data_t* data = dev->data;

  int err = gpio_pin_configure_dt(&config->oe_gpio_spec, GPIO_OUTPUT_INACTIVE);
  if (err) {
    LOG_ERR(""Error setting up Output enable pin (%d)"", err);
    return err;
  }

  memset(&data->registers, 0, sizeof(data->registers));

  err = _hv_shield_update(dev);
  if (err) {
    LOG_ERR(""Error writing registers (%d)"", err);
    return err;
  }

  err = gpio_pin_set_dt(&config->oe_gpio_spec, 1);
  if (err) {
    LOG_ERR(""Error setting enabling output (%d)"", err);
  }

  return err;
}","static int hv_shield_init(const struct device* dev) {
    struct hv_shield_data *data = dev->data;

    data->reg = regulator_get(dev, ""hv_shield_reg"");
    if (!data->reg) {
        return -ENODEV;
    }

    regulator_enable(data->reg);

    data->output_enable = regulator_get(dev, ""hv_shield_output"");
    if (!data->output_enable) {
        regulator_put(data->reg);
        return -ENODEV;
    }

    regulator_enable(data->output_enable);

    return 0;
}",0.26717695711009787,0.08568370583643908,0.11906900338936609,0.34782608695652173,0.5161290322580645
90,c,"static int hvs_set_dac_gain(const struct device* dev,
                            uint8_t dac,
                            enum hv_shield_dac_gains_t gain) {
  if (dac > 1) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;
  switch (dac) {
    case 0:
      data->registers.dac0 = gain;
      break;
    case 1:
      data->registers.dac1 = gain;
      break;
    default:
      return -EINVAL;
  }

  return _hv_shield_update(dev);
}","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
    return 0;
}",0.4104152403028944,0.10914802218503572,0.25978566629926914,0.2727272727272727,0.0
91,c,"static int hvs_set_gpio_output_enable(const struct device* dev,
                                      uint8_t index,
                                      bool enable) {
  if (index > 31) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;

  if (index % 8 < 4) {
    index += 4;
  } else {
    index -= 4;
  }

  if (enable) {
    data->registers.gpio_output |= 1 << index;
  } else {
    data->registers.gpio_output &= ~(1 << index);
  }

  return _hv_shield_update(dev);
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
    uint8_t reg_value = 0;
    uint8_t nibble = (enable) ? 0x0F : 0x00;
    uint8_t remapped_index = ((index & 0x0F) << 4) | ((index & 0xF0) >> 4);

    reg_value = (uint8_t)(nibble & (0xFF << (remapped_index * 4)));

    return 0;
}",0.2784620195990402,0.18320885972247614,0.1892870174158232,0.2830188679245283,0.4583333333333333
92,c,"static void can_router_frame_cb(const struct device *dev,
                                struct can_frame *frame,
                                void *user_data) {
  const struct device *to = user_data;

  const int err = can_send(to, frame, K_NO_WAIT, can_router_tx_cb, NULL);
  if (err) {
    LOG_WRN(""Can send failed (%d)"", err);
    return;
  }

  LOG_DBG(""Routed frame from %s to %s"", dev->name, to->name);
}","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
    struct can_frame forwarded_frame = *frame;
    struct can_bus *target_bus = (struct can_bus *)user_data;

    if (target_bus) {
        can_bus_send_frame(target_bus, &forwarded_frame);
    }
}",0.4255542821907099,0.24487528992532026,0.28234183883751934,0.425,0.75
93,c,"int can_router_register(const struct can_router_entry_t *entries,
                        int entry_count) {
  LOG_DBG(""Registering %d can router entries"", entry_count);
  for (int i = 0; i < entry_count; i++) {
    const int err =
        can_add_rx_filter(*entries[i].from, can_router_frame_cb,
                          (void *)*entries[i].to, &entries[i].filter);
    if (err) {
      return err;
    }
  }

  LOG_DBG(""Registered %d can router entries"", entry_count);

  return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
    if (entries == NULL || entry_count <= 0) {
        return -1;
    }

    for (int i = 0; i < entry_count; i++) {
        if (entries[i].interface_id < 0 || entries[i].can_id < 0) {
            return -1;
        }
    }

    return 0;
}",0.4100960716075184,0.36836006390060605,0.3852965337422821,0.41304347826086957,0.47368421052631576
94,c,"static int can_router_sysinit() {
  LOG_DBG(""Initializing can router"");

  STRUCT_SECTION_FOREACH (can_router_table_t, table) {
    int err = can_router_register(table->entries, table->entry_count);
    if (err) {
      LOG_ERR(""could not register can router"");
      return err;
    }
  }

  return 0;
}","static int can_router_sysinit() {
    return 0;
}",0.3189706654912061,0.01928492041734402,0.11866670706472181,0.13793103448275862,0.0
95,c,"static int hvs_set_masked_raw(const struct device* port,
                              gpio_port_pins_t mask,
                              gpio_port_value_t value) {
  const struct hv_shield_gpio_config_t* config = port->config;

  for (int i = 0; i < config->lv_gpios_count; i++) {
    if (!(mask & BIT(i))) continue;

    int ret = gpio_pin_set(config->lv_gpios[i].port, config->lv_gpios[i].pin,
                           !!(value & BIT(i)));
    if (ret < 0) {
      LOG_ERR(""Error settings gpio %d (error %d)"", i, ret);
      return ret;
    }
  }

  return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
	gpio_port_value_t current_value;
	int ret;

	ret = gpio_port_read(port, &current_value);
	if (ret < 0) {
		return ret;
	}

	current_value &= ~mask;
	current_value |= (value & mask);

	ret = gpio_port_write(port, current_value);
	if (ret < 0) {
		return ret;
	}

	return 0;
}",0.347836417730179,0.301983849638871,0.31817538060387895,0.2711864406779661,0.5
96,c,"static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
  struct abstract_lin_data *data = dev->data;

  if (free_slots == NULL) {
    return -EINVAL;
  }

  *free_slots = CONFIG_ABSTRACT_LIN_MAX_FRAME_COUNT - data->used_callbacks;

  return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
    if (!dev || !free_slots)
        return -EINVAL;

    if (dev->id == AL_DEVICE_ID_SOUND) {
        *free_slots = al_sound_cb_slots;
        return 0;
    } else if (dev->id == AL_DEVICE_ID_VIDEO) {
        *free_slots = al_video_cb_slots;
        return 0;
    } else {
        *free_slots = 0;
        return -ENODEV;
    }
}",0.46876918723958544,0.23055801508610654,0.37785206720556863,0.5666666666666667,0.7
97,c,"static int al_register_incoming_cb(const struct device *dev,
                                   abstract_lin_incoming_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = INCOMING;
  data->callbacks[free_index].incoming_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    struct al_lin_data *lin_data = dev->data;
    if (!lin_data) {
        return -EINVAL;
    }

    if (frame_id >= AL_MAX_FRAME_ID) {
        return -EINVAL;
    }

    if (callback == NULL) {
        return -EINVAL;
    }

    lin_data->incoming_callbacks[frame_id] = callback;
    lin_data->incoming_frame_sizes[frame_id] = frame_size;
    lin_data->incoming_user_data[frame_id] = user_data;

    return 0;
}",0.42029010336024153,0.34304184051347647,0.3766339790899547,0.4852941176470588,0.47619047619047616
98,c,"static int al_register_outgoing_cb(const struct device *dev,
                                   abstract_lin_outgoing_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = OUTGOING;
  data->callbacks[free_index].outgoing_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    struct al_lin_data *lin_data = dev->data;
    if (!lin_data) {
        return -EINVAL;
    }

    lin_data->outgoing_callback[frame_id] = callback;
    lin_data->outgoing_frame_size[frame_id] = frame_size;
    lin_data->outgoing_user_data[frame_id] = user_data;

    return 0;
}",0.3547166617340757,0.2612635890491159,0.34457784780315326,0.45588235294117646,0.35714285714285715
99,c,"int abstract_lin_scheduler_set_active_table(
    abstract_lin_scheduler_handle_t sched, size_t table_index) {
  if (table_index >= sched->table_count) {
    return -ENOENT;
  }

  bool active_before = sched->current_table != -1;

  if (active_before) {
    k_sem_take(&sched->active, K_FOREVER);
  }

  sched->current_table = table_index;
  sched->current_table_entry = 0;  // start from the beginning again.

  k_sem_give(&sched->active);

  return 0;
}","int abstract_lin_scheduler_set_active_table(void *scheduler, void *table) {
    if (scheduler == NULL || table == NULL) {
        return -1;
    }

    return 0;
}",0.08945241489569244,0.025481264574581768,0.03934593886783714,0.02631578947368421,0.26666666666666666
100,c,"void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
  if (sched->current_table == -1) {
    return;  // already stopped.
  }

  k_sem_take(&sched->active, K_FOREVER);

  sched->current_table = -1;
}","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
    sched->disabled = 1;
}",0.19764856642652098,0.08537025563868135,0.13855734340073594,0.4,0.16666666666666666
