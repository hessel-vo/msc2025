id,language,reference,generated,generated_rci,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
2,python,"def is_datatype(cls, value: Any, datatype: str) -> bool:
    t = cls.get_type(datatype)
    if t is None:
        raise DatatypesException(f""Unsupported datatype: {datatype}"")
    return t[1](value)","from typing import Any

def is_datatype(cls, value: Any, datatype: str) -> bool:
    if datatype not in cls.__dict__:
        raise ValueError(f""Unsupported datatype: {datatype}"")
    return cls.__dict__[datatype](value)","from typing import Any

def is_datatype(cls, value: Any, datatype: str) -> bool:
    if datatype not in cls.__dict__:
        raise ValueError(f""Unsupported datatype: {datatype}"")
    return cls.__dict__[datatype](value)",54.35824614312639,37.25748409395151,42.48319278624633,57.692307692307686,80.0
3,python,"def is_xintx(value: Any, signed: bool, bits: int):
    values = [value]
    if isinstance(value, list):
        values = value

    for v in values:
        if not isinstance(v, int):
            return False
        if not signed and v < 0:
            return False
        max = 2**bits - 1
        min = 0
        if signed:
            max = 2 ** (bits - 1) - 1
            min = -(2 ** (bits - 1))
        if not (v <= max and v >= min):
            return False
    return True","from typing import Any, List

def is_xintx(value: Any, signed: bool, bits: int) -> bool:
    if isinstance(value, list):
        return all(is_xintx(item, signed, bits) for item in value)
    elif isinstance(value, int):
        if signed:
            return -2**(bits - 1) <= value < 2**(bits - 1)
        else:
            return 0 <= value < 2**bits
    else:
        return False","from typing import Any, List

def is_xintx(value: Any, signed: bool, bits: int) -> bool:
    if isinstance(value, list):
        return all(is_xintx(item, signed, bits) for item in value)
    elif isinstance(value, int):
        if signed:
            return -2**(bits - 1) <= value < 2**(bits - 1)
        else:
            return 0 <= value < 2**bits
    else:
        return False",24.38496525442276,10.180664122632171,11.426120961982924,38.095238095238095,37.83783783783784
4,python,"def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
        for t in cls.types:
            if datatype == t[0]:
                return t
        return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_def in cls.__dataclass_fields__.values():
        if type_def.type.__name__ == datatype:
            return type_def.type, type_def.default_factory, type_def.metadata
    return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_def in cls.__dataclass_fields__.values():
        if type_def.type.__name__ == datatype:
            return type_def.type, type_def.default_factory, type_def.metadata
    return None",61.84616507595874,47.93450670762756,54.669008815062604,62.96296296296296,81.81818181818183
5,python,"def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if not fqn:
        return {}
    fqn_namespaced_datatypes = {}
    for t in dynamic_datatypes:
        if fqn.startswith(t):
            continue

        if fqn.startswith(""."".join(t.split(""."")[:-1])):
            fqn_namespaced_datatypes[(t.split(""."")[-1])] = t

    if fqn_namespaced_datatypes:
        log.debug(f""Namespaced datatypes, {fqn=}, {fqn_namespaced_datatypes=}"")
    return fqn_namespaced_datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn is None:
        return {}
    fqn_parts = fqn.split(""."")
    namespace = ""."".join(fqn_parts[:-1])
    datatype_name = fqn_parts[-1]
    datatypes = {}
    for datatype in get_datatypes():
        if datatype.namespace == namespace:
            datatypes[datatype.short_name] = datatype.fqn
    return datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn is None:
        return {}
    fqn_parts = fqn.split(""."")
    namespace = ""."".join(fqn_parts[:-1])
    datatype_name = fqn_parts[-1]
    datatypes = {}
    for datatype in get_datatypes():
        if datatype.namespace == namespace:
            datatypes[datatype.short_name] = datatype.fqn
    return datatypes",38.80886391180951,30.415350168974136,34.07936473752317,50.0,40.74074074074074
7,python,"def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    is_array = False
    apigear_type = None
    if t.endswith(""[]""):
        is_array = True
        t = t[0:-2]

    if t in [""int8"", ""int16"", ""int32"", ""uint8"", ""uint16"", ""uint32""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT32.value)
    elif t in [""int64"", ""uint64""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT64.value)
    elif t == ""float"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT32.value)
    elif t == ""double"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT64.value)
    elif t == ""boolean"":
        apigear_type = ApiGearType(ApiGearBasicType.BOOL.value)
    elif t == ""string"":
        apigear_type = ApiGearType(ApiGearBasicType.STRING.value)
    else:
        apigear_type = ApiGearType(t.replace(""."", ""_""))

    if is_array and apigear_type is not None:
        apigear_type.is_array = True

    return apigear_type","import typing

from apigeardef.core import ApiGearType


def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    if t == ""string"":
        return ApiGearType.STRING
    elif t == ""integer"":
        return ApiGearType.INTEGER
    elif t == ""float"":
        return ApiGearType.FLOAT
    elif t == ""boolean"":
        return ApiGearType.BOOLEAN
    elif t == ""bytes"":
        return ApiGearType.BYTES
    elif t == ""map"":
        return ApiGearType.MAP
    elif t == ""list"":
        return ApiGearType.LIST
    elif t == ""dict"":
        return ApiGearType.DICT
    elif t == ""set"":
        return ApiGearType.SET
    elif t == ""tuple"":
        return ApiGearType.TUPLE
    elif t == ""object"":
        return ApiGearType.OBJECT
    elif t == ""any"":
        return ApiGearType.ANY
    elif t == ""void"":
        return ApiGearType.VOID
    elif t.endswith(""[]""):
        t = t[:-2]
        if t == ""string"":
            return ApiGearType.STRING_ARRAY
        elif t == ""integer"":
            return ApiGearType.INTEGER_ARRAY
        elif t == ""float"":
            return ApiGearType.FLOAT_ARRAY
        elif t == ""boolean"":
            return ApiGearType.BOOLEAN_ARRAY
        elif t == ""bytes"":
            return ApiGearType.BYTES_ARRAY
        elif t == ""map"":
            return ApiGearType.MAP_ARRAY
        elif t == ""list"":
            return ApiGearType.LIST_ARRAY
        elif t == ""dict"":
            return ApiGearType.DICT_ARRAY
        elif t == ""set"":
            return ApiGearType.SET_ARRAY
        elif t == ""tuple"":
            return ApiGearType.TUPLE_ARRAY
        elif t == ""object"":
            return ApiGearType.OBJECT_ARRAY
        elif t == ""any"":
            return ApiGearType.ANY_ARRAY
        elif t == ""void"":
            return ApiGearType.VOID_ARRAY
        else:
            return ApiGearType.OBJECT_ARRAY
    else:
        if ""."" in t:
            t = t.replace(""."", ""_"")
        return ApiGearType.OBJECT","import typing

from apigeardef.core import ApiGearType


def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    if t == ""string"":
        return ApiGearType.STRING
    elif t == ""integer"":
        return ApiGearType.INTEGER
    elif t == ""float"":
        return ApiGearType.FLOAT
    elif t == ""boolean"":
        return ApiGearType.BOOLEAN
    elif t == ""bytes"":
        return ApiGearType.BYTES
    elif t == ""map"":
        return ApiGearType.MAP
    elif t == ""list"":
        return ApiGearType.LIST
    elif t == ""dict"":
        return ApiGearType.DICT
    elif t == ""set"":
        return ApiGearType.SET
    elif t == ""tuple"":
        return ApiGearType.TUPLE
    elif t == ""object"":
        return ApiGearType.OBJECT
    elif t == ""any"":
        return ApiGearType.ANY
    elif t == ""void"":
        return ApiGearType.VOID
    elif t.endswith(""[]""):
        t = t[:-2]
        if t == ""string"":
            return ApiGearType.STRING_ARRAY
        elif t == ""integer"":
            return ApiGearType.INTEGER_ARRAY
        elif t == ""float"":
            return ApiGearType.FLOAT_ARRAY
        elif t == ""boolean"":
            return ApiGearType.BOOLEAN_ARRAY
        elif t == ""bytes"":
            return ApiGearType.BYTES_ARRAY
        elif t == ""map"":
            return ApiGearType.MAP_ARRAY
        elif t == ""list"":
            return ApiGearType.LIST_ARRAY
        elif t == ""dict"":
            return ApiGearType.DICT_ARRAY
        elif t == ""set"":
            return ApiGearType.SET_ARRAY
        elif t == ""tuple"":
            return ApiGearType.TUPLE_ARRAY
        elif t == ""object"":
            return ApiGearType.OBJECT_ARRAY
        elif t == ""any"":
            return ApiGearType.ANY_ARRAY
        elif t == ""void"":
            return ApiGearType.VOID_ARRAY
        else:
            return ApiGearType.OBJECT_ARRAY
    else:
        if ""."" in t:
            t = t.replace(""."", ""_"")
        return ApiGearType.OBJECT",19.596942621110674,6.729351483963636,15.833669254359808,34.51327433628318,21.311475409836063
8,python,"def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    apigear_type = get_apigear_datatype(datatype)
    data = node.get_vss_data()

    if apigear_type is None:
        log.warning(f""Datatype {datatype} of node {node.name} currently not supported"")
        return None

    property = ApiGearProperty(apigear_type)
    if data.description != """":
        property.description = data.description
    return property","def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if datatype == ""int"":
        api_gear_type = ""int32""
    elif datatype == ""float"":
        api_gear_type = ""float""
    elif datatype == ""bool"":
        api_gear_type = ""bool""
    elif datatype == ""string"":
        api_gear_type = ""string""
    elif datatype == ""array"":
        api_gear_type = ""array""
    elif datatype == ""struct"":
        api_gear_type = ""struct""
    else:
        logging.warning(f""Unsupported datatype: {datatype}"")
        return None

    return ApiGearProperty(
        name=node.name,
        datatype=api_gear_type,
        description=node.description,
    )","def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if datatype == ""int"":
        api_gear_type = ""int32""
    elif datatype == ""float"":
        api_gear_type = ""float""
    elif datatype == ""bool"":
        api_gear_type = ""bool""
    elif datatype == ""string"":
        api_gear_type = ""string""
    elif datatype == ""array"":
        api_gear_type = ""array""
    elif datatype == ""struct"":
        api_gear_type = ""struct""
    else:
        logging.warning(f""Unsupported datatype: {datatype}"")
        return None

    return ApiGearProperty(
        name=node.name,
        datatype=api_gear_type,
        description=node.description,
    )",30.434319701702,14.560686428168232,23.843259045306432,33.33333333333333,50.0
10,python,"def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    spec = None
    vspecs: list[VSpec] = []
    for s in specs:
        includes = [s.parent] + include_dirs
        vspecs.extend(get_vspecs(includes, s))
    pre = ""VSpecs""
    if identifier:
        pre += f"" ({identifier})""
    log.info(f""{pre} loaded, amount={len(vspecs)}"")
    for vspec in vspecs:
        log.debug(vspec)
        if spec is None:
            spec = vspec
        else:
            spec.update(vspec)
    if not spec:
        msg = f""Weird behavior. Could not load any spec: {specs}""
        log.error(msg)
        raise SpecException(msg)
    return spec","from pathlib import Path
from typing import List, Optional

from vspec.vspec import VSpec
from vspec.vspec_parser import VSpecParser
from vspec.vspec_loader import VSpecLoader


def load_vspec(include_dirs: List[Path], specs: List[Path], identifier: Optional[str] = None) -> VSpec:
    """"""Loads and parses multiple VSpec files from specified paths, using a list of include directories,
    then merges them into a single composite VSpec object and returns it, raising an exception if no
    files are successfully loaded""""""
    loader = VSpecLoader(include_dirs)
    loaded_specs = loader.load_specs(specs)
    if not loaded_specs:
        raise ValueError(""No VSpec files were successfully loaded"")
    parser = VSpecParser()
    return parser.parse_specs(loaded_specs, identifier)","from pathlib import Path
from typing import List, Optional

from vspec.vspec import VSpec
from vspec.vspec_parser import VSpecParser
from vspec.vspec_loader import VSpecLoader


def load_vspec(include_dirs: List[Path], specs: List[Path], identifier: Optional[str] = None) -> VSpec:
    """"""Loads and parses multiple VSpec files from specified paths, using a list of include directories,
    then merges them into a single composite VSpec object and returns it, raising an exception if no
    files are successfully loaded""""""
    loader = VSpecLoader(include_dirs)
    loaded_specs = loader.load_specs(specs)
    if not loaded_specs:
        raise ValueError(""No VSpec files were successfully loaded"")
    parser = VSpecParser()
    return parser.parse_specs(loaded_specs, identifier)",20.483540912524372,4.019031272083988,5.253633670003175,37.77777777777778,34.883720930232556
11,python,"def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if isinstance(value, dict):
            if key in base and isinstance(base[key], dict):
                deep_update(base[key], value)
            else:
                base[key] = value
        else:
            base[key] = value","from typing import Any

def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for k, v in update.items():
        if isinstance(v, dict) and k in base and isinstance(base[k], dict):
            deep_update(base[k], v)
        else:
            base[k] = v","from typing import Any

def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for k, v in update.items():
        if isinstance(v, dict) and k in base and isinstance(base[k], dict):
            deep_update(base[k], v)
        else:
            base[k] = v",58.76662322841648,35.30389445349419,37.262598460171745,81.25,81.25
12,python,"def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return v
    pattern = r""^0x[0-9A-Fa-f]{8}$""
    assert bool(re.match(pattern, v)), f""'{v}' is not a valid 'constUID'""
    return v","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is not None:
        if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in ""0123456789abcdef"" for c in v[2:]):
            return v
        else:
            return None
    return None","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is not None:
        if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in ""0123456789abcdef"" for c in v[2:]):
            return v
        else:
            return None
    return None",50.78226129379407,34.42391013759617,46.705135037580135,52.0,70.0
13,python,"def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw(fqn=fqn, **data)
    try:
        model = resolve_vss_raw(model)
    except (ValidationError, ModelException):
        log.debug(f""'{fqn}', incomplete, initialized as '{model.__class__.__name__}'"")
        return model
    return model","from typing import Any

from vss.raw_model import VSSRaw


def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    vss_raw = VSSRaw(data)
    if vss_raw.resolve(fqn):
        return vss_raw
    return VSSRaw(data)","from typing import Any

from vss.raw_model import VSSRaw


def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    vss_raw = VSSRaw(data)
    if not vss_raw.resolve(fqn):
        return VSSRaw(data)
    return vss_raw",44.62798308753856,31.602136101271466,32.7431295822161,47.5,66.66666666666666
14,python,"def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    datatypes = get_all_datatypes()
    for value in values:
        assert value in datatypes, f""Invalid datatype: '{value}'""
    return values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_datatypes = [""int"", ""float"", ""str"", ""bool""]
    return values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_datatypes = [""int"", ""float"", ""str"", ""bool""]
    for value in values:
        assert value in valid_datatypes
    return values",37.770610356666324,22.885697136375974,24.03007762362267,45.83333333333333,58.333333333333336
15,python,"def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    tree_content_lines = []
    for pre, fill, node in RenderTree(tree):
        tree_content_lines.append(""%s%s"" % (pre, node.name))
        for attribute in attributes:
            content = getattr(node.data, attribute, None)
            if content is None:
                continue
            if isinstance(content, str):
                tree_content_lines.append(""%s%s='%s'"" % (fill, attribute, content))
            else:
                tree_content_lines.append(""%s%s=%s"" % (fill, attribute, content))
    return ""\n"".join(tree_content_lines)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    rendered = """"
    rendered += tree.name
    if attributes:
        rendered += ""(""
        for i, attr in enumerate(attributes):
            if i > 0:
                rendered += "", ""
            rendered += f""{attr}={getattr(tree, attr)}""
        rendered += "")""
    rendered += ""\n""
    for child in tree.children:
        rendered += get_rendered_tree(child, attributes)
    return rendered","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    rendered = """"
    rendered += tree.name
    if attributes:
        rendered += ""(""
        for i, attr in enumerate(attributes):
            if i > 0:
                rendered += "", ""
            rendered += f""{attr}={getattr(tree, attr)}""
        rendered += "")""
    rendered += ""\n""
    for child in tree.children:
        rendered += get_rendered_tree(child, attributes)
    return rendered",25.00537788667113,13.37614391460889,15.51176439320924,36.92307692307693,34.21052631578947
16,python,"def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not isinstance(self.data, VSSDataBranch):
        raise NoInstanceRootException()

    if not self.data.is_instance:
        return self, depth

    if self.parent is None:
        raise NoInstanceRootException()

    return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not self.is_branch:
        raise ValueError(""Starting node is not a branch"")

    if self.parent is None:
        return self, depth

    if not self.parent.is_instance:
        return self.parent, depth + 1

    return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not self.is_branch:
        raise ValueError(""Starting node is not a branch"")

    if self.parent is None:
        return self, depth

    if not self.parent.is_instance:
        return self.parent, depth + 1

    return self.parent.get_instance_root(depth + 1)",60.359350877812055,46.454150294556804,58.535884795638815,57.49999999999999,78.94736842105263
17,python,"def count_instance_children_depth(self) -> int:
    for child in self.children:
        if isinstance(child.data, VSSDataBranch):
            if child.data.is_instance:
                return 1 + child.count_instance_children_depth()
    return 0","def count_instance_children_depth(self) -> int:
    if not self.children:
        return 0
    for child in self.children:
        if isinstance(child, VSSDataBranch) and child.is_instance:
            return 1 + count_instance_children_depth(child)
    return 0","def count_instance_children_depth(self) -> int:
    if not self.children:
        return 0
    for child in self.children:
        if isinstance(child, VSSDataBranch) and child.is_instance:
            return 1 + count_instance_children_depth(child)
    return 0",47.76287801690429,32.077142814517714,42.825300930118075,30.434782608695656,85.71428571428571
18,python,"def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    ids = []
    for i in node_ids:
        if get_expected_parent(i) == name:
            ids.append(i)
    return ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        if node_id.split('_')[1] == name:
            children_ids.append(node_id)
    return children_ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        parts = node_id.split('_')
        if len(parts) > 1 and parts[1] == name:
            children_ids.append(node_id)
    return children_ids",65.24065932875062,43.03767738122004,44.591626600449125,73.33333333333333,100.0
19,python,"def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    result = getattr(o, name, default)
    if result is None and default is not None:
        result = default
    return result","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        return getattr(o, name)
    except AttributeError:
        return default","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        value = getattr(o, name)
        if value is None:
            return default
        return value
    except AttributeError:
        return default",42.338134767853695,36.67473999422677,37.67779907718803,41.66666666666667,53.333333333333336
20,python,"def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    fd.write('syntax = ""proto3"";\n\n')

    imports = []
    for node in findall(tree, filter_=lambda n: isinstance(n.data, VSSDataDatatype)):
        datatype = node.data.datatype
        if ""."" not in datatype:
            continue
        struct_path = Path(node.data.datatype.replace(""."", ""/""))  # type: ignore
        imports.append(f""{struct_path.parent}/{struct_path.parent.name}.proto"")
    write_imports(fd, imports)

    # write proto messages to file
    for node in findall(tree, filter_=lambda node: isinstance(node.data, VSSDataBranch)):
        fd.write(f""message {node.get_fqn('')} {{"" + ""\n"")
        print_messages(node.children, fd, static_uid, add_optional)
        fd.write(""}\n\n"")","```python
from typing import TextIOWrapper
from vss_types import VSSNode

def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""complex"":
        fd.write(f""import {tree.name}pb2\n"")
    if tree.type == ""branch"":
        fd.write(f""{tree.name} = {tree.name}pb2.Message()\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
    elif tree.type == ""signal"":
        if tree.type == ""signal"":
            if tree.data_type == ""uint8_t"":
                fd.write(f""{tree.name} = {tree.name}pb2.uint8_t_t()\n"")
            elif tree.data_type == ""uint16_t"":
                fd.write(f""{tree.name} = {tree.name}pb2.uint16_t_t()\n"")
            elif tree.data_type == ""uint32_t"":
                fd.write(f""{tree.name} = {tree.name}pb2.uint32_t_t()\n"")
            elif tree.data_type == ""uint64_t"":
                fd.write(f""{tree.name} = {tree.name}pb2.uint64_t_t()\n"")
            elif tree.data_type == ""int8_t"":
                fd.write(f""{tree.name} = {tree.name}pb2.int8_t_t()\n"")
            elif tree.data_type == ""int16_t"":
                fd.write(f""{tree.name} = {tree.name}pb2.int16_t_t()\n"")
            elif tree.data_type == ""int32_t"":
                fd.write(f""{tree.name} = {tree.name}pb2.int32_t_t()\n"")
            elif tree.data_type == ""int64_t"":
                fd.write(f""{tree.name} = {tree.name}pb2.int64_t_t()\n"")
            elif tree.data_type == ""float"":
                fd.write(f""{tree.name} = {tree.name}pb2.float_t()\n"")
            elif tree.data_type == ""double"":
                fd.write(f""{tree.name} = {tree.name}pb2.double_t()\n"")
            elif tree.data_type == ""bool"":
                fd.write(f""{tree.name} = {tree.name}pb2.bool_t()\n"")
            elif tree.data_type == ""string"":
                fd.write(f""{tree.name} = {tree.name}pb2.string_t()\n"")
            elif tree.data_type == ""byte"":
                fd.write(f""{tree.name} = {tree.name}pb2.byte_t()\n"")
            elif tree.data_type == ""uint8_t"":
                fd.write(f""{tree.name} = {tree.name}pb2.uint8_t_t()\n"")
            elif tree.data_type == ""uint16_t"":
                fd.write(","```python
from typing import TextIOWrapper
from vss_types import VSSNode

def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""complex"":
        fd.write(f""import {tree.name}pb2\n"")
    if tree.type == ""branch"":
        fd.write(f""{tree.name} = {tree.name}pb2.Message()\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
    elif tree.type == ""signal"":
        if tree.data_type == ""uint8_t"":
            fd.write(f""{tree.name} = {tree.name}pb2.uint8_t_t()\n"")
        elif tree.data_type == ""uint16_t"":
            fd.write(f""{tree.name} = {tree.name}pb2.uint16_t_t()\n"")
        elif tree.data_type == ""uint32_t"":
            fd.write(f""{tree.name} = {tree.name}pb2.uint32_t_t()\n"")
        elif tree.data_type == ""uint64_t"":
            fd.write(f""{tree.name} = {tree.name}pb2.uint64_t_t()\n"")
        elif tree.data_type == ""int8_t"":
            fd.write(f""{tree.name} = {tree.name}pb2.int8_t_t()\n"")
        elif tree.data_type == ""int16_t"":
            fd.write(f""{tree.name} = {tree.name}pb2.int16_t_t()\n"")
        elif tree.data_type == ""int32_t"":
            fd.write(f""{tree.name} = {tree.name}pb2.int32_t_t()\n"")
        elif tree.data_type == ""int64_t"":
            fd.write(f""{tree.name} = {tree.name}pb2.int64_t_t()\n"")
        elif tree.data_type == ""float"":
            fd.write(f""{tree.name} = {tree.name}pb2.float_t()\n"")
        elif tree.data_type == ""double"":
            fd.write(f""{tree.name} = {tree.name}pb2.double_t()\n"")
        elif tree.data_type == ""bool"":
            fd.write(f""{tree.name} = {tree.name}pb2.bool_t()\n"")
        elif tree.data_type == ""string"":
            fd.write(f""{tree.name} = {tree.name}pb2.string_t()\n"")
        elif tree.data_type == ""byte"":
            fd.write(f""{tree.name} = {tree.name}pb2.byte_t()\n"")
        elif tree.data_type == ""uint8_t"":
            fd.write(f""{tree.name} = {tree.name}pb2.uint8_t_t()\n"")
        elif tree.data_type == ""uint16_t"":
            fd.write(f""{tree.name} = {tree.",22.07927735373195,6.580888993517068,15.833204002930405,28.865979381443296,37.03703703703704
21,python,"def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    meta: dict[str, list[str]] = {}
    for node in PreOrderIter(root, filter_=lambda n: isinstance(n.data, VSSDataBranch) and n.data.is_instance):
        if any(c.data.is_instance for c in node.children if isinstance(c.data, VSSDataBranch)):
            continue
        instance_root, _ = node.get_instance_root()
        instance_root_fqn = instance_root.get_fqn()

        instance_name = node.get_fqn().removeprefix(instance_root_fqn + ""."")

        if instance_root_fqn in meta:
            meta[instance_root_fqn].append(instance_name)
        else:
            meta[instance_root_fqn] = [instance_name]
    return meta","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    for branch in root.branches:
        if branch.is_terminal:
            instances[branch.fqn] = [branch.name]
        else:
            instances.update(get_instances_meta(branch))
    return instances","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    for branch in root.branches:
        if branch.is_terminal:
            if branch.fqn not in instances:
                instances[branch.fqn] = []
            instances[branch.fqn].append(branch.name)
        else:
            instances.update(get_instances_meta(branch))
    return instances",19.649491637208687,7.063531334219627,12.56188067555812,34.48275862068966,24.489795918367346
22,python,"def is_VSS_leaf(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataDatatype):
        return True
    return False","def is_VSS_leaf(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataDatatype)","def is_VSS_leaf(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataDatatype)",53.95251422009305,34.1077254951379,31.7023313852343,50.0,100.0
23,python,"def is_VSS_branch(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataBranch):
        if not node.data.is_instance:
            return True
    return False","def is_VSS_branch(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataBranch) and not node.is_instance","def is_VSS_branch(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataBranch) and not node.is_instance",38.92121923202306,27.429553970075617,26.150059800121895,42.10526315789473,60.0
24,python,"def is_VSS_branch_instance(node: VSSNode) -> bool:
    if isinstance(node.data, VSSDataBranch):
        if node.data.is_instance:
            return True
    return False","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataBranch) and node.data.is_instance","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataBranch) and node.data.is_instance",51.30668508661355,28.641904579795412,26.584835766658777,50.0,100.0
25,python,"def fnv1_32_hash(identifier: bytes) -> int:
    id_hash = 2166136261
    for byte in identifier:
        id_hash = (id_hash * 16777619) & 0xFFFFFFFF
        id_hash ^= byte

    return id_hash","def fnv1_32_hash(identifier: bytes) -> int:
    fnv_prime = 0x01000193
    hash = 0x811c9dc5
    for byte in identifier:
        hash = (hash * fnv_prime) ^ byte
    return hash","def fnv1_32_hash(identifier: bytes) -> int:
    fnv_prime = 0x01000193
    hash = 0x811c9dc5
    for byte in identifier:
        hash ^= byte
        hash *= fnv_prime
    return hash",31.417028049627127,28.489318277723964,30.33668865762665,36.84210526315789,30.0
28,java,"public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
    mRootView = inflater.inflate(R.layout.card_fragment, container, false);
    mCardTitle = mRootView.findViewById(R.id.card_name);
    mCardIcon = mRootView.findViewById(R.id.card_icon);
    return mRootView;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View card_fragment = inflater.inflate(R.layout.card_fragment, container, false);
        TextView card_title = (TextView) card_fragment.findViewById(R.id.card_title);
        ImageView card_icon = (ImageView) card_fragment.findViewById(R.id.card_icon);
        card_title.setText(getArguments().getString(""title""));
        card_icon.setImageResource(getArguments().getInt(""icon""));
        return card_fragment;
    }","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View card_fragment = inflater.inflate(R.layout.card_fragment, container, false);
        TextView card_title = (TextView) card_fragment.findViewById(R.id.card_title);
        ImageView card_icon = (ImageView) card_fragment.findViewById(R.id.card_icon);
        card_title.setText(getArguments().getString(""title""));
        card_icon.setImageResource(getArguments().getInt(""icon""));
        return card_fragment;
    }",56.39231100609467,36.58350203979106,49.591802590648214,66.66666666666666,72.72727272727273
29,java,"private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent,
        ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageDrawable(buttonContent.getIcon());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
        if (buttonContent != null) {
            buttonView.setImageDrawable(buttonContent.getImage());
            buttonView.setOnClickListener(buttonContent.getOnClickListener());
            buttonView.setVisibility(View.VISIBLE);
        } else {
            buttonView.setVisibility(View.GONE);
        }
    }","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
        if (buttonContent != null) {
            buttonView.setImageDrawable(buttonContent.getImage());
            buttonView.setOnClickListener(buttonContent.getOnClickListener());
            buttonView.setVisibility(View.VISIBLE);
        } else {
            buttonView.setVisibility(View.GONE);
        }
    }",93.39618950293001,86.56030552541708,87.02445248630298,100.0,100.0
30,java,"protected final View getDescriptiveTextOnlyLayoutView() {
    if (mDescriptiveTextOnlyLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.descriptive_text_layout);
        mDescriptiveTextOnlyLayoutView = stub.inflate();
        mDescriptiveTextOnlyTitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.primary_text);
        mDescriptiveTextOnlySubtitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.secondary_text);
        mDescriptiveTextOnlyOptionalImage = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.optional_image);
        mDescriptiveTextOnlyTapForMore = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.tap_for_more_text);
    }
    return mDescriptiveTextOnlyLayoutView;
}","protected final View getDescriptiveTextOnlyLayoutView() {
    ViewStub viewStub = (ViewStub) findViewById(R.layout.descriptive_text_only_stub);
    View inflatedView = viewStub.inflate();
    TextView title = (TextView) findViewById(R.id.title);
    TextView subtitle = (TextView) findViewById(R.id.subtitle);
    ImageView image = (ImageView) findViewById(R.id.image);
    return inflatedView;
}","protected final View getDescriptiveTextOnlyLayoutView() {
    ViewStub viewStub = (ViewStub) findViewById(R.layout.descriptive_text_only_stub);
    View inflatedView = viewStub.inflate();
    TextView title = (TextView) findViewById(R.id.title);
    TextView subtitle = (TextView) findViewById(R.id.subtitle);
    ImageView image = (ImageView) findViewById(R.id.image);
    return inflatedView;
}",26.675248078421433,12.47096061785423,13.481368594227208,45.45454545454545,35.294117647058826
31,java,"public void updateHeaderView(CardHeader header) {
    requireActivity().runOnUiThread(() -> {
        mRootView.setVisibility(View.VISIBLE);
        mCardTitle.setText(header.getCardTitle());
        mCardIcon.setImageDrawable(header.getCardIcon());
    });
}","public void updateHeaderView(CardHeader header) {
        Runnable runnable = () -> {
            headerView.getRootView().setVisibility(View.VISIBLE);
            headerView.setTitle(header.getTitle());
            headerView.setIcon(header.getIcon());
        };
        runOnUiThread(runnable);
    }","public void updateHeaderView(CardHeader header) {
        Runnable runnable = () -> {
            headerView.getRootView().setVisibility(View.VISIBLE);
            headerView.setTitle(header.getTitle());
            headerView.setIcon(header.getIcon());
        };
        runOnUiThread(runnable);
    }",55.61237843236996,25.45984531673679,36.27538269845734,60.71428571428571,100.0
32,java,"private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.text_block_layout);
        mTextBlockLayoutView = stub.inflate();
        mTextBlock = mTextBlockLayoutView.findViewById(R.id.text_block);
        mTextBlockTapForMore = mTextBlockLayoutView.findViewById(R.id.tap_for_more_text);
    }
    return mTextBlockLayoutView;
}","```java
private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = LayoutInflater.from(getContext()).inflate(R.layout.text_block_layout, this, false);
        mTextView = (TextView) mTextBlockLayoutView.findViewById(R.id.text_block_text);
        mTextView.setText(getText());
        mTextView.setOnClickListener(this);
        mTextView.setOnLongClickListener(this);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative","```java
private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = LayoutInflater.from(getContext()).inflate(R.layout.text_block_layout, this, false);
        mTextView = (TextView) mTextBlockLayoutView.findViewById(R.id.text_block_text);
        mTextView.setText(getText());
        mTextView.setOnClickListener(this);
        mTextView.setOnLongClickListener(this);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesWithIntrinsicBounds(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawables(null, null, mArrowDrawable, null);
        mTextView.setCompoundDrawablesRelative",33.93649310895864,5.640506321065055,34.650920660224074,50.0,45.45454545454545
33,java,"static ComponentName getMediaSource(@NonNull PackageManager packageManager,
        @NonNull String packageName) {
    Intent mediaIntent = new Intent();
    mediaIntent.setPackage(packageName);
    mediaIntent.setAction(MediaBrowserService.SERVICE_INTERFACE);

    List<ResolveInfo> mediaServices = packageManager.queryIntentServices(mediaIntent,
            PackageManager.GET_RESOLVED_FILTER);

    if (mediaServices == null || mediaServices.isEmpty()) {
        return null;
    }
    String defaultService = mediaServices.get(0).serviceInfo.name;
    if (!TextUtils.isEmpty(defaultService)) {
        return new ComponentName(packageName, defaultService);
    }
    return null;
}","import android.content.ComponentName;
import android.content.pm.PackageManager;

import org.jetbrains.annotations.NotNull;

public class MediaBrowserServiceHelper {

    @NotNull
    static ComponentName getMediaSource(@NotNull PackageManager packageManager, @NotNull String packageName) {
        ComponentName componentName = null;
        for (int i = 0; i < packageManager.getServices().size(); i++) {
            android.content.pm.ServiceInfo serviceInfo = packageManager.getServicesForPackage(packageName).get(i);
            if (serviceInfo.serviceName.contains(""MediaBrowserService"")) {
                componentName = new ComponentName(packageName, serviceInfo.serviceName);
                break;
            }
        }
        return componentName;
    }
}","import android.content.ComponentName;
import android.content.pm.PackageManager;

import org.jetbrains.annotations.NotNull;

public class MediaBrowserServiceHelper {

    @NotNull
    static ComponentName getMediaSource(@NotNull PackageManager packageManager, @NotNull String packageName) {
        for (android.content.pm.ServiceInfo service : packageManager.getServicesForPackage(packageName)) {
            if (service.serviceName.contains(""MediaBrowserService"")) {
                return new ComponentName(packageName, service.serviceName);
            }
        }
        return null;
    }
}",23.926043087930314,3.756878591608448,4.4136010377408414,33.9622641509434,53.57142857142857
34,java,"private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    switch (componentAppType) {
        case APP_TYPE_MEDIA_SERVICES:
            if (customMediaComponents.contains(componentName.flattenToString())
                    && (appTypesToShow & APP_TYPE_LAUNCHABLES) != 0) {
                return false;
            }
            return true;
        case APP_TYPE_LAUNCHABLES:
            return true;
        default:
            Log.e(TAG, ""Invalid componentAppType : "" + componentAppType);
            return false;
    }
}","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
        if (appsToHide.contains(componentName.getPackageName())) {
            return false;
        }
        if ((appTypesToShow & AppTypes.LAUNCHABLE) != 0 &&
                (componentAppType & AppTypes.MEDIA_SERVICE) != 0 &&
                customMediaComponents.contains(componentName.getClassName())) {
            return false;
        }
        return true;
    }","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
        if (appsToHide.contains(componentName.getPackageName())) {
            return false;
        }
        if ((appTypesToShow & AppTypes.LAUNCHABLE) != 0 &&
                (componentAppType & AppTypes.MEDIA_SERVICE) != 0 &&
                customMediaComponents.contains(componentName.getClassName())) {
            return false;
        }
        return true;
    }",61.86418183533259,48.03984716340054,50.21053097158059,63.49206349206349,85.71428571428571
35,java,"private static void selectMediaSourceAndFinish(Context context, ComponentName componentName,
        CarMediaManager carMediaManager) {
    try {
        carMediaManager.setMediaSource(componentName, CarMediaManager.MEDIA_SOURCE_MODE_BROWSE);
        if (context instanceof Activity) {
            ((Activity) context).finish();
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected"", e);
    }
}","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
        carMediaManager.setMediaSource(componentName);
        if (context instanceof Activity) {
            try {
                ((Activity) context).finish();
            } catch (CarNotConnectedException e) {
                Log.e(""CarMediaManager"", ""Car service unavailable"", e);
            }
        }
    }","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
        carMediaManager.setMediaSource(componentName);
        if (context instanceof Activity) {
            try {
                ((Activity) context).finish();
            } catch (CarNotConnectedException e) {
                Log.e(""CarMediaManager"", ""Car service unavailable"", e);
            }
        }
    }",68.83066265444376,61.305689871011005,62.40405752095758,51.61290322580645,100.0
36,java,"static boolean isActivityDistractionOptimized(
        CarPackageManager carPackageManager, String packageName, String activityName) {
    boolean isDistractionOptimized = false;
    try {
        if (carPackageManager != null) {
            isDistractionOptimized =
                    carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected when getting DO info"", e);
    }
    return isDistractionOptimized;
}","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
        if (carPackageManager == null) {
            Log.e(TAG, ""CarPackageManager is null"");
            return false;
        }
        try {
            return carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        } catch (CarNotConnectedException e) {
            Log.e(TAG, ""Car not connected: "" + e.getMessage());
            return false;
        }
    }","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
        if (carPackageManager == null) {
            Log.e(TAG, ""CarPackageManager is null"");
            return false;
        }
        try {
            return carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        } catch (CarNotConnectedException e) {
            Log.e(TAG, ""Car not connected: "" + e.getMessage());
            return false;
        }
    }",51.89617845061385,36.17884355539638,37.16941704508861,41.37931034482759,92.85714285714286
38,java,"private Intent getMapsIntent() {
    Intent defaultIntent =
            Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MAPS);
    PackageManager pm = getPackageManager();
    ComponentName defaultActivity = defaultIntent.resolveActivity(pm);

    for (String intentUri : getResources().getStringArray(
            R.array.config_homeCardPreferredMapActivities)) {
        Intent preferredIntent;
        try {
            preferredIntent = Intent.parseUri(intentUri, Intent.URI_ANDROID_APP_SCHEME);
        } catch (URISyntaxException se) {
            Log.w(TAG, ""Invalid intent URI in config_homeCardPreferredMapActivities"", se);
            continue;
        }

        if (defaultActivity != null && !defaultActivity.getPackageName().equals(
                preferredIntent.getPackage())) {
            continue;
        }

        if (preferredIntent.resolveActivityInfo(pm, /* flags= */ 0) != null) {
            return preferredIntent;
        }
    }
    return defaultIntent;
}","private Intent getMapsIntent() {
        Intent mapsIntent = null;
        if (mapsIntent == null) {
            mapsIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=current location""));
            ResolveInfo resolveInfo = packageManager.resolveActivity(mapsIntent, PackageManager.MATCH_DEFAULT_ONLY);
            if (resolveInfo != null) {
                String packageName = resolveInfo.serviceInfo.packageName;
                if (packageName.equals(""com.google.android.apps.maps"")) {
                    mapsIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=current location""));
                    mapsIntent.setPackage(packageName);
                }
            }
        }
        return mapsIntent;
    }","private Intent getMapsIntent() {
        Intent mapsIntent = null;
        if (mapsIntent == null) {
            mapsIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=current location""));
            ResolveInfo resolveInfo = packageManager.resolveActivity(mapsIntent, PackageManager.MATCH_DEFAULT_ONLY);
            if (resolveInfo != null) {
                String packageName = resolveInfo.serviceInfo.packageName;
                if (packageName.equals(""com.google.android.apps.maps"")) {
                    mapsIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=current location""));
                    mapsIntent.setPackage(packageName);
                }
            }
        }
        return mapsIntent;
    }",15.533000249773805,8.431436174232239,9.544720669018822,22.727272727272727,21.428571428571427
39,java,"private void initializeCards() {
    if (mHomeCardModules == null) {
        mHomeCardModules = new ArraySet<>();
        for (String providerClassName : getResources().getStringArray(
                R.array.config_homeCardModuleClasses)) {
            try {
                long reflectionStartTime = System.currentTimeMillis();
                HomeCardModule cardModule = (HomeCardModule) Class.forName(
                        providerClassName).newInstance();
                cardModule.setViewModelProvider(new ViewModelProvider( /* owner= */this));
                mHomeCardModules.add(cardModule);
                if (DEBUG) {
                    long reflectionTime = System.currentTimeMillis() - reflectionStartTime;
                    Log.d(TAG, ""Initialization of HomeCardModule class "" + providerClassName
                            + "" took "" + reflectionTime + "" ms"");
                }
            } catch (IllegalAccessException | InstantiationException |
                    ClassNotFoundException e) {
                Log.w(TAG, ""Unable to create HomeCardProvider class "" + providerClassName, e);
            }
        }
    }
    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    for (HomeCardModule cardModule : mHomeCardModules) {
        transaction.replace(cardModule.getCardResId(), cardModule.getCardView());
    }
    transaction.commitNow();
}","private void initializeCards() {
        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
        for (String className : homeCardModuleNames) {
            try {
                Class<?> clazz = Class.forName(className);
                HomeCardModule module = (HomeCardModule) clazz.getDeclaredConstructor().newInstance();
                transaction.add(R.id.home_card_container, module, className);
            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
                Log.e(TAG, ""Failed to instantiate module: "" + className, e);
            }
        }
        transaction.commit();
    }","private void initializeCards() {
        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
        for (String className : homeCardModuleNames) {
            try {
                Class<?> clazz = Class.forName(className);
                HomeCardModule module = (HomeCardModule) clazz.getDeclaredConstructor().newInstance();
                transaction.add(R.id.home_card_container, module, className);
            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
                Log.e(TAG, ""Failed to instantiate module: "" + className, e);
            }
        }
        transaction.commit();
    }",23.585051052040086,8.492940950132228,10.990120400885264,42.857142857142854,32.0
40,java,"private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
    ActivityTaskManager atm = ActivityTaskManager.getInstance();
    for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
        TaskInfo taskInfo = taskAppearedInfo.getTaskInfo();
        if (taskInfo.getWindowingMode() == WINDOWING_MODE_MULTI_WINDOW) {
            if (DBG) Slog.d(TAG, ""Found the dangling task, removing: "" + taskInfo.taskId);
            atm.removeTask(taskInfo.taskId);
        }
    }
}","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
        for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
            if (taskAppearedInfo.isMultiWindow()) {
                ActivityTaskManager.get().removeTask(taskAppearedInfo.taskId);
                Log.w(TAG, ""Removing dangling task: "" + taskAppearedInfo.taskId);
            }
        }
    }","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
        for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
            if (taskAppearedInfo.isMultiWindow()) {
                ActivityTaskManager.get().removeTask(taskAppearedInfo.taskId);
                Log.w(TAG, ""Removing dangling task: "" + taskAppearedInfo.taskId);
            }
        }
    }",38.78592753297235,26.443806118509777,30.46758078105638,52.77777777777778,45.45454545454545
41,java,"private void updateMode() {
    mMode = parseMode(getIntent());
    setTitle(mMode.mTitleStringId);
    CarUi.requireToolbar(this).setTitle(mMode.mTitleStringId);
}","private void updateMode() {
        Intent intent = getIntent();
        if (intent != null) {
            String mode = intent.getStringExtra(Intent.EXTRA_MODE);
            if (mode != null) {
                int stringResourceId = getResources().getIdentifier(mode, ""string"", getPackageName());
                if (stringResourceId != 0) {
                    setTitle(stringResourceId);
                    ((Toolbar) findViewById(R.id.toolbar)).setTitle(stringResourceId);
                }
            }
        }
    }","private void updateMode() {
        Intent intent = getIntent();
        if (intent != null) {
            String mode = intent.getStringExtra(Intent.EXTRA_MODE);
            if (mode != null) {
                int stringResourceId = getResources().getIdentifier(mode, ""string"", getPackageName());
                if (stringResourceId != 0) {
                    setTitle(stringResourceId);
                    if (findViewById(R.id.toolbar) instanceof Toolbar) {
                        ((Toolbar) findViewById(R.id.toolbar)).setTitle(stringResourceId);
                    }
                }
            }
        }
    }",27.20343238765327,6.364996151971675,31.02016197006999,38.095238095238095,33.33333333333333
42,java,"private Chronometer getChronometer() {
    if (mChronometer == null) {
        mChronometer = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer);
        mChronometerSeparator = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer_separator);
    }
    return mChronometer;
}","private Chronometer getChronometer() {
    Chronometer chronometer = findViewById(R.id.chronometer);
    View separator = findViewById(R.id.separator);
    chronometer.setSeparatorView(separator);
    return chronometer;
}","private Chronometer getChronometer() {
    Chronometer chronometer = findViewById(R.id.chronometer);
    View separator = findViewById(R.id.separator);
    chronometer.setSeparatorView(separator);
    return chronometer;
}",32.88185198179086,13.320564393651892,14.360689687357706,34.61538461538461,69.23076923076923
43,java,"private View getMediaLayoutView() {
    if (mMediaLayoutView == null) {
        ViewStub stub = getRootView().findViewById(R.id.media_layout);
        mMediaLayoutView = stub.inflate();
        mMediaTitle = mMediaLayoutView.findViewById(R.id.primary_text);
        mMediaSubtitle = mMediaLayoutView.findViewById(R.id.secondary_text);
        View mediaControlBarView = mMediaLayoutView.findViewById(
                R.id.media_playback_controls_bar);
        mPresenter.initializeControlsActionBar(mediaControlBarView);
    }
    return mMediaLayoutView;
}","private View getMediaLayoutView() {
    ViewStub stub = (ViewStub) findViewById(R.id.media_layout_stub);
    View inflatedView = stub.inflate();
    TextView titleView = (TextView) inflatedView.findViewById(R.id.media_layout_title);
    TextView subtitleView = (TextView) inflatedView.findViewById(R.id.media_layout_subtitle);
    MediaPlaybackControlsBarPresenter presenter = new MediaPlaybackControlsBarPresenter(this, titleView, subtitleView);
    MediaPlaybackControlsBar controlsBar = (MediaPlaybackControlsBar) inflatedView.findViewById(R.id.media_layout_controls_bar);
    controlsBar.setPresenter(presenter);
    return inflatedView;
}","private View getMediaLayoutView() {
    ViewStub stub = (ViewStub) findViewById(R.id.media_layout_stub);
    View inflatedView = stub.inflate();
    TextView titleView = (TextView) inflatedView.findViewById(R.id.media_layout_title);
    TextView subtitleView = (TextView) inflatedView.findViewById(R.id.media_layout_subtitle);
    MediaPlaybackControlsBarPresenter presenter = new MediaPlaybackControlsBarPresenter(this, titleView, subtitleView);
    MediaPlaybackControlsBar controlsBar = (MediaPlaybackControlsBar) inflatedView.findViewById(R.id.media_layout_controls_bar);
    controlsBar.setPresenter(presenter);
    return inflatedView;
}",38.46113533771034,14.362555317755927,18.150791165402993,55.81395348837209,65.51724137931035
44,java,"private void updateBackgroundImage(Drawable image) {
    if (image != null && getCardSize() != null) {
        int maxDimen = Math.max(getCardSize().getWidth(), getCardSize().getHeight());
        Size scaledSize = new Size(maxDimen, maxDimen);
        Bitmap imageBitmap = BitmapUtils.fromDrawable(image, scaledSize);
        Bitmap blurredBackground = ImageUtils.blur(getContext(), imageBitmap, scaledSize,
                mBlurRadius);

        getCardBackgroundImage().setImageBitmap(blurredBackground, /* showAnimation= */ true);
        getCardBackground().setVisibility(View.VISIBLE);
    }
}","private void updateBackgroundImage(Drawable image) {
        if (image == null || cardWidth == 0 || cardHeight == 0) {
            return;
        }

        int largestDimension = Math.max(cardWidth, cardHeight);
        Bitmap scaledBitmap = Bitmap.createScaledBitmap(image.getBitmap(), largestDimension, largestDimension, true);
        Bitmap blurredBitmap = Bitmap.createBitmap(scaledBitmap.getWidth(), scaledBitmap.getHeight(), Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(blurredBitmap);
        Paint paint = new Paint();
        paint.setFilterBitmap(true);
        paint.setXfermode(new BlurMaskFilter(8f, BlurMaskFilter.Blur.NORMAL));
        canvas.drawBitmap(scaledBitmap, 0, 0, paint);

        cardBackground.setImageBitmap(blurredBitmap);
    }","private void updateBackgroundImage(Drawable image) {
        if (image == null || cardWidth == 0 || cardHeight == 0) {
            return;
        }

        int largestDimension = Math.max(cardWidth, cardHeight);
        Bitmap scaledBitmap = Bitmap.createScaledBitmap(image.getBitmap(), largestDimension, largestDimension, true);
        Bitmap blurredBitmap = Bitmap.createBitmap(scaledBitmap.getWidth(), scaledBitmap.getHeight(), Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(blurredBitmap);
        Paint paint = new Paint();
        paint.setFilterBitmap(true);
        paint.setXfermode(new BlurMaskFilter(8f, BlurMaskFilter.Blur.NORMAL));
        canvas.drawBitmap(scaledBitmap, 0, 0, paint);

        cardBackground.setImageBitmap(blurredBitmap);
    }",30.298519096454402,12.877338632854633,18.14579758202279,34.61538461538461,55.55555555555556
45,java,"private void updateMediaView(CharSequence title, CharSequence subtitle) {
    getMediaLayoutView().setVisibility(View.VISIBLE);
    mMediaTitle.setText(title);
    mMediaSubtitle.setText(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
}",60.50395237711008,59.75579891089116,61.207379018601806,21.052631578947366,0.0
46,java,"private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        getChronometer().setVisibility(View.VISIBLE);
        getChronometer().setBase(content.getStartTime());
        getChronometer().start();
        mChronometerSeparator.setVisibility(View.VISIBLE);
    } else {
        getChronometer().setVisibility(View.GONE);
        mChronometerSeparator.setVisibility(View.GONE);
    }
}","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
        if (content.getStartTime() > 0) {
            chronometer.setBase(content.getStartTime());
            chronometer.start();
            separator.setVisibility(View.VISIBLE);
            chronometer.setVisibility(View.VISIBLE);
        } else {
            chronometer.stop();
            chronometer.setVisibility(View.GONE);
            separator.setVisibility(View.GONE);
        }
    }","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
        if (content.getStartTime() > 0) {
            chronometer.setBase(content.getStartTime());
            chronometer.start();
            separator.setVisibility(View.VISIBLE);
            chronometer.setVisibility(View.VISIBLE);
        } else {
            chronometer.stop();
            chronometer.setVisibility(View.GONE);
            separator.setVisibility(View.GONE);
        }
    }",66.3943967566714,50.41350242010638,55.164084606579166,60.0,100.0
47,java,"public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(mCallback);
    }
}","public void onCallAdded(Call call) {
    if (call != null) {
        call.addCallback(this);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string",55.23641871663434,2.598015697208048,79.88612070779082,38.46153846153847,100.0
48,java,"public void onCallRemoved(Call call) {
    mCurrentCall = null;
    mCardContent = null;
    mPresenter.onModelUpdated(this);
    if (call != null) {
        call.unregisterCallback(mCallback);
    }
}","public void onCallRemoved(Call call) {
        call.clear();
        card.clear();
        presenter.onModelUpdated();
        call.unregisterCallback(this);
    }
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferProcess.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferProcess</title>
</head>
<body>
    <h1>TransferProcess</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferProcessState.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferProcessState</title>
</head>
<body>
    <h1>TransferProcessState</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferProcessType.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferProcessType</title>
</head>
<body>
    <h1>TransferProcessType</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferRequest.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferRequest</title>
</head>
<body>
    <h1>TransferRequest</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferRequestState.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferRequestState</title>
</head>
<body>
    <h1>TransferRequestState</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferRequestStatus.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferRequestStatus</title>
</head>
<body>
    <h1>TransferRequestStatus</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferRequestType.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferRequestType</title>
</head>
<body>
    <h1>TransferRequestType</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferResponse.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferResponse</title>
</head>
<body>
    <h1>TransferResponse</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferResponseType.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferResponseType</title>
</head>
<body>
    <h1>TransferResponseType</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferState.html
<!DOCTYPE html","public void onCallRemoved(Call call) {
        call.clear();
        presenter.onModelUpdated();
        call.unregisterCallback(this);
    }
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferProcess.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferProcess</title>
</head>
<body>
    <h1>TransferProcess</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferProcessState.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferProcessState</title>
</head>
<body>
    <h1>TransferProcessState</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferProcessType.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferProcessType</title>
</head>
<body>
    <h1>TransferProcessType</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferRequest.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferRequest</title>
</head>
<body>
    <h1>TransferRequest</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferRequestState.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferRequestState</title>
</head>
<body>
    <h1>TransferRequestState</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferRequestStatus.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferRequestStatus</title>
</head>
<body>
    <h1>TransferRequestStatus</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferRequestType.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferRequestType</title>
</head>
<body>
    <h1>TransferRequestType</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferResponse.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferResponse</title>
</head>
<body>
    <h1>TransferResponse</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferResponseType.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>TransferResponseType</title>
</head>
<body>
    <h1>TransferResponseType</h1>
</body>
</html>
docs/api/java/org/eclipse/edc/connector/transfer/spi/types/TransferState.html
<!DOCTYPE html>
<html lang=""en"">
<head>
    <",27.569265145922607,2.5194299192695415,20.61477352156375,30.0,57.14285714285714
49,java,"void updateModelWithPhoneNumber(String number) {
    String formattedNumber = TelecomUtils.getFormattedNumber(mContext, number);
    mCardContent = new DescriptiveTextWithControlsView(null, formattedNumber,
            mOngoingCallSubtitle, mElapsedTimeClock.millis(), mMuteButton, mEndCallButton,
            mDialpadButton);
    mPresenter.onModelUpdated(this);
}","void updateModelWithPhoneNumber(String number) {
        DescriptiveTextWithControlsView view = new DescriptiveTextWithControlsView(number);
        presenter.onModelUpdated(view);
    }","void updateModelWithPhoneNumber(String number) {
        DescriptiveTextWithControlsView view = new DescriptiveTextWithControlsView(number);
        presenter.onModelUpdated(view);
    }",14.306789336892923,11.682950752097785,15.6830954843628,11.11111111111111,18.75
50,java,"private void initializeAudioControls() {
    mMuteButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_mic_off),
            v -> {
                mInCallService.setMuted(mMuteCallToggle);
                mMuteCallToggle = !mMuteCallToggle;
            });
    mEndCallButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_call_end_button),
            v -> mCurrentCall.disconnect());
    mDialpadButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_dialpad), this::onClick);
}","private void initializeAudioControls() {
        muteButton.setIcon(muteIcon);
        muteButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                toggleMute();
            }
        });

        endCallButton.setIcon(endCallIcon);
        endCallButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                endCall();
            }
        });

        dialpadButton.setIcon(dialpadIcon);
        dialpadButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                dialpadHandler.onClick(view);
            }
        });
    }","private void initializeAudioControls() {
        muteButton.setIcon(muteIcon);
        muteButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                toggleMute();
            }
        });

        endCallButton.setIcon(endCallIcon);
        endCallButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                endCall();
            }
        });

        dialpadButton.setIcon(dialpadIcon);
        dialpadButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                dialpadHandler.onClick(view);
            }
        });
    }",19.14334584104017,5.992026878339571,8.950340443040359,20.454545454545457,41.17647058823529
53,cpp,"void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    (void)_subscription;
    if (dbusConnection_->isConnected())
        _listener(AvailabilityStatus::AVAILABLE);
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (isConnectionActive()) {
        _listener.onAvailable();
    }
}

#include <iostream>
#include <thread>
#include <chrono>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include <map>
#include <vector>
#include <algorithm>

#include <gtest/gtest.h>

#include <DBusConnectionStatusEvent.hpp>

class MockListener {
public:
    MockListener() : availableCalled(false), unavailableCalled(false), errorCalled(false) {}

    void onAvailable() {
        availableCalled = true;
    }

    void onUnavailable() {
        unavailableCalled = true;
    }

    void onError(const std::string &_error) {
        errorCalled = true;
    }

    bool availableCalled;
    bool unavailableCalled;
    bool errorCalled;
};

class MockSubscription {
public:
    MockSubscription() {}
};

class MockConnection {
public:
    MockConnection() : active(false) {}

    bool isConnectionActive() const {
        return active;
    }

    void setConnectionActive(bool _active) {
        active = _active;
    }

private:
    bool active;
};

TEST(DBusConnectionStatusEventTest, onListenerAdded_connectionActive) {
    MockConnection connection;
    connection.setConnectionActive(true);
    MockListener listener;
    MockSubscription subscription;
    DBusConnectionStatusEvent event(connection);

    event.onListenerAdded(listener, subscription);

    EXPECT_TRUE(listener.availableCalled);
    EXPECT_FALSE(listener.unavailableCalled);
    EXPECT_FALSE(listener.errorCalled);
}

TEST(DBusConnectionStatusEventTest, onListenerAdded_connectionInactive) {
    MockConnection connection;
    connection.setConnectionActive(false);
    MockListener listener;
    MockSubscription subscription;
    DBusConnectionStatusEvent event(connection);

    event.onListenerAdded(listener, subscription);

    EXPECT_FALSE(listener.availableCalled);
    EXPECT_FALSE(listener.unavailableCalled);
    EXPECT_FALSE(listener.errorCalled);
}

#include <iostream>
#include <thread>
#include <chrono>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include <map>
#include <vector>
#include <algorithm>

#include <gtest/gtest.h>

#include <DBusConnectionStatusEvent.hpp>

class MockListener {
public:
    MockListener() : availableCalled(false), unavailableCalled(false), errorCalled(false) {}

    void onAvailable() {
        availableCalled = true;
    }

    void onUnavailable() {
        unavailableCalled = true;
    }

    void onError(const std::string &_error) {
        errorCalled = true;
    }

    bool availableCalled;
    bool unavailableCalled;
    bool errorCalled;
};

class MockSubscription {
public:
    MockSubscription() {}
};

class MockConnection {
public:
    MockConnection() : active(false) {}

    bool isConnectionActive() const {
        return active;
    }

    void setConnectionActive(bool _active) {
        active = _active;
    }

private:
    bool active;
};

TEST","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (isConnectionActive()) {
        _listener.onAvailable();
    }
}",54.03653143665436,2.803124212513931,61.16908849062524,52.17391304347826,100.0
54,cpp,"void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (connections_.end() != connections_.find(conn)) {
        bool found(false);
        std::vector<std::thread*>::const_iterator it = threads_.begin();
        while (!found && it != threads_.end()) {
            found = (&t == *it++);
        }
        if (!found) {
            threads_.push_back(&t);
        }
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lk(exit_mutex_);
    if (conn_to_thread_.count(conn) && conn_to_thread_[conn] == &t) {
        conn_to_thread_[conn] = nullptr;
        conn_to_thread_.erase(conn);
    }
    if (conn_to_thread_.count(conn) == 0) {
        conn_to_thread_[conn] = &t;
    }
}
src/main.cpp

#include <iostream>
#include <thread>
#include <mutex>
#include <unordered_map>
#include <atomic>
#include <vector>
#include <chrono>
#include <cassert>

namespace {
    std::mutex exit_mutex_;
    std::unordered_map<std::uintptr_t, std::thread*> conn_to_thread_;
    std::atomic_bool exit_flag{false};

    void joinOnExit(std::uintptr_t conn, std::thread & t) {
        std::lock_guard<std::mutex> lk(exit_mutex_);
        if (conn_to_thread_.count(conn) && conn_to_thread_[conn] == &t) {
            conn_to_thread_[conn] = nullptr;
            conn_to_thread_.erase(conn);
        }
        if (conn_to_thread_.count(conn) == 0) {
            conn_to_thread_[conn] = &t;
        }
    }

    void worker(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker2(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(2));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker3(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(3));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker4(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(4));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker5(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(5));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker6(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(6));
        std::cout << ""Thread ","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lk(exit_mutex_);
    if (conn_to_thread_.count(conn) && conn_to_thread_[conn] == &t) {
        conn_to_thread_[conn] = nullptr;
        conn_to_thread_.erase(conn);
    }
    if (conn_to_thread_.count(conn) == 0) {
        conn_to_thread_[conn] = &t;
    }
}
src/main.cpp

#include <iostream>
#include <thread>
#include <mutex>
#include <unordered_map>
#include <atomic>
#include <vector>
#include <chrono>
#include <cassert>

namespace {
    std::mutex exit_mutex_;
    std::unordered_map<std::uintptr_t, std::thread*> conn_to_thread_;
    std::atomic_bool exit_flag{false};

    void joinOnExit(std::uintptr_t conn, std::thread & t) {
        std::lock_guard<std::mutex> lk(exit_mutex_);
        if (conn_to_thread_.count(conn) && conn_to_thread_[conn] == &t) {
            conn_to_thread_[conn] = nullptr;
            conn_to_thread_.erase(conn);
        }
        if (conn_to_thread_.count(conn) == 0) {
            conn_to_thread_[conn] = &t;
        }
    }

    void worker(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker2(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(2));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker3(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(3));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker4(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(4));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker5(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(5));
        std::cout << ""Thread "" << conn << "" exiting"" << std::endl;
        joinOnExit(conn, std::this_thread::get_id());
    }

    void worker6(std::uintptr_t conn) {
        std::this_thread::sleep_for(std::chrono::seconds(6));
        std::cout << ""Thread "" <<",38.85077773634975,4.701467972662805,23.42116556438153,44.927536231884055,82.35294117647058
56,cpp,"void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (NULL == static_cast<WatchContext*>(data)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data (WatchContext) == NULL"");
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));
    if (dbusWatch != NULL) {
        if(dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
        }
        dbus_watch_set_data(libdbusWatch, NULL, NULL);
    }
}","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch) {
        libdbusWatch->unmonitor();
        libdbusWatch->release();
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names)","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch) {
        libdbusWatch->unmonitor();
        libdbusWatch->release();
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names)",38.226535489309654,2.0057806139348706,20.900361343303732,30.0,100.0
57,cpp,"void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    WatchContext* watchContext = static_cast<WatchContext*>(data);

    if (NULL == watchContext) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""watchContext == NULL"");
        return;
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));

    if (dbusWatch == NULL) {
        DBusWatch* dbusWatch = new DBusWatch(libdbusWatch, watchContext->mainLoopContext_, watchContext->dbusConnection_);
        dbusWatch->addDependentDispatchSource(watchContext->dispatchSource_);
        dbus_watch_set_data(libdbusWatch, dbusWatch, NULL);

        if (dbusWatch->isReadyToBeWatched()) {
            dbusWatch->startWatching();
        }
    } else {
        if (!dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
            dbus_watch_set_data(libdbusWatch, NULL, NULL);
        } else {
            dbusWatch->startWatching();
        }
    }
}","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    auto it = watchWrappers_.find(libdbusWatch);
    if (it != watchWrappers_.end()) {
        if (it->second->isReady()) {
            it->second->startWatching();
        } else {
            it->second->stopWatching();
        }
    } else {
        auto wrapper = std::make_unique<DBusWatchWrapper>(libdbusWatch, data);
        watchWrappers_[libdbusWatch] = std::move(wrapper);
        if (wrapper->isReady()) {
            wrapper->startWatching();
        } else {
            wrapper->stopWatching();
        }
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""cherry""
    auto it = std::find(words.begin(), words.end(), ""cherry"");
    if (it != words.end()) {
        std::cout << ""Index of 'cherry': "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""'cherry' not found in the vector."" << std::endl;
    }

    // Remove ""banana"" from the vector
    words.erase(std::remove(words.begin(), words.end(), ""banana""), words.end());

    // Print the updated vector
    std::cout << ""Vector after removing 'banana': "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""cherry""
    auto it = std::find(words.begin(), words.end(), ""cherry"");
    if (it != words.end()) {
        std::cout << ""Index of 'cherry': "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""'cherry' not found in the vector."" << std::endl;
    }

    // Remove ""banana"" from the vector
    words.erase(std::remove(words.begin(), words.end(), ""banana""), words.end());

    // Print the updated vector
    std::cout << ""Vector after removing 'banana': "";
    for (const auto& word : words)","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    auto it = watchWrappers_.find(libdbusWatch);
    if (it != watchWrappers_.end()) {
        if (it->second->isReady()) {
            it->second->startWatching();
        } else {
            it->second->stopWatching();
        }
    } else {
        auto wrapper = std::make_unique<DBusWatchWrapper>(libdbusWatch, data);
        watchWrappers_[libdbusWatch] = std::move(wrapper);
        if (wrapper->isReady()) {
            wrapper->startWatching();
        } else {
            wrapper->stopWatching();
        }
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""cherry""
    auto it = std::find(words.begin(), words.end(), ""cherry"");
    if (it != words.end()) {
        std::cout << ""Index of 'cherry': "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""'cherry' not found in the vector."" << std::endl;
    }

    // Remove ""banana"" from the vector
    words.erase(std::remove(words.begin(), words.end(), ""banana""), words.end());

    // Print the updated vector
    std::cout << ""Vector after removing 'banana': "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""cherry""
    auto it = std::find(words.begin(), words.end(), ""cherry"");
    if (it != words.end()) {
        std::cout << ""Index of 'cherry': "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""'cherry' not found in the vector."" << std::endl;
    }

    // Remove ""banana"" from the vector
    words.erase(std::remove(words.begin(), words.end(), ""banana""), words.end());

    // Print the updated vector
    std::cout << ""Vector after removing 'banana': "";
    for (const auto& word : words)",33.55196280223271,3.4117599831099286,18.130978560708247,43.43434343434344,69.23076923076923
58,cpp,"const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> itsLock(objectManagerGuard_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return dbusObjectManager_;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> lock(dbusObjectManagerMutex_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(*dbus_);
        }
    }
    return dbusObjectManager_;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> lock(dbusObjectManagerMutex_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(*dbus_);
        }
    }
    return dbusObjectManager_;
}",77.26381842267129,70.76534431960262,71.62326270441588,66.66666666666666,100.0
59,cpp,"bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    DBusError dbusError;
    bool isServiceNameReleased = false;
    std::lock_guard<std::recursive_mutex> dbusConnectionLock(connectionGuard_);
    auto conIter = connectionNameCount_.find(serviceName);
    if (conIter != connectionNameCount_.end()) {
        if (conIter->second == 1) {
            const int libdbusStatus = dbus_bus_release_name(connection_,
                            serviceName.c_str(),
                            &dbusError.libdbusError_);
            isServiceNameReleased = (libdbusStatus == DBUS_RELEASE_NAME_REPLY_RELEASED);
            if (isServiceNameReleased) {
                connectionNameCount_.erase(conIter);
            }
        } else {
            conIter->second--;
            isServiceNameReleased = true;
        }
    }
    return isServiceNameReleased;
}","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    std::lock_guard<std::mutex> itsLock(serviceNamesMutex_);
    auto it = serviceNames_.find(serviceName);
    if (it == serviceNames_.end()) {
        return false;
    }
    it->second--;
    if (it->second == 0) {
        serviceNames_.erase(it);
        dbus_connection_unref(connection_);
        connection_ = nullptr;
    }
    return true;
}","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    std::lock_guard<std::mutex> itsLock(serviceNamesMutex_);
    auto it = serviceNames_.find(serviceName);
    if (it == serviceNames_.end()) {
        return false;
    }
    it->second--;
    if (it->second == 0) {
        serviceNames_.erase(it);
        if (connection_) {
            dbus_connection_unref(connection_);
            connection_ = nullptr;
        }
    }
    return true;
}",29.75001518412843,10.323734388670491,12.247754919271813,61.42857142857143,35.0
60,cpp,"DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (NULL == _libdbusPendingCall) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""_libdbusPendingCall == NULL"");
        return DBusMessage();
    }

    ::DBusMessage* libdbusMessage = dbus_pending_call_steal_reply(_libdbusPendingCall);
    const bool increaseLibdbusMessageReferenceCount = false;
    DBusMessage dbusMessage(libdbusMessage, increaseLibdbusMessageReferenceCount);

    return dbusMessage;
}","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (_libdbusPendingCall == nullptr) {
        return DBusMessage();
    }
    DBusMessage message;
    DBusMessage* dbusMessage = dbus_pending_call_get_reply(_libdbusPendingCall);
    if (dbusMessage) {
        message.setDBusMessage(dbusMessage);
        dbus_message_unref(dbusMessage);
    }
    return message;
}","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (_libdbusPendingCall == nullptr) {
        return DBusMessage();
    }
    DBusMessage message;
    DBusMessage* dbusMessage = dbus_pending_call_get_reply(_libdbusPendingCall);
    if (dbusMessage) {
        message.setDBusMessage(dbusMessage);
        dbus_message_unref(dbusMessage);
    }
    return message;
}",41.13097303344446,17.233770467788045,17.802942178810294,46.15384615384615,83.33333333333334
61,cpp,"void DBusConnection::deleteAsyncHandlers() {
    std::vector<DBusMessageReplyAsyncHandler*> asyncHandlers;
    {
        std::lock_guard<std::mutex> asyncHandlersLock(asyncHandlersToDeleteMutex_);
        asyncHandlers = asyncHandlersToDelete_;
        asyncHandlersToDelete_.clear();
    }

    auto it = asyncHandlers.begin();
    while(it != asyncHandlers.end()) {
        delete *it;
        it = asyncHandlers.erase(it);
    }
}","void DBusConnection::deleteAsyncHandlers() {
    std::lock_guard<std::mutex> lock(mutex_);
    std::vector<DBusAsyncHandler*> handlers;
    {
        std::lock_guard<std::mutex> local_lock(mutex_);
        handlers.swap(async_handlers_);
    }
    for (DBusAsyncHandler* handler : handlers) {
        delete handler;
    }
}
docs/cpp/dbus-cpp/dbus-cpp-api-reference.md
# DBus-CPP API Reference

## Overview

The DBus-CPP library provides a set of C++ classes and functions that allow you to easily create and use DBus applications. The library is designed to be easy to use and to provide a high level of abstraction over the underlying DBus API.

## Classes

### `DBusConnection`

The `DBusConnection` class is the main class in the DBus-CPP library. It provides a connection to a DBus session or system bus.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication, const std::string& proxy_address)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication, const std::string& proxy_address, const std::string& proxy_user)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication, const std::string& proxy_address, const std::string& proxy_user, const std::string& proxy_password)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication, const std::string& proxy_address, const std::string& proxy_user, const std::string&","void DBusConnection::deleteAsyncHandlers() {
    std::lock_guard<std::mutex> lock(mutex_);
    std::vector<DBusAsyncHandler*> handlers;
    {
        std::lock_guard<std::mutex> local_lock(mutex_);
        handlers.swap(async_handlers_);
    }
    for (DBusAsyncHandler* handler : handlers) {
        delete handler;
    }
}
docs/cpp/dbus-cpp/dbus-cpp-api-reference.md
# DBus-CPP API Reference

## Overview

The DBus-CPP library provides a set of C++ classes and functions that allow you to easily create and use DBus applications. The library is designed to be easy to use and to provide a high level of abstraction over the underlying DBus API.

## Classes

### `DBusConnection`

The `DBusConnection` class is the main class in the DBus-CPP library. It provides a connection to a DBus session or system bus.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication, const std::string& proxy_address)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication, const std::string& proxy_address, const std::string& proxy_user)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication, const std::string& proxy_address, const std::string& proxy_user, const std::string& proxy_password)`

Constructor.

#### `DBusConnection(const std::string& address, const std::string& path, const std::string& service, const std::string& name, const std::string& bus_type, const std::string& user, const std::string& password, const std::string& authentication, const std::string& proxy_address, const std::string& proxy_user, const std::string&",28.444191525843355,0.4800508549376985,5.983790078367692,48.97959183673469,58.333333333333336
62,cpp,"void DBusConnection::handleSignalStates() {
    std::map<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>, std::set<uint32_t>> tmpHandlers;
    {
        std::lock_guard<std::mutex> itsLock(signalStateHandlersMutex_);
        tmpHandlers = signalStateHandlers_;
    }
    for (auto itsHandler : tmpHandlers) {
        for (uint32_t tag : itsHandler.second) {
            itsHandler.first->onSpecificError(CommonAPI::CallStatus::SUCCESS, tag);
        }
    }
}","void DBusConnection::handleSignalStates() {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    for (auto& signal : itsSignals) {
        if (signal.second.status == SUCCESS) {
            for (auto& handler : signal.second.handlers) {
                handler.onSpecificError(signal.first);
            }
        }
    }
}","void DBusConnection::handleSignalStates() {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    for (auto& signal : itsSignals) {
        if (signal.second.status == SUCCESS) {
            for (auto& handler : signal.second.handlers) {
                handler.onSpecificError(signal.first);
            }
        }
    }
}",21.940740127807747,7.235042610347482,7.701830944361772,47.82608695652174,25.0
63,cpp,"void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::recursive_mutex> itsConnectionGuard(connectionsMutex_);
    auto itsConnection = connections_.find(_connectionId);

    if (itsConnection != connections_.end()) {
        connections_.erase(_connectionId);
    }
}","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t& _connectionId);

private:
    std::mutex mutex_;
    std::vector<ConnectionId_t> connections_;
};

void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t& _connectionId);

private:
    std::mutex mutex_;
    std::vector<ConnectionId_t> connections_;
};

void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t& _connectionId);

private:
    std::mutex mutex_;
    std::vector<ConnectionId_t> connections_;
};

void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t& _connectionId);

private:
    std::mutex mutex_;
    std::vector<ConnectionId_t> connections_;
};

void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t&","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t& _connectionId);

private:
    std::mutex mutex_;
    std::vector<ConnectionId_t> connections_;
};

void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t& _connectionId);

private:
    std::mutex mutex_;
    std::vector<ConnectionId_t> connections_;
};

void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t& _connectionId);

private:
    std::mutex mutex_;
    std::vector<ConnectionId_t> connections_;
};

void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t& _connectionId);

private:
    std::mutex mutex_;
    std::vector<ConnectionId_t> connections_;
};

void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Factory {
public:
    Factory() = default;
    ~Factory() = default;

    void releaseConnection(const ConnectionId_t&",58.72485610075909,2.5192214427046813,35.237345817474555,97.14285714285714,100.0
64,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.hasMemberName(""InterfacesAdded"")) {
        instanceAvblStatusEvent_->onInterfacesAddedSignal(dbusMessage);
    } else if (dbusMessage.hasMemberName(""InterfacesRemoved"")) {
        instanceAvblStatusEvent_->onInterfacesRemovedSignal(dbusMessage);
   }
}","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.getMember() == ""InterfacesAdded"") {
        onInterfacesAdded(dbusMessage);
    } else if (dbusMessage.getMember() == ""InterfacesRemoved"") {
        onInterfacesRemoved(dbusMessage);
    }
}
docs/cpp/dbus/DBusInstanceAvailabilityStatusChangedEvent.md
# DBusInstanceAvailabilityStatusChangedEvent

## Overview

The `DBusInstanceAvailabilityStatusChangedEvent` class is a C++ class that provides a mechanism for receiving and handling D-Bus signals related to the availability status of DBus instances. It allows applications to be notified when DBus instances are added or removed from the system.

## Class Definition

```cpp
class DBusInstanceAvailabilityStatusChangedEvent {
public:
    class SignalHandler {
    public:
        virtual void onInterfacesAdded(const DBusMessage& dbusMessage) = 0;
        virtual void onInterfacesRemoved(const DBusMessage& dbusMessage) = 0;
    };

    DBusInstanceAvailabilityStatusChangedEvent(SignalHandler* handler);
    ~DBusInstanceAvailabilityStatusChangedEvent();

    void connect();
    void disconnect();

private:
    SignalHandler* m_handler;
    DBusConnection* m_connection;
    DBusObjectPath* m_objectPath;
    DBusInterfaceName* m_interfaceName;
    DBusMethodName* m_methodName;
    DBusMessage* m_message;
};
```

## Member Variables

*   `m_handler`: A pointer to the `SignalHandler` object that will receive the D-Bus signals.
*   `m_connection`: A pointer to the `DBusConnection` object that will be used to connect to the D-Bus system.
*   `m_objectPath`: A pointer to the `DBusObjectPath` object that represents the object path of the DBus instance.
*   `m_interfaceName`: A pointer to the `DBusInterfaceName` object that represents the interface name of the DBus instance.
*   `m_methodName`: A pointer to the `DBusMethodName` object that represents the method name of the DBus instance.
*   `m_message`: A pointer to the `DBusMessage` object that will contain the D-Bus signal.

## Methods

*   `DBusInstanceAvailabilityStatusChangedEvent(SignalHandler* handler)`: The constructor of the class. It takes a pointer to a `SignalHandler` object as an argument.
*   `~DBusInstanceAvailabilityStatusChangedEvent()`: The destructor of the class.
*   `connect()`: Connects to the D-Bus system and registers the `SignalHandler` object to receive the D-Bus signals.
*   `disconnect()`: Disconnects from the D-Bus system and unregisters the `SignalHandler` object from receiving the D-Bus signals.
*   `onSignalDBusMessage(const DBusMessage& dbusMessage)`: Handles an incoming D-Bus signal by dispatching it to the appropriate handler for either ""InterfacesAdded"" or ""InterfacesRemoved"" events based on the message's member name.
 *   `onInterfacesAdded(const DBusMessage& dbusMessage)`: Handles the ""InterfacesAdded"" D-Bus signal.
 *   `onInterfacesRemoved(const DBusMessage& dbusMessage)`: Handles the ""InterfacesRemoved"" D-Bus signal.

## Usage

The `DBusInstanceAvailabilityStatusChangedEvent` class can be used to receive","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.getMember() == ""InterfacesAdded"") {
        onInterfacesAdded(dbusMessage);
    } else if (dbusMessage.getMember() == ""InterfacesRemoved"") {
        onInterfacesRemoved(dbusMessage);
    }
}
docs/cpp/dbus/DBusConnection.md
# DBusConnection

## Overview

The `DBusConnection` class provides a C++ interface for connecting to a D-Bus system and sending and receiving messages. It provides a high-level API for interacting with D-Bus, making it easier to develop D-Bus applications.

## Class Definition

```cpp
class DBusConnection {
public:
    DBusConnection(const std::string& address, const std::string& path);
    virtual ~DBusConnection();

    bool connect();
    bool disconnect();

    bool sendMessage(const DBusMessage& message, DBusError& error);
    bool receiveMessage(DBusMessage& message, DBusError& error);

    bool isConnected();

private:
    DBusConnectionImpl* m_impl;
};
```

## Member Variables

*   `m_impl`: A pointer to the `DBusConnectionImpl` object that implements the actual D-Bus connection.

## Methods

*   `DBusConnection(const std::string& address, const std::string& path)`: The constructor of the class. It takes the address and path of the D-Bus system as arguments.
*   `~DBusConnection()`: The destructor of the class.
*   `connect()`: Connects to the D-Bus system.
*   `disconnect()`: Disconnects from the D-Bus system.
*   `sendMessage(const DBusMessage& message, DBusError& error)`: Sends a D-Bus message to the D-Bus system.
*   `receiveMessage(DBusMessage& message, DBusError& error)`: Receives a D-Bus message from the D-Bus system.
*   `isConnected()`: Returns true if the connection is currently connected to the D-Bus system.
docs/cpp/dbus/DBusConnectionImpl.md
# DBusConnectionImpl

## Overview

The `DBusConnectionImpl` class is an implementation of the `DBusConnection` class. It provides the actual D-Bus connection functionality.

## Class Definition

```cpp
class DBusConnectionImpl {
public:
    DBusConnectionImpl(const std::string& address, const std::string& path);
    virtual ~DBusConnectionImpl();

    bool connect();
    bool disconnect();

    bool sendMessage(const DBusMessage& message, DBusError& error);
    bool receiveMessage(DBusMessage& message, DBusError& error);

    bool isConnected();

private:
    DBusConnection* m_connection;
};
```

## Member Variables

*   `m_connection`: A pointer to the `DBusConnection` object that provides the high-level API for interacting with D-Bus.

## Methods

*   `DBusConnectionImpl(const std::string& address, const std::string& path)`: The constructor of the class. It takes the address and path of the D-Bus system as arguments.
*   `~DBusConnectionImpl()`: The destructor of the class.
*   `connect()`: Connects to the D-Bus system.
*   `disconnect()`: Disconnects from the D-Bus system.
*",36.64444598709235,1.8901312181162675,42.09025013285051,45.45454545454545,57.14285714285714
65,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(
        CommonAPI::CallStatus &_status,
        std::vector<DBusAddress> &_availableServiceInstances) {

    _availableServiceInstances.clear();
    DBusObjectManagerStub::DBusObjectPathAndInterfacesDict itsAvailableServiceInstances;
    registry_->getAvailableServiceInstances(proxy_.getDBusAddress().getService(),
            proxy_.getDBusAddress().getObjectPath(),
            itsAvailableServiceInstances);

    _status = CommonAPI::CallStatus::SUCCESS;
    translate(itsAvailableServiceInstances, _availableServiceInstances);
}","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    std::shared_ptr<DBus> dbus = std::make_shared<DBus>();
    dbus->init();
    std::vector<std::string> serviceNames;
    dbus->getAvailableServiceInstances(serviceNames);
    _availableServiceInstances.clear();
    for (const auto &serviceName : serviceNames) {
        _availableServiceInstances.push_back(DBusAddress(serviceName));
    }
    _status = CommonAPI::CallStatus::SUCCESS;
}
docs/cpp/DBusInstanceAvailabilityStatusChangedEvent.md
# DBusInstanceAvailabilityStatusChangedEvent

## Description

The `DBusInstanceAvailabilityStatusChangedEvent` class is a C++ class that provides a mechanism for receiving notifications when the availability status of DBus service instances changes. It is part of the CommonAPI library and is used to monitor the availability of DBus services.

## Class Members

### `DBusInstanceAvailabilityStatusChangedEvent` Constructor

The constructor of the `DBusInstanceAvailabilityStatusChangedEvent` class takes a `DBusAddress` object as input, which represents the DBus address of the service instance whose availability status has changed.

```cpp
DBusInstanceAvailabilityStatusChangedEvent(const DBusAddress &_dbusAddress);
```

### `getAvailableServiceInstances` Method

The `getAvailableServiceInstances` method retrieves the available service instances from the DBus registry and translates the internal D-Bus representation into a vector of `DBusAddress` objects. It populates the provided output vector and status parameter.

```cpp
void getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances);
```

## Example

```cpp
#include <iostream>
#include <vector>
#include <CommonAPI/DBusAddress.hpp>
#include <CommonAPI/CallStatus.hpp>
#include <CommonAPI/DBusInstanceAvailabilityStatusChangedEvent.hpp>

int main() {
    DBusInstanceAvailabilityStatusChangedEvent event(""org.example.MyService"");
    std::vector<DBusAddress> availableServiceInstances;
    CommonAPI::CallStatus status;
    event.getAvailableServiceInstances(status, availableServiceInstances);

    if (status == CommonAPI::CallStatus::SUCCESS) {
        std::cout << ""Available service instances:"" << std::endl;
        for (const auto &dbusAddress : availableServiceInstances) {
            std::cout << dbusAddress << std::endl;
        }
    } else {
        std::cout << ""Failed to get available service instances."" << std::endl;
    }

    return 0;
}
```
docs/cpp/DBusAddress.md
# DBusAddress

## Description

The `DBusAddress` class is a C++ class that represents a DBus address. It is part of the CommonAPI library and is used to identify DBus services and objects.

## Class Members

### `DBusAddress` Constructor

The constructor of the `DBusAddress` class takes a string as input, which represents the DBus address.

```cpp
DBusAddress(const std::string &_dbusAddress);
```

### `operator[]` Method

The `operator[]` method returns the character at the specified index in the DBus address string.

```cpp
char operator[](size_t index) const;
```

### `operator<<` Method

The `operator<<` method is used","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    std::shared_ptr<DBus> dbus = std::make_shared<DBus>();
    dbus->init();
    std::vector<std::string> serviceNames;
    dbus->getAvailableServiceInstances(serviceNames);
    _availableServiceInstances.clear();
    for (const auto &serviceName : serviceNames) {
        _availableServiceInstances.push_back(DBusAddress(serviceName));
    }
    _status = CommonAPI::CallStatus::SUCCESS;
}
docs/cpp/DBusAddress.md
# DBusAddress

## Description

The `DBusAddress` class is a C++ class that represents a DBus address. It is part of the CommonAPI library and is used to identify DBus services and objects.

## Class Members

### `DBusAddress` Constructor

The constructor of the `DBusAddress` class takes a string as input, which represents the DBus address.

```cpp
DBusAddress(const std::string &_dbusAddress);
```

### `operator[]` Method

The `operator[]` method returns the character at the specified index in the DBus address string.

```cpp
char operator[](size_t index) const;
```

### `operator<<` Method

The `operator<<` method is used
docs/cpp/DBusAddress.md
# DBusAddress

## Description

The `DBusAddress` class is a C++ class that represents a DBus address. It is part of the CommonAPI library and is used to identify DBus services and objects.

## Class Members

### `DBusAddress` Constructor

The constructor of the `DBusAddress` class takes a string as input, which represents the DBus address.

```cpp
DBusAddress(const std::string &_dbusAddress);
```

### `operator[]` Method

The `operator[]` method returns the character at the specified index in the DBus address string.

```cpp
char operator[](size_t index) const;
```

### `operator<<` Method

The `operator<<` method is used
docs/cpp/DBusAddress.md
# DBusAddress

## Description

The `DBusAddress` class is a C++ class that represents a DBus address. It is part of the CommonAPI library and is used to identify DBus services and objects.

## Class Members

### `DBusAddress` Constructor

The constructor of the `DBusAddress` class takes a string as input, which represents the DBus address.

```cpp
DBusAddress(const std::string &_dbusAddress);
```

### `operator[]` Method

The `operator[]` method returns the character at the specified index in the DBus address string.

```cpp
char operator[](size_t index) const;
```

### `operator<<` Method

The `operator<<` method is used
docs/cpp/DBusAddress.md
# DBusAddress

## Description

The `DBusAddress` class is a C++ class that represents a DBus address. It is part of the CommonAPI library and is used to identify DBus services and objects.

## Class Members

### `DBusAddress` Constructor

The constructor of the `DBusAddress` class takes a string as input, which represents the DBus address.

```cpp
DBusAddress(const std::string &_dbusAddress);
```

### `operator[]` Method

The `operator[]` method returns the character at",46.97026281041345,1.1542827274530911,21.14235292978515,72.72727272727273,92.85714285714286
66,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(
        const std::string &_instance,
        CallStatus &_callStatus,
        AvailabilityStatus &_availabilityStatus) {

    CommonAPI::Address itsAddress(""local"", observedCapiInterfaceName_, _instance);
    DBusAddress itsDBusAddress;
    DBusAddressTranslator::get()->translate(itsAddress, itsDBusAddress);

    _availabilityStatus = AvailabilityStatus::NOT_AVAILABLE;
    if (registry_->isServiceInstanceAlive(
            itsDBusAddress.getInterface(),
            itsDBusAddress.getService(),
            itsDBusAddress.getObjectPath())) {
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
    }
    _callStatus = CallStatus::SUCCESS;
}","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    std::shared_ptr<DBusConnection> connection = std::make_shared<DBusConnection>();
    if (!connection->connect()) {
        _callStatus = CallStatus::CONNECTION_ERROR;
        return;
    }

    std::string dbusAddress = _instance;
    dbusAddress += "".service"";

    std::shared_ptr<DBusObjectProxy> proxy = connection->createProxy(dbusAddress, ""org.freedesktop.DBus"");
    if (!proxy) {
        _callStatus = CallStatus::PROXY_ERROR;
        return;
    }

    std::shared_ptr<DBusMethodCall> call = proxy->createMethodCall(""GetAvailabilityStatus"");
    if (!call) {
        _callStatus = CallStatus::METHOD_ERROR;
        return;
    }

    call->set_reply_handler(
        [this, _availabilityStatus](DBusReply<AvailabilityStatus> &_reply) {
            if (_reply.get_success()) {
                _availabilityStatus = _reply.get_value();
            } else {
                _availabilityStatus = AvailabilityStatus::UNKNOWN;
            }
        });

    call->set_error_handler(
        [this, _callStatus](DBusError &_error) {
            _callStatus = CallStatus::DBUS_ERROR;
        });

    if (!call->call()) {
        _callStatus = CallStatus::CALL_ERROR;
        return;
    }

    _callStatus = CallStatus::SUCCESS;
}
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    std::sort(words.begin(), words.end());

    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    std::sort(words.begin(), words.end());

    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    std::sort(words.begin(), words.end());

    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    std::shared_ptr<DBusConnection> connection = std::make_shared<DBusConnection>();
    if (!connection->connect()) {
        _callStatus = CallStatus::CONNECTION_ERROR;
        return;
    }

    std::string dbusAddress = _instance;
    dbusAddress += "".service"";

    std::shared_ptr<DBusObjectProxy> proxy = connection->createProxy(dbusAddress, ""org.freedesktop.DBus"");
    if (!proxy) {
        _callStatus = CallStatus::PROXY_ERROR;
        return;
    }

    std::shared_ptr<DBusMethodCall> call = proxy->createMethodCall(""GetAvailabilityStatus"");
    if (!call) {
        _callStatus = CallStatus::METHOD_ERROR;
        return;
    }

    call->set_reply_handler(
        [this, _availabilityStatus](DBusReply<AvailabilityStatus> &_reply) {
            if (_reply.get_success()) {
                _availabilityStatus = _reply.get_value();
            } else {
                _availabilityStatus = AvailabilityStatus::UNKNOWN;
            }
        });

    call->set_error_handler(
        [this, _callStatus](DBusError &_error) {
            _callStatus = CallStatus::DBUS_ERROR;
        });

    if (!call->call()) {
        _callStatus = CallStatus::CALL_ERROR;
        return;
    }

    _callStatus = CallStatus::SUCCESS;
}
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    std::sort(words.begin(), words.end());

    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    std::sort(words.begin(), words.end());

    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    std::sort(words.begin(), words.end());

    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std",40.28330177700576,4.3953995099062055,32.55480106216913,68.62745098039215,55.55555555555556
67,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    DBusInputStream dbusInputStream(_message);
    std::string dbusObjectPath;
    std::vector<std::string> dbusInterfaceNames;

    dbusInputStream >> dbusObjectPath;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read object path"");
    }

    dbusInputStream >> dbusInterfaceNames;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read interface names"");
    }

    for (const auto& dbusInterfaceName : dbusInterfaceNames) {
        if(auto itsProxy = proxyWeakPtr_.lock() &&
                dbusInterfaceName == observedDbusInterfaceName_ &&
                removeInterface(dbusObjectPath, dbusInterfaceName)) {
            (void)itsProxy;
            notifyInterfaceStatusChanged(dbusObjectPath, dbusInterfaceName, AvailabilityStatus::NOT_AVAILABLE);
        }
    }
}","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    std::string_view interfaceName = _message.getInterface();
    std::string_view memberName = _message.getMember();
    if (interfaceName == ""org.freedesktop.DBus.Introspectable"" && memberName == ""InterfacesRemoved"") {
        DBusMessage reply = _message.createMethodReturn();
        DBusVariant variant;
        DBusVariant::List list;
        DBusVariant::Dictionary dict;
        DBusVariant::Array array;
        DBusVariant::StringInterfaceName interfaceName;
        DBusVariant::StringInterfaceName interfaceName2;
        DBusVariant::StringInterfaceName interfaceName3;
        DBusVariant::StringInterfaceName interfaceName4;
        DBusVariant::StringInterfaceName interfaceName5;
        DBusVariant::StringInterfaceName interfaceName6;
        DBusVariant::StringInterfaceName interfaceName7;
        DBusVariant::StringInterfaceName interfaceName8;
        DBusVariant::StringInterfaceName interfaceName9;
        DBusVariant::StringInterfaceName interfaceName10;
        DBusVariant::StringInterfaceName interfaceName11;
        DBusVariant::StringInterfaceName interfaceName12;
        DBusVariant::StringInterfaceName interfaceName13;
        DBusVariant::StringInterfaceName interfaceName14;
        DBusVariant::StringInterfaceName interfaceName15;
        DBusVariant::StringInterfaceName interfaceName16;
        DBusVariant::StringInterfaceName interfaceName17;
        DBusVariant::StringInterfaceName interfaceName18;
        DBusVariant::StringInterfaceName interfaceName19;
        DBusVariant::StringInterfaceName interfaceName20;
        DBusVariant::StringInterfaceName interfaceName21;
        DBusVariant::StringInterfaceName interfaceName22;
        DBusVariant::StringInterfaceName interfaceName23;
        DBusVariant::StringInterfaceName interfaceName24;
        DBusVariant::StringInterfaceName interfaceName25;
        DBusVariant::StringInterfaceName interfaceName26;
        DBusVariant::StringInterfaceName interfaceName27;
        DBusVariant::StringInterfaceName interfaceName28;
        DBusVariant::StringInterfaceName interfaceName29;
        DBusVariant::StringInterfaceName interfaceName30;
        DBusVariant::StringInterfaceName interfaceName31;
        DBusVariant::StringInterfaceName interfaceName32;
        DBusVariant::StringInterfaceName interfaceName33;
        DBusVariant::StringInterfaceName interfaceName34;
        DBusVariant::StringInterfaceName interfaceName35;
        DBusVariant::StringInterfaceName interfaceName36;
        DBusVariant::StringInterfaceName interfaceName37;
        DBusVariant::StringInterfaceName interfaceName38;
        DBusVariant::StringInterfaceName interfaceName39;
        DBusVariant::StringInterfaceName interfaceName40;
        DBusVariant::StringInterfaceName interfaceName41;
        DBusVariant::StringInterfaceName interfaceName42;
        DBusVariant::StringInterfaceName interfaceName43;
        DBusVariant::StringInterfaceName interfaceName44;
        DBusVariant::StringInterfaceName interfaceName45;
        DBusVariant::StringInterfaceName interfaceName46;
        DBusVariant::StringInterfaceName interfaceName47;
        DBusVariant::StringInterfaceName interfaceName48;
        DBusVariant","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    std::string_view interfaceName = _message.getInterface();
    std::string_view memberName = _message.getMember();
    if (interfaceName == ""org.freedesktop.DBus.Introspectable"" && memberName == ""InterfacesRemoved"") {
        DBusMessage reply = _message.createMethodReturn();
        DBusVariant variant;
        DBusVariant::List list;
        DBusVariant::Dictionary dict;
        DBusVariant::Array array;
        DBusVariant::StringInterfaceName interfaceName;
        DBusVariant::StringInterfaceName interfaceName2;
        DBusVariant::StringInterfaceName interfaceName3;
        DBusVariant::StringInterfaceName interfaceName4;
        DBusVariant::StringInterfaceName interfaceName5;
        DBusVariant::StringInterfaceName interfaceName6;
        DBusVariant::StringInterfaceName interfaceName7;
        DBusVariant::StringInterfaceName interfaceName8;
        DBusVariant::StringInterfaceName interfaceName9;
        DBusVariant::StringInterfaceName interfaceName10;
        DBusVariant::StringInterfaceName interfaceName11;
        DBusVariant::StringInterfaceName interfaceName12;
        DBusVariant::StringInterfaceName interfaceName13;
        DBusVariant::StringInterfaceName interfaceName14;
        DBusVariant::StringInterfaceName interfaceName15;
        DBusVariant::StringInterfaceName interfaceName16;
        DBusVariant::StringInterfaceName interfaceName17;
        DBusVariant::StringInterfaceName interfaceName18;
        DBusVariant::StringInterfaceName interfaceName19;
        DBusVariant::StringInterfaceName interfaceName20;
        DBusVariant::StringInterfaceName interfaceName21;
        DBusVariant::StringInterfaceName interfaceName22;
        DBusVariant::StringInterfaceName interfaceName23;
        DBusVariant::StringInterfaceName interfaceName24;
        DBusVariant::StringInterfaceName interfaceName25;
        DBusVariant::StringInterfaceName interfaceName26;
        DBusVariant::StringInterfaceName interfaceName27;
        DBusVariant::StringInterfaceName interfaceName28;
        DBusVariant::StringInterfaceName interfaceName29;
        DBusVariant::StringInterfaceName interfaceName30;
        DBusVariant::StringInterfaceName interfaceName31;
        DBusVariant::StringInterfaceName interfaceName32;
        DBusVariant::StringInterfaceName interfaceName33;
        DBusVariant::StringInterfaceName interfaceName34;
        DBusVariant::StringInterfaceName interfaceName35;
        DBusVariant::StringInterfaceName interfaceName36;
        DBusVariant::StringInterfaceName interfaceName37;
        DBusVariant::StringInterfaceName interfaceName38;
        DBusVariant::StringInterfaceName interfaceName39;
        DBusVariant::StringInterfaceName interfaceName40;
        DBusVariant::StringInterfaceName interfaceName41;
        DBusVariant::StringInterfaceName interfaceName42;
        DBusVariant::StringInterfaceName interfaceName43;
        DBusVariant::StringInterfaceName interfaceName44;
        DBusVariant::StringInterfaceName interfaceName45;
        DBusVariant::StringInterfaceName interfaceName46;
        DBusVariant::StringInterfaceName interfaceName47;
        DBusVariant::StringInterfaceName interfaceName48;
        DBusVariant",17.15307276979583,3.0394795689522294,6.598452535872109,32.05128205128205,26.923076923076923
68,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(
        const std::string &_objectPath,
        const std::string &_interfaceName,
        const AvailabilityStatus &_availability) {
    CommonAPI::Address itsAddress;
    DBusAddress itsDBusAddress(proxy_.getDBusAddress().getService(),
                               _objectPath,
                               _interfaceName);

    DBusAddressTranslator::get()->translate(itsDBusAddress, itsAddress);

    notifyListeners(itsAddress.getAddress(), _availability);
}","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    std::shared_ptr<DBusInstanceAvailabilityStatusChangedEvent> itsEvent = std::make_shared<DBusInstanceAvailabilityStatusChangedEvent>();
    itsEvent->setAvailabilityStatus(_availability);
    itsEvent->setObjectPath(_objectPath);
    itsEvent->setInterfaceName(_interfaceName);
    itsEvent->setCommonAPIAddress(CommonAPI::DBus::getDBusAddress(_objectPath, _interfaceName));
    itsEvent->setEventTime(std::chrono::system_clock::now());
    itsEvent->setEventId(itsEventId++);
    itsEvent->setEventVersion(DBusInstanceAvailabilityStatusChangedEvent::VERSION);
    itsEvent->setEventName(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_NAME);
    itsEvent->setEventInterface(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_INTERFACE);
    itsEvent->setEventMethod(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_METHOD);
    itsEvent->setEventType(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_TYPE);
    itsEvent->setEventDomain(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_DOMAIN);
    itsEvent->setEventVersion(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_VERSION);
    itsEvent->setEventPriority(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_PRIORITY);
    itsEvent->setEventTimestamp(std::chrono::system_clock::now().time_since_epoch().count());
    itsEvent->setEventPayload(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_PAYLOAD);
    itsEvent->setEventSource(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_SOURCE);
    itsEvent->setEventStatus(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_STATUS);
    itsEvent->setEventCorrelationId(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_CORRELATION_ID);
    itsEvent->setEventReplyTo(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_REPLY_TO);
    itsEvent->setEventError(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_ERROR);
    itsEvent->setEventArguments(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_ARGUMENTS);
    itsEvent->setEventReturnValue(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_RETURN_VALUE);
    itsEvent->setEventSignature(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_SIGNATURE);
    itsEvent->setEventData(DBusInstance","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    std::shared_ptr<DBusInstanceAvailabilityStatusChangedEvent> itsEvent = std::make_shared<DBusInstanceAvailabilityStatusChangedEvent>();
    itsEvent->setAvailabilityStatus(_availability);
    itsEvent->setObjectPath(_objectPath);
    itsEvent->setInterfaceName(_interfaceName);
    itsEvent->setCommonAPIAddress(CommonAPI::DBus::getDBusAddress(_objectPath, _interfaceName));
    itsEvent->setEventTime(std::chrono::system_clock::now());
    itsEvent->setEventId(itsEventId++);
    itsEvent->setEventVersion(DBusInstanceAvailabilityStatusChangedEvent::VERSION);
    itsEvent->setEventName(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_NAME);
    itsEvent->setEventInterface(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_INTERFACE);
    itsEvent->setEventMethod(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_METHOD);
    itsEvent->setEventType(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_TYPE);
    itsEvent->setEventDomain(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_DOMAIN);
    itsEvent->setEventVersion(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_VERSION);
    itsEvent->setEventPriority(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_PRIORITY);
    itsEvent->setEventTimestamp(std::chrono::system_clock::now().time_since_epoch().count());
    itsEvent->setEventPayload(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_PAYLOAD);
    itsEvent->setEventSource(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_SOURCE);
    itsEvent->setEventStatus(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_STATUS);
    itsEvent->setEventCorrelationId(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_CORRELATION_ID);
    itsEvent->setEventReplyTo(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_REPLY_TO);
    itsEvent->setEventError(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_ERROR);
    itsEvent->setEventArguments(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_ARGUMENTS);
    itsEvent->setEventReturnValue(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_RETURN_VALUE);
    itsEvent->setEventSignature(DBusInstanceAvailabilityStatusChangedEvent::DBUS_INSTANCE_AVAILABILITY_STATUS_CHANGED_EVENT_SIGNATURE);
    itsEvent->setEventData(DBusInstanceAvailability",53.07370951050887,18.35246569050701,37.844811375918695,56.09756097560976,100.0
69,cpp,"void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener,
                                           const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);

   std::weak_ptr<DBusProxy> itsdbusProxy = dbusProxy_->shared_from_this();
    dbusProxy_->getDBusConnection()->proxyPushFunctionToMainLoop<DBusConnection>(
            DBusProxy::notifySpecificListener,
            itsdbusProxy,
            _listener,
            _subscription);
}","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(_listener);
    itsSubscriptions.push_back(_subscription);
}

#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <condition_variable>

class DBusProxyStatusEvent {
public:
    struct Listener {
        std::string interface;
        std::string path;
        std::string member;
    };

    struct Subscription {
        std::string interface;
        std::string path;
        std::string member;
        std::string signal;
    };

    void onListenerAdded(const Listener &_listener, const Subscription _subscription);

private:
    std::vector<Listener> itsListeners;
    std::vector<Subscription> itsSubscriptions;
    std::mutex itsMutex;
    std::condition_variable itsCondition;
};

void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(_listener);
    itsSubscriptions.push_back(_subscription);
}

#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <condition_variable>

class DBusProxyStatusEvent {
public:
    struct Listener {
        std::string interface;
        std::string path;
        std::string member;
    };

    struct Subscription {
        std::string interface;
        std::string path;
        std::string member;
        std::string signal;
    };

    void onListenerAdded(const Listener &_listener, const Subscription _subscription);

private:
    std::vector<Listener> itsListeners;
    std::vector<Subscription> itsSubscriptions;
    std::mutex itsMutex;
    std::condition_variable itsCondition;
};

void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(_listener);
    itsSubscriptions.push_back(_subscription);
}

#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <condition_variable>

class DBusProxyStatusEvent {
public:
    struct Listener {
        std::string interface;
        std::string path;
        std::string member;
    };

    struct Subscription {
        std::string interface;
        std::string path;
        std::string member;
        std::string signal;
    };

    void onListenerAdded(const Listener &_listener, const Subscription _subscription);

private:
    std::vector<Listener> itsListeners;
    std::vector<Subscription> itsSubscriptions;
    std::mutex itsMutex;
    std::condition_variable itsCondition;
};

void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(_listener);
    itsSubscriptions.push_back(_subscription);
}

#include <iostream>
#include <thread>
#include <vector>
#include <mutex","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(_listener);
    itsSubscriptions.push_back(_subscription);
}
docs/cpp/cpp_api_reference/cpp_api_reference_dbus_proxy_status_event.md
# DBusProxyStatusEvent

## Description

The `DBusProxyStatusEvent` class is used to notify listeners of changes in the status of a DBus proxy.

## Members

### Listener

The `Listener` struct represents a listener that is interested in receiving status updates for a specific DBus proxy.

```cpp
struct Listener {
    std::string interface;
    std::string path;
    std::string member;
};
```

### Subscription

The `Subscription` struct represents a subscription to a specific signal on a DBus proxy.

```cpp
struct Subscription {
    std::string interface;
    std::string path;
    std::string member;
    std::string signal;
};
```

### itsListeners

A vector of `Listener` structs that are currently subscribed to status updates.

```cpp
std::vector<Listener> itsListeners;
```

### itsSubscriptions

A vector of `Subscription` structs that represent the subscriptions that are currently active.

```cpp
std::vector<Subscription> itsSubscriptions;
```

### itsMutex

A mutex that is used to protect access to the `itsListeners` and `itsSubscriptions` vectors.

```cpp
std::mutex itsMutex;
```

### itsCondition

A condition variable that is used to signal listeners when a new status update is available.

```cpp
std::condition_variable itsCondition;
```

## Methods

### onListenerAdded

This method is called to add a new listener to the list of listeners that are interested in receiving status updates.

```cpp
void onListenerAdded(const Listener &_listener, const Subscription _subscription);
```

## Example

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <condition_variable>

class DBusProxyStatusEvent {
public:
    struct Listener {
        std::string interface;
        std::string path;
        std::string member;
    };

    struct Subscription {
        std::string interface;
        std::string path;
        std::string member;
        std::string signal;
    };

    void onListenerAdded(const Listener &_listener, const Subscription _subscription);

private:
    std::vector<Listener> itsListeners;
    std::vector<Subscription> itsSubscriptions;
    std::mutex itsMutex;
    std::condition_variable itsCondition;
};

void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(_listener);
    itsSubscriptions.push_back(_subscription);
}
```
docs/cpp/cpp_api_reference/cpp_api_reference_dbus_proxy_status_event.md
# DBusProxyStatusEvent

## Description

The `DBusProxyStatusEvent` class is used to notify listeners of changes in the status of a DBus proxy.

## Members

### Listener

The `Listener` struct represents a listener that is interested in receiving status updates for a specific DBus proxy.

```cpp
struct Listener {
    std::string interface;
    std",51.78709653613711,3.1124422377263623,39.03594390682206,65.0,100.0
70,cpp,"void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener,
                                             const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);
    (void)_listener;
    auto listenerIt = listeners_.begin();
    while(listenerIt != listeners_.end()) {
        if(listenerIt->first == _subscription)
            listenerIt = listeners_.erase(listenerIt);
        else
            ++listenerIt;
    }
}","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener](const Listener& listener) {
                               return listener == _listener;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Listener {
public:
    Listener(int id) : id_(id) {}
    int id() const { return id_; }
private:
    int id_;
};

class Subscription {
public:
    Subscription(std::string name) : name_(name) {}
    std::string name() const { return name_; }
private:
    std::string name_;
};

class DBusProxyStatusEvent {
public:
    void onListenerRemoved(const Listener& _listener, const Subscription _subscription);
private:
    std::vector<Listener> itsListeners;
    std::mutex itsMutex;
};

void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener](const Listener& listener) {
                               return listener == _listener;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}

int main() {
    DBusProxyStatusEvent event;
    Listener listener1(1);
    Listener listener2(2);
    Subscription subscription1(""sub1"");
    Subscription subscription2(""sub2"");

    event.onListenerRemoved(listener1, subscription1);
    event.onListenerRemoved(listener2, subscription2);

    return 0;
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Listener {
public:
    Listener(int id) : id_(id) {}
    int id() const { return id_; }
private:
    int id_;
};

class Subscription {
public:
    Subscription(std::string name) : name_(name) {}
    std::string name() const { return name_; }
private:
    std::string name_;
};

class DBusProxyStatusEvent {
public:
    void onListenerRemoved(const Listener& _listener, const Subscription _subscription);
private:
    std::vector<Listener> itsListeners;
    std::mutex itsMutex;
};

void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener](const Listener& listener) {
                               return listener == _listener;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}

int main() {
    DBusProxyStatusEvent event;
    Listener listener1(1);
    Listener listener2(2);
    Subscription subscription1","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener](const Listener& listener) {
                               return listener == _listener;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Listener {
public:
    Listener(int id) : id_(id) {}
    int id() const { return id_; }
private:
    int id_;
};

class Subscription {
public:
    Subscription(std::string name) : name_(name) {}
    std::string name() const { return name_; }
private:
    std::string name_;
};

class DBusProxyStatusEvent {
public:
    void onListenerRemoved(const Listener& _listener, const Subscription _subscription);
private:
    std::vector<Listener> itsListeners;
    std::mutex itsMutex;
};

void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener](const Listener& listener) {
                               return listener == _listener;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}

int main() {
    DBusProxyStatusEvent event;
    Listener listener1(1);
    Listener listener2(2);
    Subscription subscription1(""sub1"");
    Subscription subscription2(""sub2"");

    event.onListenerRemoved(listener1, subscription1);
    event.onListenerRemoved(listener2, subscription2);

    return 0;
}
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <algorithm>

class Listener {
public:
    Listener(int id) : id_(id) {}
    int id() const { return id_; }
private:
    int id_;
};

class Subscription {
public:
    Subscription(std::string name) : name_(name) {}
    std::string name() const { return name_; }
private:
    std::string name_;
};

class DBusProxyStatusEvent {
public:
    void onListenerRemoved(const Listener& _listener, const Subscription _subscription);
private:
    std::vector<Listener> itsListeners;
    std::mutex itsMutex;
};

void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener](const Listener& listener) {
                               return listener == _listener;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}

int main() {
    DBusProxyStatusEvent event;
    Listener listener1(1);
    Listener listener2(2);
    Subscription subscription1(""sub1"");",47.05512124091535,3.07986520555562,29.783476900962913,62.5,92.85714285714286
71,cpp,"void DBusProxyBase::addSignalStateHandler(
            std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler,
            const uint32_t _subscription) {
    connection_->addSignalStateHandler(_handler, _subscription);
}","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->addSignalStateHandler(_handler, _subscription);
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""banana""
    auto it = std::find(words.begin(), words.end(), ""banana"");
    if (it != words.end()) {
        std::cout << ""Index of banana: "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""banana not found"" << std::endl;
    }

    // Remove ""cherry""
    words.erase(std::remove(words.begin(), words.end(), ""cherry""), words.end());

    // Print the updated words
    std::cout << ""Words after removing cherry: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""banana""
    auto it = std::find(words.begin(), words.end(), ""banana"");
    if (it != words.end()) {
        std::cout << ""Index of banana: "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""banana not found"" << std::endl;
    }

    // Remove ""cherry""
    words.erase(std::remove(words.begin(), words.end(), ""cherry""), words.end());

    // Print the updated words
    std::cout << ""Words after removing cherry: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->addSignalStateHandler(_handler, _subscription);
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""banana""
    auto it = std::find(words.begin(), words.end(), ""banana"");
    if (it != words.end()) {
        std::cout << ""Index of banana: "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""banana not found"" << std::endl;
    }

    // Remove ""cherry""
    words.erase(std::remove(words.begin(), words.end(), ""cherry""), words.end());

    // Print the updated words
    std::cout << ""Words after removing cherry: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""banana""
    auto it = std::find(words.begin(), words.end(), ""banana"");
    if (it != words.end()) {
        std::cout << ""Index of banana: "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""banana not found"" << std::endl;
    }

    // Remove ""cherry""
    words.erase(std::remove(words.begin(), words.end(), ""cherry""), words.end());

    // Print the updated words
    std::cout << ""Words after removing cherry: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word",59.748057905549125,1.2676344150435028,43.28015276270854,94.44444444444444,100.0
72,cpp,"void
DBusProxyManager::instancesAsyncCallback(
        std::shared_ptr<Proxy> _proxy,
        const CommonAPI::CallStatus &_status,
        const std::vector<DBusAddress> &_availableServiceInstances,
        GetAvailableInstancesCallback &_call) {
    (void)_proxy;
    std::vector<std::string> itsAvailableInstances;
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        translate(_availableServiceInstances, itsAvailableInstances);
    }
    _call(_status, itsAvailableInstances);
}","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> availableServiceInstances;
        for (const auto &_dbusAddress : _availableServiceInstances) {
            availableServiceInstances.push_back(_dbusAddress.toString());
        }
        _call(CommonAPI::CallStatus::SUCCESS, availableServiceInstances);
    } else {
        _call(_status, {});
    }
}
docs/api/cpp/commonapi/commonapi_examples.md
# CommonAPI Examples

## Hello World

This example shows how to use the CommonAPI to call a simple hello world service.

### Server

```cpp
#include <iostream>
#include <string>
#include <memory>
#include <thread>
#include <CommonAPI/CommonAPI.hpp>

class HelloService : public CommonAPI::DBusService {
public:
    HelloService() : CommonAPI::DBusService(""org.example.hello"", ""org.example.hello.Hello"") {
    }

    void registerService() {
        addMethod(""hello"", &HelloService::hello);
    }

    void hello(CommonAPI::DBusCall &call) {
        std::string message = ""Hello, world!"";
        call.reply(message);
    }
};

int main() {
    CommonAPI::DBusMainLoop mainLoop;
    CommonAPI::DBusConnection connection;
    CommonAPI::DBusAddress address(""unix:hello.dbus"");
    CommonAPI::DBusAddress busAddress(""unix:org.example.hello.hello.DBus"");
    CommonAPI::DBusAddress busAddress2(""unix:org.example.hello.hello.DBus2"");
    CommonAPI::DBusAddress busAddress3(""unix:org.example.hello.hello.DBus3"");
    CommonAPI::DBusAddress busAddress4(""unix:org.example.hello.hello.DBus4"");
    CommonAPI::DBusAddress busAddress5(""unix:org.example.hello.hello.DBus5"");
    CommonAPI::DBusAddress busAddress6(""unix:org.example.hello.hello.DBus6"");
    CommonAPI::DBusAddress busAddress7(""unix:org.example.hello.hello.DBus7"");
    CommonAPI::DBusAddress busAddress8(""unix:org.example.hello.hello.DBus8"");
    CommonAPI::DBusAddress busAddress9(""unix:org.example.hello.hello.DBus9"");
    CommonAPI::DBusAddress busAddress10(""unix:org.example.hello.hello.DBus10"");
    CommonAPI::DBusAddress busAddress11(""unix:org.example.hello.hello.DBus11"");
    CommonAPI::DBusAddress busAddress12(""unix:org.example.hello.hello.DBus12"");
    CommonAPI::DBusAddress busAddress13(""unix:org.example.hello.hello.DBus13"");
    CommonAPI::DBusAddress busAddress14(""unix:org.example.hello.hello.DBus14"");
    CommonAPI::DBusAddress busAddress15(""unix:org.example.hello.hello.DBus15"");
    CommonAPI::DBus","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> availableServiceInstances;
        for (const auto &_dbusAddress : _availableServiceInstances) {
            availableServiceInstances.push_back(_dbusAddress.toString());
        }
        _call(CommonAPI::CallStatus::SUCCESS, availableServiceInstances);
    } else {
        _call(_status, {});
    }
}
docs/api/cpp/commonapi/commonapi_examples.md
# CommonAPI Examples

## Hello World

This example shows how to use the CommonAPI to call a simple hello world service.

### Server

```cpp
#include <iostream>
#include <string>
#include <memory>
#include <thread>
#include <CommonAPI/CommonAPI.hpp>

class HelloService : public CommonAPI::DBusService {
public:
    HelloService() : CommonAPI::DBusService(""org.example.hello"", ""org.example.hello.Hello"") {
    }

    void registerService() {
        addMethod(""hello"", &HelloService::hello);
    }

    void hello(CommonAPI::DBusCall &call) {
        std::string message = ""Hello, world!"";
        call.reply(message);
    }
};

int main() {
    CommonAPI::DBusMainLoop mainLoop;
    CommonAPI::DBusConnection connection;
    CommonAPI::DBusAddress address(""unix:hello.dbus"");
    CommonAPI::DBusAddress busAddress(""unix:org.example.hello.hello.DBus"");
    CommonAPI::DBusAddress busAddress2(""unix:org.example.hello.hello.DBus2"");
    CommonAPI::DBusAddress busAddress3(""unix:org.example.hello.hello.DBus3"");
    CommonAPI::DBusAddress busAddress4(""unix:org.example.hello.hello.DBus4"");
    CommonAPI::DBusAddress busAddress5(""unix:org.example.hello.hello.DBus5"");
    CommonAPI::DBusAddress busAddress6(""unix:org.example.hello.hello.DBus6"");
    CommonAPI::DBusAddress busAddress7(""unix:org.example.hello.hello.DBus7"");
    CommonAPI::DBusAddress busAddress8(""unix:org.example.hello.hello.DBus8"");
    CommonAPI::DBusAddress busAddress9(""unix:org.example.hello.hello.DBus9"");
    CommonAPI::DBusAddress busAddress10(""unix:org.example.hello.hello.DBus10"");
    CommonAPI::DBusAddress busAddress11(""unix:org.example.hello.hello.DBus11"");
    CommonAPI::DBusAddress busAddress12(""unix:org.example.hello.hello.DBus12"");
    CommonAPI::DBusAddress busAddress13(""unix:org.example.hello.hello.DBus13"");
    CommonAPI::DBusAddress busAddress14(""unix:org.example.hello.hello.DBus14"");
    CommonAPI::DBusAddress busAddress15(""unix:org.example.hello.hello.DBus15"");
    CommonAPI::DBusAddress",55.19311372423425,8.951776964180418,51.265122377201045,68.88888888888889,91.66666666666666
73,cpp,"bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    const char* objectPath = dbusMessage.getObjectPath();
    const char* interfaceName = dbusMessage.getInterface();

    if (NULL == objectPath) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" objectPath == NULL"");
    }
    if (NULL == interfaceName) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" interfaceName == NULL"");
    }

    DBusInterfaceHandlerPath handlerPath(objectPath, interfaceName);

    std::unique_lock<std::recursive_mutex> itsLock(objectPathLock_);

    auto handlerIterator = dbusRegisteredObjectsTable_.find(handlerPath);
    const bool foundDBusInterfaceHandler = handlerIterator != dbusRegisteredObjectsTable_.end();
    bool dbusMessageHandled = false;

    if (foundDBusInterfaceHandler) {
        std::shared_ptr<DBusInterfaceHandler> dbusStubAdapterBase = handlerIterator->second.front();
        itsLock.unlock();
        dbusMessageHandled = dbusStubAdapterBase->onInterfaceDBusMessage(dbusMessage);
        return dbusMessageHandled;
    } else if (dbusMessage.hasInterfaceName(""org.freedesktop.DBus.Introspectable"")) {
        dbusMessageHandled = onIntrospectableInterfaceDBusMessage(dbusMessage);
    }

    return dbusMessageHandled;
}","```cpp
bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.isMethodCall()) {
        const std::string& interface = dbusMessage.getInterface();
        const std::string& method = dbusMessage.getMethodName();
        const std::string& objectPath = dbusMessage.getObjectPath();

        auto it = handlers_.find(objectPath);
        if (it != handlers_.end()) {
            auto& handlers = it->second;
            auto it2 = handlers.find(interface);
            if (it2 != handlers.end()) {
                auto& methodHandlers = it2->second;
                auto it3 = methodHandlers.find(method);
                if (it3 != methodHandlers.end()) {
                    return it3->second(dbusMessage);
                }
            }
        }
    } else if (dbusMessage.isSignal()) {
        return false;
    } else if (dbusMessage.isError()) {
        return false;
    } else if (dbusMessage.isReply()) {
        return false;
    } else if (dbusMessage.isMethodReturn()) {
        return false;
    } else if (dbusMessage.isMethodError()) {
        return false;
    } else if (dbusMessage.isEndOfSession()) {
        return false;
    } else if (dbusMessage.isEndOfSessionMessage()) {
        return false;
    } else if (dbusMessage.isErrorResponse()) {
        return false;
    } else if (dbusMessage.isMethodInfo()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;","```cpp
bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.isMethodCall()) {
        const std::string& interface = dbusMessage.getInterface();
        const std::string& method = dbusMessage.getMethodName();
        const std::string& objectPath = dbusMessage.getObjectPath();

        auto it = handlers_.find(objectPath);
        if (it != handlers_.end()) {
            auto& handlers = it->second;
            auto it2 = handlers.find(interface);
            if (it2 != handlers.end()) {
                auto& methodHandlers = it2->second;
                auto it3 = methodHandlers.find(method);
                if (it3 != methodHandlers.end()) {
                    return it3->second(dbusMessage);
                }
            }
        }
    } else if (dbusMessage.isSignal()) {
        return false;
    } else if (dbusMessage.isError()) {
        return false;
    } else if (dbusMessage.isReply()) {
        return false;
    } else if (dbusMessage.isMethodReturn()) {
        return false;
    } else if (dbusMessage.isMethodError()) {
        return false;
    } else if (dbusMessage.isEndOfSession()) {
        return false;
    } else if (dbusMessage.isEndOfSessionMessage()) {
        return false;
    } else if (dbusMessage.isErrorResponse()) {
        return false;
    } else if (dbusMessage.isMethodInfo()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;",29.185768631276492,2.9572308249408206,10.503990418311867,35.714285714285715,67.56756756756756
74,cpp,"bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath,
                                                std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    const auto& dbusRegisteredObjectsTableIter = dbusRegisteredObjectsTable_.find(dbusInterfaceHandlerPath);
    const bool isDBusInterfaceHandlerAlreadyAdded = (dbusRegisteredObjectsTableIter != dbusRegisteredObjectsTable_.end());

    if (isDBusInterfaceHandlerAlreadyAdded) {

        auto handler = find(dbusRegisteredObjectsTableIter->second.begin(), dbusRegisteredObjectsTableIter->second.end(), dbusInterfaceHandler);
        if (handler != dbusRegisteredObjectsTableIter->second.end()) {
            if (dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.ObjectManager"" ||
                    dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.Properties"") {
                return true;
            }
            return false;
        }
    }

    auto insertSuccess = addToRegisteredObjectsTable(dbusInterfaceHandlerPath, dbusInterfaceHandler);
    return insertSuccess;
}","bool DBusObjectManager::addDBusInterfaceHandler(
    const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath,
    std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
  std::lock_guard<std::mutex> lock(interfaceHandlersMutex_);
  auto it = interfaceHandlers_.find(dbusInterfaceHandlerPath);
  if (it != interfaceHandlers_.end()) {
    if (it->second->getInterface() == ""org.freedesktop.DBus.Introspectable"" ||
        it->second->getInterface() == ""org.freedesktop.DBus.Properties"") {
      return true;
    } else {
      return false;
    }
  }
  interfaceHandlers_[dbusInterfaceHandlerPath] = std::move(dbusInterfaceHandler);
  return true;
}","bool DBusObjectManager::addDBusInterfaceHandler(
    const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath,
    std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
  std::lock_guard<std::mutex> lock(interfaceHandlersMutex_);
  auto it = interfaceHandlers_.find(dbusInterfaceHandlerPath);
  if (it != interfaceHandlers_.end()) {
    if (it->second->getInterface() == ""org.freedesktop.DBus.Introspectable"" ||
        it->second->getInterface() == ""org.freedesktop.DBus.Properties"") {
      return true;
    } else {
      return false;
    }
  }
  interfaceHandlers_[dbusInterfaceHandlerPath] = std::move(dbusInterfaceHandler);
  return true;
}",39.97743921296945,20.79194777273109,22.252729714067343,59.72222222222222,57.14285714285714
75,cpp,"bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    auto handlerRecord = dbusRegisteredObjectsTable_.find(ifpath);
    if (handlerRecord == dbusRegisteredObjectsTable_.end()) {
        dbusRegisteredObjectsTable_.insert({
            ifpath,
            std::vector<std::shared_ptr<DBusInterfaceHandler>>({handler})
        });
    }
    else {
        std::vector<std::shared_ptr<DBusInterfaceHandler>> handlerList = handlerRecord->second;
        auto adapter = find(handlerList.begin(), handlerList.end(), handler);
        if (adapter != handlerList.end()) {
            return false;
        }
        else {
            handlerList.push_back(handler);
            handlerRecord->second = handlerList;
        }
    }
    return true;
}","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    std::lock_guard<std::mutex> itsLock(registeredObjectsMutex_);
    auto it = registeredObjects_.find(ifpath);
    if (it != registeredObjects_.end()) {
        return false;
    }
    registeredObjects_[ifpath] = std::move(handler);
    return true;
}","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    std::lock_guard<std::mutex> itsLock(registeredObjectsMutex_);
    auto it = registeredObjects_.find(ifpath);
    if (it != registeredObjects_.end()) {
        return false;
    }
    registeredObjects_[ifpath] = std::move(handler);
    return true;
}",32.53885472803908,13.161448160370679,17.957826173472384,59.036144578313255,40.0
78,c,"void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t positive_sid = UDS_SID_ECU_RESET + 0x40;

  uint8_t tx_data[] = {positive_sid, reset_type};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_positive_reset_response(uint8_t reset_type) {
    uint8_t ecu_reset_response[2];
    ecu_reset_response[0] = 0x70;
    ecu_reset_response[1] = reset_type;
    if (iso_tp_send_message(ecu_reset_response, 2) != 0) {
        error_log(""Failed to send ECU reset response"");
    }
}","void send_positive_reset_response(uint8_t reset_type) {
    uint8_t ecu_reset_response[2];
    ecu_reset_response[0] = 0x70;
    ecu_reset_response[1] = reset_type;
    if (iso_tp_send_message(ecu_reset_response, 2) != 0) {
        error_log(""Failed to send ECU reset response"");
    }
}",11.747897329678961,6.529498338214534,7.841770124886338,9.090909090909092,23.52941176470588
79,c,"void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    return;
  }

  uint8_t reset_type = data[1];

  if (reset_type == UDS_RESET_TYPE_HARD) {
    send_positive_reset_response(UDS_RESET_TYPE_HARD);

    k_sleep(K_MSEC(100));

    LOG_DBG(""Hard reset\n"");
    sys_reboot(SYS_REBOOT_COLD);
  } else {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_SUBFUNCTION_NOT_SUPPORTED);
  }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
    if (len != 2) {
        send_negative_response();
        return;
    }

    uint8_t sub_function = data[1];

    if (sub_function == ECU_RESET_HARD) {
        send_positive_response();
        system_reboot();
    } else {
        send_negative_response();
    }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
    if (len != 2) {
        send_negative_response();
        return;
    }

    uint8_t sub_function = data[1];

    if (sub_function == ECU_RESET_HARD) {
        send_positive_response();
        system_reboot();
    } else {
        send_negative_response();
    }
}",44.949373388655786,40.61398531981548,42.28428342860616,30.23255813953488,66.66666666666666
80,c,"void send_request_download_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_DOWNLOAD + 0x40;


  uint8_t tx_data[] = {
    positive_sid,
    0x20,  // positive response code
    0x00,
    0xD2,  // block size = 258 - 2
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","```c
void send_request_download_response() {
    uint8_t ecu_id = 0x01;
    uint8_t service_id = 0x10;
    uint8_t payload[4] = {0x00, 0xD2, 0x00, 0x00};
    uint8_t ecu_id_extended = 0x00;
    uint8_t ecu_id_extended_length = 0x00;
    uint8_t ecu_id_length = 0x01;
    uint8_t service_id_length = 0x02;
    uint8_t data_length = 0x04;
    uint8_t data_length_extended = 0x00;
    uint8_t data_length_extended_length = 0x00;
    uint8_t data_length_length = 0x01;
    uint8_t data_length_extended_length_length = 0x00;
    uint8_t data_length_length_length = 0x00;
    uint8_t data_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length","```c
void send_request_download_response() {
    uint8_t ecu_id = 0x01;
    uint8_t service_id = 0x10;
    uint8_t payload[4] = {0x00, 0xD2, 0x00, 0x00};
    uint8_t ecu_id_extended = 0x00;
    uint8_t ecu_id_extended_length = 0x00;
    uint8_t ecu_id_length = 0x01;
    uint8_t service_id_length = 0x02;
    uint8_t data_length = 0x04;
    uint8_t data_length_extended = 0x00;
    uint8_t data_length_extended_length = 0x00;
    uint8_t data_length_length = 0x01;
    uint8_t data_length_length_length = 0x00;
    uint8_t data_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length = 0x00;
    uint8_t data_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length",27.374155555068324,1.0544938095516672,2.1921284107216423,6.25,0.0
81,c,"static void send_transfer_data_response(uint8_t block_sequence_counter) {
  int ret;
  uint8_t positive_sid = UDS_SID_TRANSFER_DATA + 0x40;

  uint8_t tx_data[] = {positive_sid, block_sequence_counter};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
    uint8_t ecu_id = 0x7E;
    uint8_t positive_sid = 0x31;
    uint8_t data[2] = {positive_sid, block_sequence_counter};
    uint8_t length = 2;
    uint8_t result = can_send_iso_tp_message(ecu_id, data, length);
    if (result != CAN_OK) {
        printf(""Error sending transfer data response: %d\n"", result);
    }
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
    uint8_t ecu_id = 0x7E;
    uint8_t positive_sid = 0x31;
    uint8_t data[2] = {positive_sid, block_sequence_counter};
    uint8_t length = 2;
    uint8_t result = can_send_iso_tp_message(ecu_id, data, length);
    if (result != CAN_OK) {
        printf(""Error sending transfer data response: %d\n"", result);
    }
}",28.17484404991618,14.979856584169287,15.366578439024861,23.52941176470588,58.82352941176471
82,c,"static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
  int ret;
  uint8_t positive_sid = UDS_SID_ROUTINE_CONTROL + 0x40;

  uint8_t tx_data[] = {positive_sid, 0x1, (routine_id >> 8) & 0xFF,
                       routine_id & 0xFF, result};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
    uint8_t data[5];
    data[0] = 0x7E;
    data[1] = 0x00;
    data[2] = 0x00;
    data[3] = (uint8_t)(routine_id >> 8);
    data[4] = (uint8_t)routine_id;

    if (iso_tp_send(0x180, data, 5) != 0) {
        fprintf(stderr, ""Error sending routine control result\n"");
    }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
    uint8_t data[5];
    data[0] = 0x7E;
    data[1] = 0x00;
    data[2] = 0x00;
    data[3] = (uint8_t)(routine_id >> 8);
    data[4] = (uint8_t)routine_id;
    data[4] = result;

    if (iso_tp_send(0x180, data, 5) != 0) {
        fprintf(stderr, ""Error sending routine control result\n"");
    }
}",24.193907091083926,12.446260805703862,13.688341917606209,25.64102564102564,45.0
83,c,"static void send_transer_exit_positive_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_TRANSFER_EXIT + 0x40;

  uint8_t tx_data[] = {positive_sid};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","```c
static void send_transer_exit_positive_response() {
    uint8_t ecu_id = 0x7E;
    uint8_t sid = 0x40;
    uint8_t data[1] = {0x40};
    uint8_t length = 1;
    uint8_t payload[1] = {sid};
    uint8_t num_bytes = 1;
    uint8_t ecu_id_extended = 0;
    uint8_t ecu_id_extended_length = 0;
    uint8_t ecu_id_extended_data[1] = {0};
    uint8_t ecu_id_extended_data_length = 0;
    uint8_t ecu_id_extended_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_length = 0;
    uint8_t ecu_id_extended_data_length_field_data[1] = {0};
    uint8_t ecu_id_extended_data_length_field_data_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data[1] = {0};
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data[1] = {0};
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field_data[1] = {0};
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field_data_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field_data_length_field_length = 0;
    uint8_t ecu_id_extended","```c
static void send_transer_exit_positive_response() {
    uint8_t ecu_id = 0x7E;
    uint8_t sid = 0x40;
    uint8_t data[1] = {0x40};
    uint8_t length = 1;
    uint8_t payload[1] = {sid};
    uint8_t num_bytes = 1;
    uint8_t ecu_id_extended = 0;
    uint8_t ecu_id_extended_length = 0;
    uint8_t ecu_id_extended_data[1] = {0};
    uint8_t ecu_id_extended_data_length = 0;
    uint8_t ecu_id_extended_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_length = 0;
    uint8_t ecu_id_extended_data_length_field_data[1] = {0};
    uint8_t ecu_id_extended_data_length_field_data_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data[1] = {0};
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data[1] = {0};
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field_data[1] = {0};
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field_data_length_field_length = 0;
    uint8_t ecu_id_extended_data_length_field_data_length_field_data_length_field",12.230775302270809,2.545389755321228,7.58983266588322,12.121212121212121,26.666666666666668
85,c,"static inline uint8_t map_from_can_id(uint32_t can_id) {
  for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
    if (id_mapping[i] == can_id) {
      return i;
    }
  }

  return 0xff;
}","static inline uint8_t map_from_can_id(uint32_t can_id) {
    uint8_t i;
    for (i = 0; i < sizeof(id_mapping) / sizeof(id_mapping[0]); i++) {
        if (id_mapping[i].can_id == can_id) {
            return i;
        }
    }
    return 0xff;
}","static inline uint8_t map_from_can_id(uint32_t can_id) {
    uint8_t i;
    for (i = 0; i < sizeof(id_mapping) / sizeof(id_mapping[0]); i++) {
        if (id_mapping[i].can_id == can_id) {
            return i;
        }
    }
    return 0xff;
}",52.56786101386842,56.182680051524926,63.61257352775831,47.61904761904761,42.857142857142854
86,c,"static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
  struct lin2can_data *data = dev->data;

 if (filter_id == TRANSLATABLE_ADDRESSES_LEN) {
    for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
      data->incoming_callbacks[i].callback = 0;
    }

    return;
  }

  if (filter_id >= TRANSLATABLE_ADDRESSES_LEN) {
    return;
  }
  data->incoming_callbacks[filter_id].callback = 0;
}","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev->data;

	if (filter_id == -1) {
		for (int i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			data->rx_filters[i].cb = NULL;
		}
	} else if (filter_id >= 0 && filter_id < ARRAY_SIZE(data->rx_filters)) {
		data->rx_filters[filter_id].cb = NULL;
	}
}","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev->data;

	if (filter_id == -1) {
		for (int i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			data->rx_filters[i].cb = NULL;
		}
	} else if (filter_id >= 0 && filter_id < ARRAY_SIZE(data->rx_filters)) {
		data->rx_filters[filter_id].cb = NULL;
	}
}",53.88814496926921,53.02914032874241,57.96857412390379,52.38095238095239,52.17391304347826
87,c,"static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  struct lin2can_data *data = dev->data;
  struct k_msgq *outgoing_frame_buffer = data->outgoing_frame_queue;

  struct lin2can_outgoing_frame_t outgoing;
  if (k_msgq_get(outgoing_frame_buffer, &outgoing, K_NO_WAIT)) {
    return false;
  }

  memcpy(frame, &outgoing.frame, sizeof(*frame));

  LOG_DBG(""Calling can tx callback"");

  outgoing.callback(dev, 0, outgoing.user_data);

  return true;
}","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
	struct lin_context *ctx = user_data;
	struct lin_frame_data *data = &frame->data;
	bool ret = false;

	if (list_empty(&ctx->tx_queue)) {
		return false;
	}

	struct list_head *head = &ctx->tx_queue;
	struct lin_frame *tmp = list_first_entry(head, struct lin_frame, list);

	if (tmp->type == LIN_FRAME_TYPE_REQUEST) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	} else if (tmp->type == LIN_FRAME_TYPE_RESPONSE) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	} else if (tmp->type == LIN_FRAME_TYPE_ACK) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	} else if (tmp->type == LIN_FRAME_TYPE_NACK) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	} else if (tmp->type == LIN_FRAME_TYPE_ERROR) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	}

	if (ret) {
		ctx->frame_cb(frame, user_data);
	}

	return ret;
}","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
	struct lin_context *ctx = user_data;
	struct lin_frame_data *data = &frame->data;
	bool ret = false;

	if (list_empty(&ctx->tx_queue)) {
		return false;
	}

	struct list_head *head = &ctx->tx_queue;
	struct lin_frame *tmp = list_first_entry(head, struct lin_frame, list);

	if (tmp->type == LIN_FRAME_TYPE_REQUEST) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	} else if (tmp->type == LIN_FRAME_TYPE_RESPONSE) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	} else if (tmp->type == LIN_FRAME_TYPE_ACK) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	} else if (tmp->type == LIN_FRAME_TYPE_NACK) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	} else if (tmp->type == LIN_FRAME_TYPE_ERROR) {
		if (tmp->data.length > 0) {
			memcpy(data, &tmp->data, tmp->data.length);
			tmp->data.length = 0;
			list_del(&tmp->list);
			ctx->tx_pending--;
			ret = true;
		}
	}

	if (ret) {
		ctx->frame_cb(frame, user_data);
	}

	return ret;
}",37.994934352682826,6.540116531641734,24.060310534261976,41.37931034482759,80.0
88,c,"static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  const struct lin2can_data *data = dev->data;

 uint8_t mapped_id = frame->data[0] >> 6;

  __ASSERT(mapped_id < TRANSLATABLE_ADDRESSES_LEN, ""Unexpected LIN-ID: %x"",
           mapped_id);

  LOG_DBG(""Incoming can frame with can id %x"", id_mapping[mapped_id]);

 if (!data->incoming_callbacks[mapped_id].callback) {
    return;
  }

  struct can_frame translated = {
    .id = id_mapping[mapped_id],
    .dlc = 8,
  };
  memcpy(translated.data, frame->data, frame->len);

  translated.data[0] = frame->data[0] & 0x3f;

  LOG_DBG(""Calling according can callback"");

  data->incoming_callbacks[mapped_id].callback(
      dev, &translated, data->incoming_callbacks[mapped_id].user_data);
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
    uint32_t can_id = (frame->data[0] & 0x03) << 16;
    uint8_t payload_len = frame->data_len - 1;
    uint8_t *payload = frame->data + 1;

    struct can_frame can_frame = {
        .id = can_id,
        .dlc = payload_len,
        .data = payload,
    };

    struct can_handler_data *handler_data = (struct can_handler_data *)user_data;
    handler_data->handler(handler_data->context, &can_frame);
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
    uint32_t can_id = (frame->data[0] & 0x03) << 16;
    uint8_t payload_len = frame->data_len - 1;
    uint8_t *payload = frame->data + 1;

    struct can_frame can_frame = {
        .id = can_id,
        .dlc = payload_len,
        .data = payload,
    };

    struct can_handler_data *handler_data = (struct can_handler_data *)user_data;
    handler_data->handler(handler_data->context, &can_frame);
}",28.416788948645923,14.623080441405653,16.51533972099414,42.5287356321839,40.0
89,c,"static int hv_shield_init(const struct device* dev) {
  const struct hv_shield_config_t* config = dev->config;
  struct hv_shield_data_t* data = dev->data;

  int err = gpio_pin_configure_dt(&config->oe_gpio_spec, GPIO_OUTPUT_INACTIVE);
  if (err) {
    LOG_ERR(""Error setting up Output enable pin (%d)"", err);
    return err;
  }

  memset(&data->registers, 0, sizeof(data->registers));

  err = _hv_shield_update(dev);
  if (err) {
    LOG_ERR(""Error writing registers (%d)"", err);
    return err;
  }

  err = gpio_pin_set_dt(&config->oe_gpio_spec, 1);
  if (err) {
    LOG_ERR(""Error setting enabling output (%d)"", err);
  }

  return err;
}","static int hv_shield_init(const struct device* dev) {
	int ret;

	ret = gpio_request(dev->data->oe_gpio, ""hv_shield_oe"");
	if (ret) {
		dev_err(dev, ""Failed to request OE GPIO: %d\n"", ret);
		return ret;
	}

	ret = gpio_direction_output(dev->data->oe_gpio, 0);
	if (ret) {
		dev_err(dev, ""Failed to set OE GPIO direction: %d\n"", ret);
		gpio_free(dev->data->oe_gpio);
		return ret;
	}

	memset(dev->data->hw_reg, 0, sizeof(dev->data->hw_reg));

	ret = gpio_set_value(dev->data->oe_gpio, 1);
	if (ret) {
		dev_err(dev, ""Failed to set OE GPIO value: %d\n"", ret);
		gpio_free(dev->data->oe_gpio);
		return ret;
	}

	return 0;
}","static int hv_shield_init(const struct device* dev) {
	int ret;

	ret = gpio_request(dev->data->oe_gpio, ""hv_shield_oe"");
	if (ret) {
		dev_err(dev, ""Failed to request OE GPIO: %d\n"", ret);
		return ret;
	}

	ret = gpio_direction_output(dev->data->oe_gpio, 0);
	if (ret) {
		dev_err(dev, ""Failed to set OE GPIO direction: %d\n"", ret);
		gpio_free(dev->data->oe_gpio);
		return ret;
	}

	memset(dev->data->hw_reg, 0, sizeof(dev->data->hw_reg));

	ret = gpio_set_value(dev->data->oe_gpio, 1);
	if (ret) {
		dev_err(dev, ""Failed to set OE GPIO value: %d\n"", ret);
		gpio_free(dev->data->oe_gpio);
		return ret;
	}

	return 0;
}",24.64080401686205,11.233637264241631,12.71527305285593,39.130434782608695,35.483870967741936
90,c,"static int hvs_set_dac_gain(const struct device* dev,
                            uint8_t dac,
                            enum hv_shield_dac_gains_t gain) {
  if (dac > 1) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;
  switch (dac) {
    case 0:
      data->registers.dac0 = gain;
      break;
    case 1:
      data->registers.dac1 = gain;
      break;
    default:
      return -EINVAL;
  }

  return _hv_shield_update(dev);
}","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
	if (dac > 1) {
		return -EINVAL;
	}

	hvs_shield_dac_gains[dac] = gain;
	hvs_shield_update_dac_gains(dev);

	return 0;
}","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
	if (dac > 1) {
		return -EINVAL;
	}

	hvs_shield_dac_gains[dac] = gain;
	hvs_shield_update_dac_gains(dev);

	return 0;
}",37.752640102876136,34.33427207619715,39.642795512340896,45.45454545454545,31.57894736842105
91,c,"static int hvs_set_gpio_output_enable(const struct device* dev,
                                      uint8_t index,
                                      bool enable) {
  if (index > 31) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;

  if (index % 8 < 4) {
    index += 4;
  } else {
    index -= 4;
  }

  if (enable) {
    data->registers.gpio_output |= 1 << index;
  } else {
    data->registers.gpio_output &= ~(1 << index);
  }

  return _hv_shield_update(dev);
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
	uint8_t reg_index = (index >> 4) | ((index & 0x0f) << 4);
	uint32_t reg_offset = 0x00000004 + (reg_index * 4);
	uint32_t reg_value = 0;
	uint32_t mask = 0x00000001 << index;
	if (enable) {
		reg_value = mask;
	} else {
		reg_value = ~mask;
	}
	reg_value |= hvs_gpio_output_enable_cache[reg_index];
	hvs_gpio_output_enable_cache[reg_index] = reg_value;
	return hvs_write_register(dev, reg_offset, reg_value);
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
	uint8_t reg_index = (index >> 4) | ((index & 0x0f) << 4);
	uint32_t reg_offset = 0x00000004 + (reg_index * 4);
	uint32_t reg_value = 0;
	uint32_t mask = 0x00000001 << index;
	if (enable) {
		reg_value = mask;
	} else {
		reg_value = ~mask;
	}
	reg_value |= hvs_gpio_output_enable_cache[reg_index];
	hvs_gpio_output_enable_cache[reg_index] = reg_value;
	return hvs_write_register(dev, reg_offset, reg_value);
}",32.494706414665835,21.641035200842275,24.375526306877685,33.9622641509434,50.0
92,c,"static void can_router_frame_cb(const struct device *dev,
                                struct can_frame *frame,
                                void *user_data) {
  const struct device *to = user_data;

  const int err = can_send(to, frame, K_NO_WAIT, can_router_tx_cb, NULL);
  if (err) {
    LOG_WRN(""Can send failed (%d)"", err);
    return;
  }

  LOG_DBG(""Routed frame from %s to %s"", dev->name, to->name);
}","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
	int ret;
	struct can_frame dest_frame = {};

	memcpy(&dest_frame, frame, sizeof(struct can_frame));

	ret = can_bus_send(dev, &dest_frame, user_data, 0);

	if (ret == 0) {
		dev_info(dev, ""CAN frame forwarded to destination\n"");
	} else {
		dev_warn(dev, ""Failed to forward CAN frame to destination\n"");
	}
}","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
	int ret;
	struct can_frame dest_frame = {};

	memcpy(&dest_frame, frame, sizeof(struct can_frame));

	ret = can_bus_send(dev, &dest_frame, user_data, 0);

	if (ret == 0) {
		dev_info(dev, ""CAN frame forwarded to destination\n"");
	} else {
		dev_warn(dev, ""Failed to forward CAN frame to destination\n"");
	}
}",44.139302493261965,23.858103002873406,29.365773636841137,40.0,83.33333333333334
93,c,"int can_router_register(const struct can_router_entry_t *entries,
                        int entry_count) {
  LOG_DBG(""Registering %d can router entries"", entry_count);
  for (int i = 0; i < entry_count; i++) {
    const int err =
        can_add_rx_filter(*entries[i].from, can_router_frame_cb,
                          (void *)*entries[i].to, &entries[i].filter);
    if (err) {
      return err;
    }
  }

  LOG_DBG(""Registered %d can router entries"", entry_count);

  return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
    int i;
    for (i = 0; i < entry_count; i++) {
        if (can_filter_register(entries[i].source_if, &entries[i].filter) != 0) {
            return -1;
        }
        if (can_frame_forward_register(entries[i].source_if, entries[i].filter.id, entries[i].filter.mask, entries[i].dest_if, entries[i].callback) != 0) {
            return -1;
        }
    }
    return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
    int i;
    for (i = 0; i < entry_count; i++) {
        if (can_filter_register(entries[i].source_if, &entries[i].filter) != 0) {
            return -1;
        }
        if (can_frame_forward_register(entries[i].source_if, entries[i].filter.id, entries[i].filter.mask, entries[i].dest_if, entries[i].callback) != 0) {
            return -1;
        }
    }
    return 0;
}",42.59769012416372,30.75126288112278,33.0033420091248,43.47826086956522,63.1578947368421
94,c,"static int can_router_sysinit() {
  LOG_DBG(""Initializing can router"");

  STRUCT_SECTION_FOREACH (can_router_table_t, table) {
    int err = can_router_register(table->entries, table->entry_count);
    if (err) {
      LOG_ERR(""could not register can router"");
      return err;
    }
  }

  return 0;
}","static int can_router_sysinit() {
	int ret;
	struct can_route_entry *route;

	for (route = can_route_entries; route->dst != NULL; route++) {
		ret = can_route_register(route->dst, route->src, route->mask, route->flags);
		if (ret < 0) {
			return ret;
		}
	}

	return 0;
}","static int can_router_sysinit() {
	int ret;
	struct can_route_entry *route;

	for (route = can_route_entries; route->dst != NULL; route++) {
		ret = can_route_register(route->dst, route->src, route->mask, route->flags);
		if (ret < 0) {
			return ret;
		}
	}

	return 0;
}",29.228922893232962,18.889796346849767,23.887964191599316,24.137931034482758,50.0
95,c,"static int hvs_set_masked_raw(const struct device* port,
                              gpio_port_pins_t mask,
                              gpio_port_value_t value) {
  const struct hv_shield_gpio_config_t* config = port->config;

  for (int i = 0; i < config->lv_gpios_count; i++) {
    if (!(mask & BIT(i))) continue;

    int ret = gpio_pin_set(config->lv_gpios[i].port, config->lv_gpios[i].pin,
                           !!(value & BIT(i)));
    if (ret < 0) {
      LOG_ERR(""Error settings gpio %d (error %d)"", i, ret);
      return ret;
    }
  }

  return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
	int ret;
	int i;

	for (i = 0; i < ARRAY_SIZE(hvs_gpio_pins); i++) {
		if ((mask & (1 << i)) && (value & (1 << i))) {
			ret = gpio_set_pin(port, hvs_gpio_pins[i], GPIO_ACTIVE_HIGH);
			if (ret) {
				LOG_ERR(""Failed to set GPIO %d\n"", hvs_gpio_pins[i]);
				return ret;
			}
		} else if ((mask & (1 << i)) && !(value & (1 << i))) {
			ret = gpio_set_pin(port, hvs_gpio_pins[i], GPIO_ACTIVE_LOW);
			if (ret) {
				LOG_ERR(""Failed to set GPIO %d\n"", hvs_gpio_pins[i]);
				return ret;
			}
		}
	}

	return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
	int ret;
	int i;

	for (i = 0; i < ARRAY_SIZE(hvs_gpio_pins); i++) {
		if ((mask & (1 << i)) && (value & (1 << i))) {
			ret = gpio_set_pin(port, hvs_gpio_pins[i], GPIO_ACTIVE_HIGH);
			if (ret) {
				LOG_ERR(""Failed to set GPIO %d\n"", hvs_gpio_pins[i]);
				return ret;
			}
		} else if ((mask & (1 << i)) && !(value & (1 << i))) {
			ret = gpio_set_pin(port, hvs_gpio_pins[i], GPIO_ACTIVE_LOW);
			if (ret) {
				LOG_ERR(""Failed to set GPIO %d\n"", hvs_gpio_pins[i]);
				return ret;
			}
		}
	}

	return 0;
}",41.5079702325374,22.084816554578442,35.27692095966506,35.59322033898305,73.07692307692307
96,c,"static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
  struct abstract_lin_data *data = dev->data;

  if (free_slots == NULL) {
    return -EINVAL;
  }

  *free_slots = CONFIG_ABSTRACT_LIN_MAX_FRAME_COUNT - data->used_callbacks;

  return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
	if (free_slots == NULL) {
		return -EINVAL;
	}

	*free_slots = dev->abstract_lin.max_cb_slots - dev->abstract_lin.used_cb_slots;

	return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
	if (free_slots == NULL) {
		return -EINVAL;
	}

	*free_slots = dev->abstract_lin.max_cb_slots - dev->abstract_lin.used_cb_slots;

	return 0;
}",66.4293444834293,60.562229523054434,61.82181507732941,73.33333333333333,70.0
97,c,"static int al_register_incoming_cb(const struct device *dev,
                                   abstract_lin_incoming_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = INCOMING;
  data->callbacks[free_index].incoming_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
	if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
		return -EINVAL;
	}

	struct al_incoming_cb_entry *cb_entry = k_calloc(1, sizeof(struct al_incoming_cb_entry));
	if (!cb_entry) {
		return -ENOMEM;
	}

	cb_entry->callback = callback;
	cb_entry->user_data = user_data;

	list_add_tail(&cb_entry->list, &dev->incoming_cb_list[frame_id]);

	return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
	if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
		return -EINVAL;
	}

	struct al_incoming_cb_entry *cb_entry = k_calloc(1, sizeof(struct al_incoming_cb_entry));
	if (!cb_entry) {
		return -ENOMEM;
	}

	cb_entry->callback = callback;
	cb_entry->user_data = user_data;
	cb_entry->frame_size = frame_size;

	list_add_tail(&cb_entry->list, &dev->incoming_cb_list[frame_id]);

	return 0;
}",44.69137052814949,42.0950254008791,45.28390208987012,48.529411764705884,42.857142857142854
98,c,"static int al_register_outgoing_cb(const struct device *dev,
                                   abstract_lin_outgoing_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = OUTGOING;
  data->callbacks[free_index].outgoing_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
	if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
		return -EINVAL;
	}

	struct abstract_lin_outgoing_cb_entry *cb_entry = k_calloc(1, sizeof(struct abstract_lin_outgoing_cb_entry));
	if (!cb_entry) {
		return -ENOMEM;
	}

	cb_entry->callback = callback;
	cb_entry->user_data = user_data;

	list_add_tail(&cb_entry->list, &dev->abstract_lin.outgoing_cb_list[frame_id]);

	return 0;
}","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
	if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
		return -EINVAL;
	}

	struct abstract_lin_outgoing_cb_entry *cb_entry = k_calloc(1, sizeof(struct abstract_lin_outgoing_cb_entry));
	if (!cb_entry) {
		return -ENOMEM;
	}

	cb_entry->callback = callback;
	cb_entry->user_data = user_data;
	cb_entry->frame_size = frame_size;

	list_add_tail(&cb_entry->list, &dev->abstract_lin.outgoing_cb_list[frame_id]);

	return 0;
}",42.85313523403184,42.0950254008791,45.28390208987012,41.17647058823529,42.857142857142854
99,c,"int abstract_lin_scheduler_set_active_table(
    abstract_lin_scheduler_handle_t sched, size_t table_index) {
  if (table_index >= sched->table_count) {
    return -ENOENT;
  }

  bool active_before = sched->current_table != -1;

  if (active_before) {
    k_sem_take(&sched->active, K_FOREVER);
  }

  sched->current_table = table_index;
  sched->current_table_entry = 0;  // start from the beginning again.

  k_sem_give(&sched->active);

  return 0;
}","int abstract_lin_scheduler_set_active_table(struct abstract_lin_scheduler *scheduler, uint32_t table_index)
{
    if (table_index >= scheduler->num_tables) {
        return -EINVAL;
    }

    sem_acquire(&scheduler->sem);
    scheduler->active_table_index = table_index;
    scheduler->entry_index = 0;
    sem_release(&scheduler->sem);

    return 0;
}","int abstract_lin_scheduler_set_active_table(struct abstract_lin_scheduler *scheduler, uint32_t table_index)
{
    if (table_index >= scheduler->num_tables) {
        return -EINVAL;
    }

    sem_acquire(&scheduler->sem);
    scheduler->active_table_index = table_index;
    scheduler->entry_index = 0;
    sem_release(&scheduler->sem);

    return 0;
}",35.354597651410984,12.37907615107048,15.179665331766445,60.526315789473685,53.333333333333336
100,c,"void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
  if (sched->current_table == -1) {
    return;  // already stopped.
  }

  k_sem_take(&sched->active, K_FOREVER);

  sched->current_table = -1;
}","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
    if (sched->is_stopped) {
        return;
    }

    sem_wait(&sched->sem);
    sched->active_schedule_table_index = -1;
    sem_post(&sched->sem);
}","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
    if (sched->is_stopped) {
        return;
    }

    sem_wait(&sched->sem);
    sched->active_schedule_table_index = -1;
    sem_post(&sched->sem);
}",51.05464073514023,23.758717623824147,25.45984531673679,55.00000000000001,100.0
