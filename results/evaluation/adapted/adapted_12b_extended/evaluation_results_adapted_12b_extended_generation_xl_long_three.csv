id,language,reference,generated,generated_rci,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
2,python,"def is_datatype(cls, value: Any, datatype: str) -> bool:
    t = cls.get_type(datatype)
    if t is None:
        raise DatatypesException(f""Unsupported datatype: {datatype}"")
    return t[1](value)","from typing import Any

def is_datatype(cls, value: Any, datatype: str) -> bool:
    if datatype == ""int"":
        return isinstance(value, int)
    elif datatype == ""float"":
        return isinstance(value, float)
    elif datatype == ""str"":
        return isinstance(value, str)
    elif datatype == ""bool"":
        return isinstance(value, bool)
    elif datatype == ""list"":
        return isinstance(value, list)
    elif datatype == ""tuple"":
        return isinstance(value, tuple)
    elif datatype == ""dict"":
        return isinstance(value, dict)
    elif datatype == ""set"":
        return isinstance(value, set)
    else:
        raise ValueError(""Unsupported datatype"")","from typing import Any

def is_datatype(cls, value: Any, datatype: str) -> bool:
    if datatype == ""int"":
        return isinstance(value, int)
    elif datatype == ""float"":
        return isinstance(value, float)
    elif datatype == ""str"":
        return isinstance(value, str)
    elif datatype == ""bool"":
        return isinstance(value, bool)
    elif datatype == ""list"":
        return isinstance(value, list)
    elif datatype == ""tuple"":
        return isinstance(value, tuple)
    elif datatype == ""dict"":
        return isinstance(value, dict)
    elif datatype == ""set"":
        return isinstance(value, set)
    else:
        raise ValueError(""Unsupported datatype"")",37.65499699406495,9.834867222003856,37.70819767733287,23.076923076923077,80.0
3,python,"def is_xintx(value: Any, signed: bool, bits: int):
    values = [value]
    if isinstance(value, list):
        values = value

    for v in values:
        if not isinstance(v, int):
            return False
        if not signed and v < 0:
            return False
        max = 2**bits - 1
        min = 0
        if signed:
            max = 2 ** (bits - 1) - 1
            min = -(2 ** (bits - 1))
        if not (v <= max and v >= min):
            return False
    return True","from typing import Any

def is_xintx(value: Any, signed: bool, bits: int):
    if isinstance(value, int):
        if signed:
            min_val = -(2**(bits-1))
            max_val = 2**(bits-1) - 1
        else:
            min_val = 0
            max_val = 2**bits - 1
        return min_val <= value <= max_val
    elif isinstance(value, list):
        for val in value:
            if not is_xintx(val, signed, bits):
                return False
        return True
    else:
        return False","from typing import Any

def is_xintx(value: Any, signed: bool, bits: int):
    if isinstance(value, int):
        if signed:
            min_val = -(2**(bits-1))
            max_val = 2**(bits-1) - 1
        else:
            min_val = 0
            max_val = 2**bits - 1
        return min_val <= value <= max_val
    elif isinstance(value, list):
        for val in value:
            if not is_xintx(val, signed, bits):
                return False
        return True
    else:
        return False",37.852979043082065,18.624889278736596,20.00281410937886,58.730158730158735,54.054054054054056
4,python,"def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
        for t in cls.types:
            if datatype == t[0]:
                return t
        return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_def in cls.__dict__.get(""_types"", []):
        if type_def[0] == datatype:
            return type_def
    return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_def in cls.__dict__.get(""_types"", []):
        if type_def[0] == datatype:
            return type_def
    return None",62.91007368150975,50.16993910962959,54.669008815062604,74.07407407407408,72.72727272727273
5,python,"def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if not fqn:
        return {}
    fqn_namespaced_datatypes = {}
    for t in dynamic_datatypes:
        if fqn.startswith(t):
            continue

        if fqn.startswith(""."".join(t.split(""."")[:-1])):
            fqn_namespaced_datatypes[(t.split(""."")[-1])] = t

    if fqn_namespaced_datatypes:
        log.debug(f""Namespaced datatypes, {fqn=}, {fqn_namespaced_datatypes=}"")
    return fqn_namespaced_datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    fqn_namespaced_datatypes = {
        ""int"": ""core.primitive.Int"",
        ""float"": ""core.primitive.Float"",
        ""bool"": ""core.primitive.Bool"",
        ""string"": ""core.primitive.String"",
        ""bytes"": ""core.primitive.Bytes"",
        ""list"": ""core.primitive.List"",
        ""dict"": ""core.primitive.Dict"",
        ""tuple"": ""core.primitive.Tuple"",
        ""set"": ""core.primitive.Set"",
        ""None"": ""core.primitive.None"",
    }
    if fqn is None:
        return fqn_namespaced_datatypes
    return {
        k: v
        for k, v in fqn_namespaced_datatypes.items()
        if k in fqn.split(""."")
    }","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    fqn_namespaced_datatypes = {
        ""int"": ""core.primitive.Int"",
        ""float"": ""core.primitive.Float"",
        ""bool"": ""core.primitive.Bool"",
        ""string"": ""core.primitive.String"",
        ""bytes"": ""core.primitive.Bytes"",
        ""list"": ""core.primitive.List"",
        ""dict"": ""core.primitive.Dict"",
        ""tuple"": ""core.primitive.Tuple"",
        ""set"": ""core.primitive.Set"",
        ""None"": ""core.primitive.None"",
    }
    if fqn is None:
        return fqn_namespaced_datatypes
    return {
        k: v
        for k, v in fqn_namespaced_datatypes.items()
        if k in fqn.split(""."")
    }",26.54144948780326,19.816310154938755,29.75226557405207,34.375,22.22222222222222
7,python,"def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    is_array = False
    apigear_type = None
    if t.endswith(""[]""):
        is_array = True
        t = t[0:-2]

    if t in [""int8"", ""int16"", ""int32"", ""uint8"", ""uint16"", ""uint32""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT32.value)
    elif t in [""int64"", ""uint64""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT64.value)
    elif t == ""float"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT32.value)
    elif t == ""double"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT64.value)
    elif t == ""boolean"":
        apigear_type = ApiGearType(ApiGearBasicType.BOOL.value)
    elif t == ""string"":
        apigear_type = ApiGearType(ApiGearBasicType.STRING.value)
    else:
        apigear_type = ApiGearType(t.replace(""."", ""_""))

    if is_array and apigear_type is not None:
        apigear_type.is_array = True

    return apigear_type","```python
import typing

from apigear.core.types import ApiGearType

def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    if t == ""int"":
        return ApiGearType.INT
    elif t == ""float"":
        return ApiGearType.FLOAT
    elif t == ""bool"":
        return ApiGearType.BOOL
    elif t == ""string"":
        return ApiGearType.STRING
    elif t == ""bytes"":
        return ApiGearType.BYTES
    elif t == ""uint8"":
        return ApiGearType.UINT8
    elif t == ""uint16"":
        return ApiGearType.UINT16
    elif t == ""uint32"":
        return ApiGearType.UINT32
    elif t == ""uint64"":
        return ApiGearType.UINT64
    elif t == ""int8"":
        return ApiGearType.INT8
    elif t == ""int16"":
        return ApiGearType.INT16
    elif t == ""int32"":
        return ApiGearType.INT32
    elif t == ""int64"":
        return ApiGearType.INT64
    elif t == ""date"":
        return ApiGearType.DATE
    elif t == ""datetime"":
        return ApiGearType.DATETIME
    elif t == ""time"":
        return ApiGearType.TIME
    elif t == ""enum"":
        return ApiGearType.ENUM
    elif t == ""struct"":
        return ApiGearType.STRUCT
    elif t == ""map"":
        return ApiGearType.MAP
    elif t == ""array"":
        return ApiGearType.ARRAY
    elif t.endswith(""[]""):
        t = t[:-2]
        if t == ""int"":
            return ApiGearType.INT_ARRAY
        elif t == ""float"":
            return ApiGearType.FLOAT_ARRAY
        elif t == ""bool"":
            return ApiGearType.BOOL_ARRAY
        elif t == ""string"":
            return ApiGearType.STRING_ARRAY
        elif t == ""bytes"":
            return ApiGearType.BYTES_ARRAY
        elif t == ""uint8"":
            return ApiGearType.UINT8_ARRAY
        elif t == ""uint16"":
            return ApiGearType.UINT16_ARRAY
        elif t == ""uint32"":
            return ApiGearType.UINT32_ARRAY
        elif t == ""uint64"":
            return ApiGearType.UINT64_ARRAY
        elif t == ""int8"":
            return ApiGearType.INT8_ARRAY
        elif t == ""int16"":
            return ApiGearType.INT16_ARRAY
        elif t == ""int32"":
            return ApiGearType.INT32_ARRAY
        elif t == ""int64"":
            return ApiGearType.INT64_ARRAY
        elif t == ""date"":
            return ApiGearType.DATE_ARRAY
        elif t == ""datetime"":
            return ApiGearType.DATETIME_ARRAY
        elif t == ""time"":
            return ApiGearType.TIME_ARRAY
        elif t == ""enum"":
            return ApiGearType.ENUM_ARRAY
        elif t == ""struct"":
            return ApiGearType.STRUCT_ARRAY
        elif t == ""map"":
            return ApiGearType.MAP_ARRAY
        else:
            return None
    elif ""."" in t:
        t = t.replace","```python
import typing

from apigear.core.types import ApiGearType

def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    if t == ""int"":
        return ApiGearType.INT
    elif t == ""float"":
        return ApiGearType.FLOAT
    elif t == ""bool"":
        return ApiGearType.BOOL
    elif t == ""string"":
        return ApiGearType.STRING
    elif t == ""bytes"":
        return ApiGearType.BYTES
    elif t == ""uint8"":
        return ApiGearType.UINT8
    elif t == ""uint16"":
        return ApiGearType.UINT16
    elif t == ""uint32"":
        return ApiGearType.UINT32
    elif t == ""uint64"":
        return ApiGearType.UINT64
    elif t == ""int8"":
        return ApiGearType.INT8
    elif t == ""int16"":
        return ApiGearType.INT16
    elif t == ""int32"":
        return ApiGearType.INT32
    elif t == ""int64"":
        return ApiGearType.INT64
    elif t == ""date"":
        return ApiGearType.DATE
    elif t == ""datetime"":
        return ApiGearType.DATETIME
    elif t == ""time"":
        return ApiGearType.TIME
    elif t == ""enum"":
        return ApiGearType.ENUM
    elif t == ""struct"":
        return ApiGearType.STRUCT
    elif t == ""map"":
        return ApiGearType.MAP
    elif t == ""array"":
        return ApiGearType.ARRAY
    elif t.endswith(""[]""):
        t = t[:-2]
        if t == ""int"":
            return ApiGearType.INT_ARRAY
        elif t == ""float"":
            return ApiGearType.FLOAT_ARRAY
        elif t == ""bool"":
            return ApiGearType.BOOL_ARRAY
        elif t == ""string"":
            return ApiGearType.STRING_ARRAY
        elif t == ""bytes"":
            return ApiGearType.BYTES_ARRAY
        elif t == ""uint8"":
            return ApiGearType.UINT8_ARRAY
        elif t == ""uint16"":
            return ApiGearType.UINT16_ARRAY
        elif t == ""uint32"":
            return ApiGearType.UINT32_ARRAY
        elif t == ""uint64"":
            return ApiGearType.UINT64_ARRAY
        elif t == ""int8"":
            return ApiGearType.INT8_ARRAY
        elif t == ""int16"":
            return ApiGearType.INT16_ARRAY
        elif t == ""int32"":
            return ApiGearType.INT32_ARRAY
        elif t == ""int64"":
            return ApiGearType.INT64_ARRAY
        elif t == ""date"":
            return ApiGearType.DATE_ARRAY
        elif t == ""datetime"":
            return ApiGearType.DATETIME_ARRAY
        elif t == ""time"":
            return ApiGearType.TIME_ARRAY
        elif t == ""enum"":
            return ApiGearType.ENUM_ARRAY
        elif t == ""struct"":
            return ApiGearType.STRUCT_ARRAY
        elif t == ""map"":
            return ApiGearType.MAP_ARRAY
        else:
            return None
    elif ""."" in t:
        t = t.replace",18.03196158249872,4.558710557571624,15.153641793023867,32.743362831858406,19.672131147540984
8,python,"def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    apigear_type = get_apigear_datatype(datatype)
    data = node.get_vss_data()

    if apigear_type is None:
        log.warning(f""Datatype {datatype} of node {node.name} currently not supported"")
        return None

    property = ApiGearProperty(apigear_type)
    if data.description != """":
        property.description = data.description
    return property","def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if datatype == ""int"":
        api_type = ""int32""
    elif datatype == ""float"":
        api_type = ""float""
    elif datatype == ""bool"":
        api_type = ""bool""
    elif datatype == ""string"":
        api_type = ""string""
    elif datatype == ""uint8"":
        api_type = ""uint8""
    elif datatype == ""uint16"":
        api_type = ""uint16""
    elif datatype == ""uint32"":
        api_type = ""uint32""
    elif datatype == ""uint64"":
        api_type = ""uint64""
    elif datatype == ""int8"":
        api_type = ""int8""
    elif datatype == ""int16"":
        api_type = ""int16""
    elif datatype == ""int64"":
        api_type = ""int64""
    elif datatype == ""byte"":
        api_type = ""byte""
    elif datatype == ""enum"":
        api_type = ""enum""
    elif datatype == ""struct"":
        api_type = ""struct""
    elif datatype == ""array"":
        api_type = ""array""
    else:
        logging.warning(f""Unsupported datatype: {datatype}"")
        return None

    return ApiGearProperty(
        name=node.name,
        datatype=api_type,
        description=node.description,
    )","def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if datatype == ""int"":
        api_type = ""int32""
    elif datatype == ""float"":
        api_type = ""float""
    elif datatype == ""bool"":
        api_type = ""bool""
    elif datatype == ""string"":
        api_type = ""string""
    elif datatype == ""uint8"":
        api_type = ""uint8""
    elif datatype == ""uint16"":
        api_type = ""uint16""
    elif datatype == ""uint32"":
        api_type = ""uint32""
    elif datatype == ""uint64"":
        api_type = ""uint64""
    elif datatype == ""int8"":
        api_type = ""int8""
    elif datatype == ""int16"":
        api_type = ""int16""
    elif datatype == ""int64"":
        api_type = ""int64""
    elif datatype == ""byte"":
        api_type = ""byte""
    elif datatype == ""enum"":
        api_type = ""enum""
    elif datatype == ""struct"":
        api_type = ""struct""
    elif datatype == ""array"":
        api_type = ""array""
    else:
        logging.warning(f""Unsupported datatype: {datatype}"")
        return None

    return ApiGearProperty(
        name=node.name,
        datatype=api_type,
        description=node.description,
    )",28.59208045954107,7.191729459524515,23.843259045306432,33.33333333333333,50.0
10,python,"def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    spec = None
    vspecs: list[VSpec] = []
    for s in specs:
        includes = [s.parent] + include_dirs
        vspecs.extend(get_vspecs(includes, s))
    pre = ""VSpecs""
    if identifier:
        pre += f"" ({identifier})""
    log.info(f""{pre} loaded, amount={len(vspecs)}"")
    for vspec in vspecs:
        log.debug(vspec)
        if spec is None:
            spec = vspec
        else:
            spec.update(vspec)
    if not spec:
        msg = f""Weird behavior. Could not load any spec: {specs}""
        log.error(msg)
        raise SpecException(msg)
    return spec","from pathlib import Path
from typing import List, Optional

from vspec.vspec import VSpec
from vspec.vspec_parser import VSpecParser
from vspec.vspec_loader import VSpecLoader


def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    """"""Loads and parses multiple VSpec files from specified paths, using a list of include directories,
    then merges them into a single composite VSpec object and returns it, raising an exception if no
    files are successfully loaded""""""
    loader = VSpecLoader(include_dirs)
    loaded_specs = []
    for spec_path in specs:
        try:
            loaded_specs.append(loader.load_vspec(spec_path))
        except Exception as e:
            raise ValueError(f""Failed to load VSpec file {spec_path}: {e}"")

    if not loaded_specs:
        raise ValueError(""No VSpec files were successfully loaded"")

    parser = VSpecParser()
    merged_spec = parser.merge_specs(loaded_specs, identifier)
    return merged_spec","from pathlib import Path
from typing import List, Optional

from vspec.vspec import VSpec
from vspec.vspec_parser import VSpecParser
from vspec.vspec_loader import VSpecLoader


def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    """"""Loads and parses multiple VSpec files from specified paths, using a list of include directories,
    then merges them into a single composite VSpec object and returns it, raising an exception if no
    files are successfully loaded""""""
    loader = VSpecLoader(include_dirs)
    loaded_specs = []
    for spec_path in specs:
        try:
            loaded_specs.append(loader.load_vspec(spec_path))
        except Exception as e:
            raise ValueError(f""Failed to load VSpec file {spec_path}: {e}"")

    if not loaded_specs:
        raise ValueError(""No VSpec files were successfully loaded"")

    parser = VSpecParser()
    merged_spec = parser.merge_specs(loaded_specs, identifier)
    return merged_spec",32.43278202353639,13.533596241552514,21.908126167838518,47.77777777777778,46.51162790697674
11,python,"def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if isinstance(value, dict):
            if key in base and isinstance(base[key], dict):
                deep_update(base[key], value)
            else:
                base[key] = value
        else:
            base[key] = value","def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for k, v in update.items():
        if isinstance(v, dict) and k in base and isinstance(base[k], dict):
            deep_update(base[k], v)
        else:
            base[k] = v","def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for k, v in update.items():
        if isinstance(v, dict) and k in base and isinstance(base[k], dict):
            deep_update(base[k], v)
        else:
            base[k] = v",61.09433177212898,35.2397286283442,37.262598460171745,81.25,90.625
12,python,"def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return v
    pattern = r""^0x[0-9A-Fa-f]{8}$""
    assert bool(re.match(pattern, v)), f""'{v}' is not a valid 'constUID'""
    return v","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in ""0123456789abcdef"" for c in v[2:]):
        return v
    return None","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in ""0123456789abcdef"" for c in v[2:]):
        return v
    return None

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.
def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in ""0123456789abcdef"" for c in v[2:]):
        return v
    return None

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.
def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in ""0123456789abcdef"" for c in v[2:]):
        return v
    return None

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.
def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in ""0123456789abcdef"" for c in v[2:]):
        return v
    return None

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.
def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in ""0123456789abcdef"" for c in v[2:]):
        return v
    return None

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output.
def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if isinstance(v, str) and len(v) == 10 and v.startswith(""0x"") and all(c in ""0123456789abcdef"" for c in v[2:]):
        return v
    return None

Review the generated code and the task instructions.",53.00979747473712,39.801862783019985,50.2373271159285,52.0,70.0
13,python,"def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw(fqn=fqn, **data)
    try:
        model = resolve_vss_raw(model)
    except (ValidationError, ModelException):
        log.debug(f""'{fqn}', incomplete, initialized as '{model.__class__.__name__}'"")
        return model
    return model","from typing import Any

from vss.core.vssraw import VSSRaw


def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    vss_raw = VSSRaw(data)
    if fqn:
        vss_raw.resolve(fqn)
    return vss_raw","from typing import Any

from vss.core.vssraw import VSSRaw


def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    vss_raw = VSSRaw(data)
    if fqn:
        vss_raw.resolve(fqn)
    return vss_raw",44.00682229461464,30.894082456907405,30.96654005488453,47.5,66.66666666666666
14,python,"def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    datatypes = get_all_datatypes()
    for value in values:
        assert value in datatypes, f""Invalid datatype: '{value}'""
    return values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_datatypes = [""int"", ""float"", ""str"", ""bool""]
    for value in values:
        if value not in valid_datatypes:
            raise ValueError(f""Invalid datatype: {value}"")
    return values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_datatypes = [""int"", ""float"", ""str"", ""bool""]
    for value in values:
        if value not in valid_datatypes:
            raise ValueError(f""Invalid datatype: {value}"")
    return values",47.270146323358716,30.096870722978437,38.150381237123135,54.166666666666664,66.66666666666666
15,python,"def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    tree_content_lines = []
    for pre, fill, node in RenderTree(tree):
        tree_content_lines.append(""%s%s"" % (pre, node.name))
        for attribute in attributes:
            content = getattr(node.data, attribute, None)
            if content is None:
                continue
            if isinstance(content, str):
                tree_content_lines.append(""%s%s='%s'"" % (fill, attribute, content))
            else:
                tree_content_lines.append(""%s%s=%s"" % (fill, attribute, content))
    return ""\n"".join(tree_content_lines)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    def render_node(node: VSSNode, indent: int) -> str:
        result = ""  "" * indent + node.name + ""\n""
        for attr in attributes:
            if hasattr(node, attr):
                result += ""  "" * (indent + 1) + f""{attr}: {getattr(node, attr)}\n""
        for child in node.children:
            result += render_node(child, indent + 1)
        return result

    return render_node(tree, 0)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    def render_node(node: VSSNode, indent: int) -> str:
        result = ""  "" * indent + node.name + ""\n""
        for attr in attributes:
            if hasattr(node, attr):
                result += ""  "" * (indent + 1) + f""{attr}: {getattr(node, attr)}\n""
        for child in node.children:
            result += render_node(child, indent + 1)
        return result

    return render_node(tree, 0)",24.862253356908727,11.983713904037705,15.683923005378581,32.30769230769231,39.473684210526315
16,python,"def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not isinstance(self.data, VSSDataBranch):
        raise NoInstanceRootException()

    if not self.data.is_instance:
        return self, depth

    if self.parent is None:
        raise NoInstanceRootException()

    return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not self.is_branch:
        raise ValueError(""Starting node is not a branch"")

    if self.parent is None:
        return self, depth

    if self.parent.is_instance:
        return self.parent, depth + 1

    return get_instance_root(self.parent, depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not self.is_branch:
        raise ValueError(""Starting node is not a branch"")

    if self.parent is None:
        return self, depth

    if self.parent.is_instance:
        return self.parent, depth + 1

    return get_instance_root(self.parent, depth + 1)",55.19816347497783,41.596990634096706,52.748294844762015,47.5,78.94736842105263
17,python,"def count_instance_children_depth(self) -> int:
    for child in self.children:
        if isinstance(child.data, VSSDataBranch):
            if child.data.is_instance:
                return 1 + child.count_instance_children_depth()
    return 0","def count_instance_children_depth(self) -> int:
    if not self.children:
        return 0
    for child in self.children:
        if isinstance(child, VSSDataBranch) and child.is_instance:
            return 1 + count_instance_children_depth(child)
    return 0","def count_instance_children_depth(self) -> int:
    if not self.children:
        return 0
    for child in self.children:
        if isinstance(child, VSSDataBranch) and child.is_instance:
            return 1 + count_instance_children_depth(child)
    return 0",47.76287801690429,32.077142814517714,42.825300930118075,30.434782608695656,85.71428571428571
18,python,"def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    ids = []
    for i in node_ids:
        if get_expected_parent(i) == name:
            ids.append(i)
    return ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        if node_id.split('_')[1] == name:
            children_ids.append(node_id)
    return children_ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        parts = node_id.split('_')
        if len(parts) > 1 and parts[1] == name:
            children_ids.append(node_id)
    return children_ids",65.24065932875062,43.03767738122004,44.591626600449125,73.33333333333333,100.0
19,python,"def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    result = getattr(o, name, default)
    if result is None and default is not None:
        result = default
    return result","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        return getattr(o, name)
    except AttributeError:
        return default","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        return getattr(o, name)
    except AttributeError:
        return default",42.338134767853695,36.67473999422677,37.67779907718803,41.66666666666667,53.333333333333336
20,python,"def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    fd.write('syntax = ""proto3"";\n\n')

    imports = []
    for node in findall(tree, filter_=lambda n: isinstance(n.data, VSSDataDatatype)):
        datatype = node.data.datatype
        if ""."" not in datatype:
            continue
        struct_path = Path(node.data.datatype.replace(""."", ""/""))  # type: ignore
        imports.append(f""{struct_path.parent}/{struct_path.parent.name}.proto"")
    write_imports(fd, imports)

    # write proto messages to file
    for node in findall(tree, filter_=lambda node: isinstance(node.data, VSSDataBranch)):
        fd.write(f""message {node.get_fqn('')} {{"" + ""\n"")
        print_messages(node.children, fd, static_uid, add_optional)
        fd.write(""}\n\n"")","```python
def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""complex"":
        fd.write(f""import {tree.name} from '{tree.module}.proto'\n"")
    if tree.type == ""branch"":
        fd.write(f""{tree.name} = {tree.name}()\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
    elif tree.type == ""signal"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""signal"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""field"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""field"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""array"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""array"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""map"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""map"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""enum"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""enum"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""message"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree","```python
def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""complex"":
        fd.write(f""import {tree.name} from '{tree.module}.proto'\n"")
    if tree.type == ""branch"":
        fd.write(f""{tree.name} = {tree.name}()\n"")
        for child in tree.children:
            traverse_signal_tree(child, fd, static_uid, add_optional)
    elif tree.type == ""signal"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""signal"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""field"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""field"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""array"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""array"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""map"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""map"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""enum"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree.name}.optional = True\n"")
        if static_uid:
            fd.write(f""    {tree.name}.uid = '{tree.uid}'\n"")
        if tree.type == ""enum"":
            fd.write(f""    {tree.name}.value = {tree.value}\n"")
    elif tree.type == ""message"":
        fd.write(f""    {tree.name} = {tree.name}()\n"")
        if add_optional:
            fd.write(f""    {tree",23.154350611048997,5.325626467229704,15.833204002930405,28.865979381443296,42.592592592592595
21,python,"def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    meta: dict[str, list[str]] = {}
    for node in PreOrderIter(root, filter_=lambda n: isinstance(n.data, VSSDataBranch) and n.data.is_instance):
        if any(c.data.is_instance for c in node.children if isinstance(c.data, VSSDataBranch)):
            continue
        instance_root, _ = node.get_instance_root()
        instance_root_fqn = instance_root.get_fqn()

        instance_name = node.get_fqn().removeprefix(instance_root_fqn + ""."")

        if instance_root_fqn in meta:
            meta[instance_root_fqn].append(instance_name)
        else:
            meta[instance_root_fqn] = [instance_name]
    return meta","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    def traverse(node: VSSNode, path: list[str]):
        if node.is_terminal():
            instances[path[-1]] = instances.get(path[-1], []) + [node.name]
        else:
            for child in node.children:
                traverse(child, path + [child.name])
    traverse(root, [])
    return instances","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    def traverse(node: VSSNode, path: list[str]):
        if node.is_terminal():
            instances[path[-1]] = instances.get(path[-1], []) + [node.name]
        else:
            for child in node.children:
                traverse(child, path + [child.name])
    traverse(root, [])
    return instances",24.607050847743057,9.949319039303774,11.514305416646176,40.229885057471265,36.734693877551024
22,python,"def is_VSS_leaf(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataDatatype):
        return True
    return False","def is_VSS_leaf(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataDatatype)","def is_VSS_leaf(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataDatatype)",53.95251422009305,34.1077254951379,31.7023313852343,50.0,100.0
23,python,"def is_VSS_branch(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataBranch):
        if not node.data.is_instance:
            return True
    return False","def is_VSS_branch(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataBranch) and not node.is_instance","def is_VSS_branch(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataBranch) and not node.is_instance",38.92121923202306,27.429553970075617,26.150059800121895,42.10526315789473,60.0
24,python,"def is_VSS_branch_instance(node: VSSNode) -> bool:
    if isinstance(node.data, VSSDataBranch):
        if node.data.is_instance:
            return True
    return False","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataBranch) and node.data.is_instance","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return isinstance(node.data, VSSDataBranch) and node.data.is_instance",51.30668508661355,28.641904579795412,26.584835766658777,50.0,100.0
25,python,"def fnv1_32_hash(identifier: bytes) -> int:
    id_hash = 2166136261
    for byte in identifier:
        id_hash = (id_hash * 16777619) & 0xFFFFFFFF
        id_hash ^= byte

    return id_hash","def fnv1_32_hash(identifier: bytes) -> int:
    FNV_PRIME = 0x01000193
    offset_basis = 0x811C9DC5
    hash = offset_basis
    for byte in identifier:
        hash *= FNV_PRIME
        hash ^= byte
    return hash","def fnv1_32_hash(identifier: bytes) -> int:
    FNV_PRIME = 0x01000193
    offset_basis = 0x811C9DC5
    hash = offset_basis
    for byte in identifier:
        hash = (hash * FNV_PRIME) ^ byte
    return hash",34.566342776006245,28.196659117306076,32.700290934087334,47.368421052631575,30.0
28,java,"public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
    mRootView = inflater.inflate(R.layout.card_fragment, container, false);
    mCardTitle = mRootView.findViewById(R.id.card_name);
    mCardIcon = mRootView.findViewById(R.id.card_icon);
    return mRootView;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View root = inflater.inflate(R.layout.card_fragment, container, false);
    TextView cardTitle = (TextView) root.findViewById(R.id.card_title);
    ImageView cardIcon = (ImageView) root.findViewById(R.id.card_icon);
    cardTitle.setText(getArguments().getString(""title""));
    cardIcon.setImageResource(getArguments().getInt(""icon""));
    return root;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View root = inflater.inflate(R.layout.card_fragment, container, false);
    TextView cardTitle = (TextView) root.findViewById(R.id.card_title);
    ImageView cardIcon = (ImageView) root.findViewById(R.id.card_icon);
    cardTitle.setText(getArguments().getString(""title""));
    cardIcon.setImageResource(getArguments().getInt(""icon""));
    return root;
}",58.665038278821946,36.58350203979106,49.591802590648214,66.66666666666666,81.81818181818183
29,java,"private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent,
        ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageDrawable(buttonContent.getIcon());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
    if (buttonContent == null) {
        buttonView.setVisibility(View.GONE);
    } else {
        buttonView.setImageResource(buttonContent.getDrawable());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
    if (buttonContent == null) {
        buttonView.setVisibility(View.GONE);
    } else {
        buttonView.setImageResource(buttonContent.getDrawable());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 5;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 3;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n",76.78865729191429,59.69491792019645,60.36293705391236,87.09677419354838,100.0
30,java,"protected final View getDescriptiveTextOnlyLayoutView() {
    if (mDescriptiveTextOnlyLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.descriptive_text_layout);
        mDescriptiveTextOnlyLayoutView = stub.inflate();
        mDescriptiveTextOnlyTitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.primary_text);
        mDescriptiveTextOnlySubtitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.secondary_text);
        mDescriptiveTextOnlyOptionalImage = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.optional_image);
        mDescriptiveTextOnlyTapForMore = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.tap_for_more_text);
    }
    return mDescriptiveTextOnlyLayoutView;
}","protected final View getDescriptiveTextOnlyLayoutView() {
    ViewStub viewStub = (ViewStub) findViewById(R.layout.descriptive_text_only);
    View inflatedView = viewStub.inflate();
    TextView title = (TextView) inflatedView.findViewById(R.id.title);
    TextView subtitle = (TextView) inflatedView.findViewById(R.id.subtitle);
    ImageView image = (ImageView) inflatedView.findViewById(R.id.image);
    viewStub.setLayout(inflatedView);
    return inflatedView;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (","protected final View getDescriptiveTextOnlyLayoutView() {
    ViewStub viewStub = (ViewStub) findViewById(R.layout.descriptive_text_only);
    View inflatedView = viewStub.inflate();
    TextView title = (TextView) inflatedView.findViewById(R.id.title);
    TextView subtitle = (TextView) inflatedView.findViewById(R.id.subtitle);
    ImageView image = (ImageView) inflatedView.findViewById(R.id.image);
    viewStub.setLayout(inflatedView);
    return inflatedView;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (",31.005420542953456,1.3673097988375869,15.83619055479441,56.81818181818182,50.0
31,java,"public void updateHeaderView(CardHeader header) {
    requireActivity().runOnUiThread(() -> {
        mRootView.setVisibility(View.VISIBLE);
        mCardTitle.setText(header.getCardTitle());
        mCardIcon.setImageDrawable(header.getCardIcon());
    });
}","public void updateHeaderView(CardHeader header) {
    headerView.getRootView().setVisibility(View.VISIBLE);
    headerView.setTitle(header.getTitle());
    headerView.setIcon(header.getIcon());
}","public void updateHeaderView(CardHeader header) {
    headerView.getRootView().setVisibility(View.VISIBLE);
    headerView.setTitle(header.getTitle());
    headerView.setIcon(header.getIcon());
}",55.068900543077916,29.95197100101508,33.18077402843942,57.14285714285714,100.0
32,java,"private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.text_block_layout);
        mTextBlockLayoutView = stub.inflate();
        mTextBlock = mTextBlockLayoutView.findViewById(R.id.text_block);
        mTextBlockTapForMore = mTextBlockLayoutView.findViewById(R.id.tap_for_more_text);
    }
    return mTextBlockLayoutView;
}","private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = LayoutInflater.from(mContext).inflate(R.layout.text_block_layout, this, false);
        mTextView = (TextView) mTextBlockLayoutView.findViewById(R.id.text_block_text);
        mTextView.setText(mText);
        mTextView.setOnClickListener(this);
        mTextView.setLongClickable(true);
        mTextView.setMovementMethod(new ScrollingTextWatcher());
        mTextView.setScrollBarStyle(View.SCROLLBARS_INSIDE_OUTSIDE);
        mTextView.setPadding(mPaddingLeft, mPaddingTop, mPaddingRight, mPaddingBottom);
        mTextView.setTextSize(mTextSize);
        mTextView.setTypeface(mTypeface);
        mTextView.setTextColor(mTextColor);
        mTextView.setTextIsSelectable(mTextIsSelectable);
        mTextView.setHorizontallyScrolling(mHorizontallyScrolling);
        mTextView.setLines(mLines);
        mTextView.setSingleLine(mSingleLine);
        mTextView.setEllipsize(mEllipsize);
        mTextView.setGravity(mGravity);
        mTextView.setIncludeFontPadding(mIncludeFontPadding);
        mTextView.setLineSpacing(mLineSpacingExtra, mLineSpacingMultiplier);
        mTextView.setLinkTextColor(mLinkTextColor);
        mTextView.setLinkClickable(mLinkClickable);
        mTextView.setLinkMovementMethod(mLinkMovementMethod);
        mTextView.setHighlightColor(mHighlightColor);
        mTextView.setHighlightColorHsv(mHighlightColorHsv);
        mTextView.setHighlightColorAlpha(mHighlightColorAlpha);
        mTextView.setHighlightColorGradient(mHighlightColorGradient);
        mTextView.setHighlightColorGradientAlpha(mHighlightColorGradientAlpha);
        mTextView.setHighlightColorGradientStartColor(mHighlightColorGradientStartColor);
        mTextView.setHighlightColorGradientEndColor(mHighlightColorGradientEndColor);
        mTextView.setHighlightColorGradientCenterColor(mHighlightColorGradientCenterColor);
        mTextView.setHighlightColorGradientStartOffset(mHighlightColorGradientStartOffset);
        mTextView.setHighlightColorGradientEndOffset(mHighlightColorGradientEndOffset);
        mTextView.setHighlightColorGradientCenterOffset(mHighlightColorGradientCenterOffset);
        mTextView.setHighlightColorGradientStartAlpha(mHighlightColorGradientStartAlpha);
        mTextView.setHighlightColorGradientEndAlpha(mHighlightColorGradientEndAlpha);
        mTextView.setHighlightColorGradientCenterAlpha(mHighlightColorGradientCenterAlpha);
        mTextView.setHighlightColorGradientStartColorAlpha(mHighlightColorGradientStartColorAlpha);
        mTextView.setHighlightColorGradientEndColorAlpha(mHighlightColorGradientEndColorAlpha);
        mTextView.setHighlightColorGradientCenterColorAlpha(mHighlightColorGradientCenterColorAlpha);
        mTextView.setHighlightColorGradientStartColorAlpha(mHighlightColorGradientStartColorAlpha);
        mTextView.setHighlightColorGradientEndColorAlpha(mHighlightColorGradientEndColorAlpha);
        mTextView.setHighlightColorGradientCenterColorAlpha(mHighlightColorGradientCenterColorAlpha);
        mTextView.setHighlightColorGradientStartColorAlpha(mHighlightColorGradientStartColorAlpha);
        mTextView.setHighlightColorGradientEndColorAlpha(mHighlightColorGradientEndColorAlpha);
        mTextView.setHighlightColorGradientCenterColorAlpha(mHighlightColorGradientCenterColorAlpha);
        mTextView","private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = LayoutInflater.from(mContext).inflate(R.layout.text_block_layout, this, false);
        mTextView = (TextView) mTextBlockLayoutView.findViewById(R.id.text_block_text);
        mTextView.setText(mText);
        mTextView.setOnClickListener(this);
        mTextView.setLongClickable(true);
        mTextView.setMovementMethod(new ScrollingTextWatcher());
        mTextView.setScrollBarStyle(View.SCROLLBARS_INSIDE_OUTSIDE);
        mTextView.setPadding(mPaddingLeft, mPaddingTop, mPaddingRight, mPaddingBottom);
        mTextView.setTextSize(mTextSize);
        mTextView.setTypeface(mTypeface);
        mTextView.setTextColor(mTextColor);
        mTextView.setTextIsSelectable(mTextIsSelectable);
        mTextView.setHorizontallyScrolling(mHorizontallyScrolling);
        mTextView.setLines(mLines);
        mTextView.setSingleLine(mSingleLine);
        mTextView.setEllipsize(mEllipsize);
        mTextView.setGravity(mGravity);
        mTextView.setIncludeFontPadding(mIncludeFontPadding);
        mTextView.setLineSpacing(mLineSpacingExtra, mLineSpacingMultiplier);
        mTextView.setLinkTextColor(mLinkTextColor);
        mTextView.setLinkClickable(mLinkClickable);
        mTextView.setLinkMovementMethod(mLinkMovementMethod);
        mTextView.setHighlightColor(mHighlightColor);
        mTextView.setHighlightColorHsv(mHighlightColorHsv);
        mTextView.setHighlightColorAlpha(mHighlightColorAlpha);
        mTextView.setHighlightColorGradient(mHighlightColorGradient);
        mTextView.setHighlightColorGradientAlpha(mHighlightColorGradientAlpha);
        mTextView.setHighlightColorGradientStartColor(mHighlightColorGradientStartColor);
        mTextView.setHighlightColorGradientEndColor(mHighlightColorGradientEndColor);
        mTextView.setHighlightColorGradientCenterColor(mHighlightColorGradientCenterColor);
        mTextView.setHighlightColorGradientStartOffset(mHighlightColorGradientStartOffset);
        mTextView.setHighlightColorGradientEndOffset(mHighlightColorGradientEndOffset);
        mTextView.setHighlightColorGradientCenterOffset(mHighlightColorGradientCenterOffset);
        mTextView.setHighlightColorGradientStartColorAlpha(mHighlightColorGradientStartColorAlpha);
        mTextView.setHighlightColorGradientEndColorAlpha(mHighlightColorGradientEndColorAlpha);
        mTextView.setHighlightColorGradientCenterColorAlpha(mHighlightColorGradientCenterColorAlpha);
        mTextView.setHighlightColorGradientStartColorAlpha(mHighlightColorGradientStartColorAlpha);
        mTextView.setHighlightColorGradientEndColorAlpha(mHighlightColorGradientEndColorAlpha);
        mTextView.setHighlightColorGradientCenterColorAlpha(mHighlightColorGradientCenterColorAlpha);
    }
    return mTextBlockLayoutView;
}

Review the generated code and the task instructions.
Modify or improve the code if necessary.
Return the improved code, or the original code if no changes are needed.
Do not provide any other output
```java
private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = LayoutInflater.from(mContext).inflate(R.layout.text_block_layout, this, false);
        mTextView = (TextView) mTextBlockLayoutView.",36.44039909219599,12.531130254014425,34.650920660224074,53.125,45.45454545454545
33,java,"static ComponentName getMediaSource(@NonNull PackageManager packageManager,
        @NonNull String packageName) {
    Intent mediaIntent = new Intent();
    mediaIntent.setPackage(packageName);
    mediaIntent.setAction(MediaBrowserService.SERVICE_INTERFACE);

    List<ResolveInfo> mediaServices = packageManager.queryIntentServices(mediaIntent,
            PackageManager.GET_RESOLVED_FILTER);

    if (mediaServices == null || mediaServices.isEmpty()) {
        return null;
    }
    String defaultService = mediaServices.get(0).serviceInfo.name;
    if (!TextUtils.isEmpty(defaultService)) {
        return new ComponentName(packageName, defaultService);
    }
    return null;
}","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {
    Intent intent = new Intent(MediaBrowserService.SERVICE_INTERFACE);
    intent.setPackage(packageName);
    List<ResolveInfo> services = packageManager.queryIntentServices(intent, null);
    if (services.isEmpty()) {
        return null;
    }
    return services.get(0).serviceInfo.getComponentName();
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    max_sum = ((incl > excl) ? incl : excl);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            cout << ""x is a majority element"" << endl;
            return 0;
        }
    }
    cout << ""x is not a majority element"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int diff = 2;

    int size = arr.size();
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return 0;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    int incl = arr[0];","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {
    Intent intent = new Intent(MediaBrowserService.SERVICE_INTERFACE);
    intent.setPackage(packageName);
    List<ResolveInfo> services = packageManager.queryIntentServices(intent, null);
    if (services.isEmpty()) {
        return null;
    }
    return services.get(0).serviceInfo.getComponentName();
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    max_sum = ((incl > excl) ? incl : excl);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            cout << ""x is a majority element"" << endl;
            return 0;
        }
    }
    cout << ""x is not a majority element"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int diff = 2;

    int size = arr.size();
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return 0;
        } else if (arr[j] - arr[i] < diff) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    int incl = arr[0];
    int excl = 0;",35.71798227345714,3.75164999148591,31.03402573307042,50.943396226415096,57.14285714285714
34,java,"private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    switch (componentAppType) {
        case APP_TYPE_MEDIA_SERVICES:
            if (customMediaComponents.contains(componentName.flattenToString())
                    && (appTypesToShow & APP_TYPE_LAUNCHABLES) != 0) {
                return false;
            }
            return true;
        case APP_TYPE_LAUNCHABLES:
            return true;
        default:
            Log.e(TAG, ""Invalid componentAppType : "" + componentAppType);
            return false;
    }
}","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    if ((appTypesToShow & AppTypes.LAUNCHABLE) != 0 &&
            (componentAppType & AppTypes.MEDIA_SERVICE) != 0 &&
            customMediaComponents.contains(componentName.getClassName())) {
        return false;
    }
    return true;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    for (int i = 0; i < (1 << n); i++) {
        int current_sum = 0;
        bool is_valid = true;
        for (int j = 0; j < n; j++) {
            if ((i >> j) & 1) {
                if (j > 0 && (i >> (j - 1)) & 1) {
                    is_valid = false;
                    break;
                }
                current_sum += arr[j];
            }
        }
        if (is_valid) {
            max_sum = max(max_sum, current_sum);
        }
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    for (int i = 0; i < (1 << n); i++) {
        int current_sum = 0;
        bool is_valid = true;
        for (int j = 0; j < n; j++) {
            if ((i >> j) & 1) {
                if (j > 0 && (i >> (j - 1)) & 1) {
                    is_valid = false;
                    break;
                }
                current_sum += arr[j];
            }
        }
        if (is_valid) {
            max_sum = max(max_sum, current_sum);
        }
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    for (int i = 0; i < (1 << n); i++) {
        int current_sum = 0;
        bool is_valid = true;
        for (int j = 0; j < n; j++) {
            if ((i >> j) & 1) {","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    if ((appTypesToShow & AppTypes.LAUNCHABLE) != 0 &&
            (componentAppType & AppTypes.MEDIA_SERVICE) != 0 &&
            customMediaComponents.contains(componentName.getClassName())) {
        return false;
    }
    return true;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    for (int i = 0; i < (1 << n); i++) {
        int current_sum = 0;
        bool is_valid = true;
        for (int j = 0; j < n; j++) {
            if ((i >> j) & 1) {
                if (j > 0 && (i >> (j - 1)) & 1) {
                    is_valid = false;
                    break;
                }
                current_sum += arr[j];
            }
        }
        if (is_valid) {
            max_sum = max(max_sum, current_sum);
        }
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    for (int i = 0; i < (1 << n); i++) {
        int current_sum = 0;
        bool is_valid = true;
        for (int j = 0; j < n; j++) {
            if ((i >> j) & 1) {
                if (j > 0 && (i >> (j - 1)) & 1) {
                    is_valid = false;
                    break;
                }
                current_sum += arr[j];
            }
        }
        if (is_valid) {
            max_sum = max(max_sum, current_sum);
        }
    }

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    for (int i = 0; i < (1 << n); i++) {
        int current_sum = 0;
        bool is_valid = true;
        for (int j = 0; j < n; j++) {
            if ((i >> j) & 1) {",57.19916437547392,9.159673071093804,52.970317764135174,71.42857142857143,95.23809523809523
35,java,"private static void selectMediaSourceAndFinish(Context context, ComponentName componentName,
        CarMediaManager carMediaManager) {
    try {
        carMediaManager.setMediaSource(componentName, CarMediaManager.MEDIA_SOURCE_MODE_BROWSE);
        if (context instanceof Activity) {
            ((Activity) context).finish();
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected"", e);
    }
}","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
    carMediaManager.setMediaSource(componentName);
    if (context instanceof Activity) {
        try {
            ((Activity) context).finish();
        } catch (CarNotConnectedException e) {
            Log.e(""CarMediaManager"", ""Car service unavailable"", e);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
    carMediaManager.setMediaSource(componentName);
    if (context instanceof Activity) {
        try {
            ((Activity) context).finish();
        } catch (CarNotConnectedException e) {
            Log.e(""CarMediaManager"", ""Car service unavailable"", e);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl",54.83399922409217,5.047116605491783,62.67597706507044,51.61290322580645,100.0
36,java,"static boolean isActivityDistractionOptimized(
        CarPackageManager carPackageManager, String packageName, String activityName) {
    boolean isDistractionOptimized = false;
    try {
        if (carPackageManager != null) {
            isDistractionOptimized =
                    carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected when getting DO info"", e);
    }
    return isDistractionOptimized;
}","boolean isOptimized = false;
    try {
        isOptimized = carPackageManager.isActivityDistractionOptimized(packageName, activityName);
    } catch (CarNotConnectedException e) {
        Log.e(""CarPackageManager"", ""Car not connected: "" + e.getMessage());
    } catch (NullPointerException e) {
        Log.e(""CarPackageManager"", ""CarPackageManager is null"");
    }
    return isOptimized;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    int incl = arr[0];
    int excl = 0;
    int excl_new;

    for (int i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    max_sum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool is_majority = false;
    int x = 3;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            is_majority = true;
            break;
        }
    }

    if (is_majority) {
        cout << ""3 is a majority element"" << endl;
    } else {
        cout << ""3 is not a majority element"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int i = 0, j = 1;
    bool found = false;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == 2) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            found = true;
            break;
        } else if (arr[j] - arr[i] < 2) {
            j++;
        } else {
            i++;
        }
    }

    if (!found) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2,","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
    boolean isOptimized = false;
    try {
        isOptimized = carPackageManager.isActivityDistractionOptimized(packageName, activityName);
    } catch (CarNotConnectedException e) {
        Log.e(""CarPackageManager"", ""Car not connected: "" + e.getMessage());
    } catch (NullPointerException e) {
        Log.e(""CarPackageManager"", ""CarPackageManager is null"");
    }
    return isOptimized;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int max_sum = 0;
    int incl = arr[0];
    int excl = 0;
    int excl_new;

    for (int i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    max_sum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool is_majority = false;
    int x = 3;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            is_majority = true;
            break;
        }
    }

    if (is_majority) {
        cout << ""3 is a majority element"" << endl;
    } else {
        cout << ""3 is not a majority element"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int i = 0, j = 1;
    bool found = false;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == 2) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            found = true;
            break;
        } else if (arr[j] - arr[i] < 2) {
            j++;
        } else {
            i++;
        }
    }

    if (!found) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int",30.37997441581518,2.7333552334041977,23.712650804240763,37.93103448275862,57.14285714285714
38,java,"private Intent getMapsIntent() {
    Intent defaultIntent =
            Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MAPS);
    PackageManager pm = getPackageManager();
    ComponentName defaultActivity = defaultIntent.resolveActivity(pm);

    for (String intentUri : getResources().getStringArray(
            R.array.config_homeCardPreferredMapActivities)) {
        Intent preferredIntent;
        try {
            preferredIntent = Intent.parseUri(intentUri, Intent.URI_ANDROID_APP_SCHEME);
        } catch (URISyntaxException se) {
            Log.w(TAG, ""Invalid intent URI in config_homeCardPreferredMapActivities"", se);
            continue;
        }

        if (defaultActivity != null && !defaultActivity.getPackageName().equals(
                preferredIntent.getPackage())) {
            continue;
        }

        if (preferredIntent.resolveActivityInfo(pm, /* flags= */ 0) != null) {
            return preferredIntent;
        }
    }
    return defaultIntent;
}","private Intent getMapsIntent() {
    Intent mapsIntent = null;
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.google.android.apps.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.waze"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.here.android.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""net.osmand.osmand"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.skobee.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.tomtom.navigator"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapswithme.maps.viewer"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.apple.Maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.qmap.android"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.sygic.car"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.sygic.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.garmin.android.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.pro"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.lite"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.lite.pro"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.lite.free"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.free"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.pro.free"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentFor","private Intent getMapsIntent() {
    Intent mapsIntent = null;
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.google.android.apps.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.waze"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.here.android.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""net.osmand.osmand"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.skobee.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.tomtom.navigator"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapswithme.maps.viewer"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.apple.Maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.qmap.android"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.sygic.car"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.sygic.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.garmin.android.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.pro"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.lite"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.lite.pro"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.lite.free"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.free"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentForPackage(""com.mapstrider.maps.offline.pro.free"");
    }
    if (mapsIntent == null) {
        mapsIntent = packageManager.getLaunchIntentFor",10.155563625958521,2.7395953641711634,8.01252926953305,6.0606060606060606,23.809523809523807
39,java,"private void initializeCards() {
    if (mHomeCardModules == null) {
        mHomeCardModules = new ArraySet<>();
        for (String providerClassName : getResources().getStringArray(
                R.array.config_homeCardModuleClasses)) {
            try {
                long reflectionStartTime = System.currentTimeMillis();
                HomeCardModule cardModule = (HomeCardModule) Class.forName(
                        providerClassName).newInstance();
                cardModule.setViewModelProvider(new ViewModelProvider( /* owner= */this));
                mHomeCardModules.add(cardModule);
                if (DEBUG) {
                    long reflectionTime = System.currentTimeMillis() - reflectionStartTime;
                    Log.d(TAG, ""Initialization of HomeCardModule class "" + providerClassName
                            + "" took "" + reflectionTime + "" ms"");
                }
            } catch (IllegalAccessException | InstantiationException |
                    ClassNotFoundException e) {
                Log.w(TAG, ""Unable to create HomeCardProvider class "" + providerClassName, e);
            }
        }
    }
    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    for (HomeCardModule cardModule : mHomeCardModules) {
        transaction.replace(cardModule.getCardResId(), cardModule.getCardView());
    }
    transaction.commitNow();
}","private void initializeCards() {
    for (String cardModuleName : cardModuleNames) {
        try {
            Class<?> cardModuleClass = Class.forName(cardModuleName);
            HomeCardModule cardModule = (HomeCardModule) cardModuleClass.getDeclaredConstructor().newInstance();
            cardModule.onCreate(this);
            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
            transaction.add(R.id.card_container, cardModule, cardModuleName);
            transaction.commit();
        } catch (Exception e) {
            Log.e(""HomeActivity"", ""Failed to initialize card module: "" + cardModuleName, e);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];","private void initializeCards() {
    for (String cardModuleName : cardModuleNames) {
        try {
            Class<?> cardModuleClass = Class.forName(cardModuleName);
            HomeCardModule cardModule = (HomeCardModule) cardModuleClass.getDeclaredConstructor().newInstance();
            cardModule.onCreate(this);
            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
            transaction.add(R.id.card_container, cardModule, cardModuleName);
            transaction.commit();
        } catch (Exception e) {
            Log.e(""HomeActivity"", ""Failed to initialize card module: "" + cardModuleName, e);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int",30.178303980153988,3.5805087161016664,14.077762149569212,45.05494505494506,57.99999999999999
40,java,"private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
    ActivityTaskManager atm = ActivityTaskManager.getInstance();
    for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
        TaskInfo taskInfo = taskAppearedInfo.getTaskInfo();
        if (taskInfo.getWindowingMode() == WINDOWING_MODE_MULTI_WINDOW) {
            if (DBG) Slog.d(TAG, ""Found the dangling task, removing: "" + taskInfo.taskId);
            atm.removeTask(taskInfo.taskId);
        }
    }
}","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
        for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
            if (taskAppearedInfo.isMultiWindow()) {
                ActivityTaskManager.get().removeTask(taskAppearedInfo.taskId);
                Log.d(""TaskManager"", ""Removing dangling task: "" + taskAppearedInfo.taskId);
            }
        }
    }

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
        for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
            if (taskAppearedInfo.isMultiWindow()) {
                ActivityTaskManager.get().removeTask(taskAppearedInfo.taskId);
                Log.d(""TaskManager"", ""Removing dangling task: "" + taskAppearedInfo.taskId);
            }
        }
    }",37.87920791812158,3.049445969789576,32.05324428855535,52.77777777777778,63.63636363636363
41,java,"private void updateMode() {
    mMode = parseMode(getIntent());
    setTitle(mMode.mTitleStringId);
    CarUi.requireToolbar(this).setTitle(mMode.mTitleStringId);
}","private void updateMode() {
    String mode = Intent.getStringExtra(Intent.EXTRA_MODE);
    if (mode != null) {
        int modeId = getResources().getIdentifier(mode, ""string"", getPackageName());
        if (modeId != 0) {
            String title = getString(modeId);
            setTitle(title);
            ((CarUiToolbar) findViewById(R.id.toolbar)).setTitle(title);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 5;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 3;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i","private void updateMode() {
    String mode = Intent.getStringExtra(Intent.EXTRA_MODE);
    if (mode != null) {
        int modeId = getResources().getIdentifier(mode, ""string"", getPackageName());
        if (modeId != 0) {
            String title = getString(modeId);
            setTitle(title);
            ((CarUiToolbar) findViewById(R.id.toolbar)).setTitle(title);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 5;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 3;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i",28.548813270403627,0.6354085718619878,31.02016197006999,38.095238095238095,44.44444444444444
42,java,"private Chronometer getChronometer() {
    if (mChronometer == null) {
        mChronometer = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer);
        mChronometerSeparator = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer_separator);
    }
    return mChronometer;
}","private Chronometer getChronometer() {
    Chronometer chronometer = (Chronometer) findViewById(R.id.chronometer);
    View separator = findViewById(R.id.separator);
    chronometer.setSeparatorView(separator);
    return chronometer;
}","private Chronometer getChronometer() {
    Chronometer chronometer = (Chronometer) findViewById(R.id.chronometer);
    View separator = findViewById(R.id.separator);
    chronometer.setSeparatorView(separator);
    return chronometer;
}",32.91579101004886,13.456320506683921,14.360689687357706,34.61538461538461,69.23076923076923
43,java,"private View getMediaLayoutView() {
    if (mMediaLayoutView == null) {
        ViewStub stub = getRootView().findViewById(R.id.media_layout);
        mMediaLayoutView = stub.inflate();
        mMediaTitle = mMediaLayoutView.findViewById(R.id.primary_text);
        mMediaSubtitle = mMediaLayoutView.findViewById(R.id.secondary_text);
        View mediaControlBarView = mMediaLayoutView.findViewById(
                R.id.media_playback_controls_bar);
        mPresenter.initializeControlsActionBar(mediaControlBarView);
    }
    return mMediaLayoutView;
}","private View getMediaLayoutView() {
    ViewStub stub = (ViewStub) findViewById(R.id.media_layout_stub);
    View inflatedView = stub.inflate();
    TextView titleView = (TextView) inflatedView.findViewById(R.id.media_layout_title);
    TextView subtitleView = (TextView) inflatedView.findViewById(R.id.media_layout_subtitle);
    MediaPlaybackControlsBarPresenter presenter = new MediaPlaybackControlsBarPresenter(this);
    MediaPlaybackControlsBar controlsBar = (MediaPlaybackControlsBar) inflatedView.findViewById(R.id.media_layout_controls_bar);
    controlsBar.setPresenter(presenter);
    return inflatedView;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0","private View getMediaLayoutView() {
    ViewStub stub = (ViewStub) findViewById(R.id.media_layout_stub);
    View inflatedView = stub.inflate();
    TextView titleView = (TextView) inflatedView.findViewById(R.id.media_layout_title);
    TextView subtitleView = (TextView) inflatedView.findViewById(R.id.media_layout_subtitle);
    MediaPlaybackControlsBarPresenter presenter = new MediaPlaybackControlsBarPresenter(this);
    MediaPlaybackControlsBar controlsBar = (MediaPlaybackControlsBar) inflatedView.findViewById(R.id.media_layout_controls_bar);
    controlsBar.setPresenter(presenter);
    return inflatedView;
}",35.94947994656658,1.6414788427351008,20.825246075848796,55.81395348837209,65.51724137931035
44,java,"private void updateBackgroundImage(Drawable image) {
    if (image != null && getCardSize() != null) {
        int maxDimen = Math.max(getCardSize().getWidth(), getCardSize().getHeight());
        Size scaledSize = new Size(maxDimen, maxDimen);
        Bitmap imageBitmap = BitmapUtils.fromDrawable(image, scaledSize);
        Bitmap blurredBackground = ImageUtils.blur(getContext(), imageBitmap, scaledSize,
                mBlurRadius);

        getCardBackgroundImage().setImageBitmap(blurredBackground, /* showAnimation= */ true);
        getCardBackground().setVisibility(View.VISIBLE);
    }
}","private void updateBackgroundImage(Drawable image) {
    int cardSize = card.getWidth();
    int largestDimension = Math.max(cardSize, card.getHeight());
    Bitmap scaledBitmap = Bitmap.createScaledBitmap(image.getBitmap(), largestDimension, largestDimension, true);
    Bitmap blurredBitmap = scaledBitmap.copy(Bitmap.Config.ARGB_8888, true).blur(5);
    card.setBackground(new BitmapDrawable(blurredBitmap));
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 5;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 3;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int","private void updateBackgroundImage(Drawable image) {
    int cardSize = card.getWidth();
    int largestDimension = Math.max(cardSize, card.getHeight());
    Bitmap scaledBitmap = Bitmap.createScaledBitmap(image.getBitmap(), largestDimension, largestDimension, true);
    Bitmap blurredBitmap = scaledBitmap.copy(Bitmap.Config.ARGB_8888, true).blur(5);
    card.setBackground(new BitmapDrawable(blurredBitmap));
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 5;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 3;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_",25.583439290115106,1.3823124345108648,12.98848176298661,25.0,62.96296296296296
45,java,"private void updateMediaView(CharSequence title, CharSequence subtitle) {
    getMediaLayoutView().setVisibility(View.VISIBLE);
    mMediaTitle.setText(title);
    mMediaSubtitle.setText(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
    mediaLayout.setVisibility(View.VISIBLE);
    mediaLayout.setTitle(title);
    mediaLayout.setSubtitle(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
    mediaLayout.setVisibility(View.VISIBLE);
    mediaLayout.setTitle(title);
    mediaLayout.setSubtitle(subtitle);
}",70.842490254843,59.004687263928076,61.207379018601806,63.1578947368421,100.0
46,java,"private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        getChronometer().setVisibility(View.VISIBLE);
        getChronometer().setBase(content.getStartTime());
        getChronometer().start();
        mChronometerSeparator.setVisibility(View.VISIBLE);
    } else {
        getChronometer().setVisibility(View.GONE);
        mChronometerSeparator.setVisibility(View.GONE);
    }
}","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        Chronometer chronometer = new Chronometer(content.getStartTime());
        Separator separator = new Separator();
        separator.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, 1));
        content.addView(separator);
        content.addView(chronometer);
        chronometer.start();
    } else {
        Chronometer chronometer = (Chronometer) content.findViewById(R.id.chronometer);
        Separator separator = (Separator) content.findViewById(R.id.separator);
        if (chronometer != null) {
            chronometer.setVisibility(View.GONE);
        }
        if (separator != null) {
            separator.setVisibility(View.GONE);
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    for (int i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;
    bool isMajority = false;
    for (int i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }
    cout << ""Is "" << x << "" a majority element? "" << (isMajority ? ""Yes"" : ""No"") << endl;

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;
    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }
    cout << ""Found a pair with difference "" << n_diff << ""? "" << (foundPair ? ""Yes"" : ""No"") << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        Chronometer chronometer = new Chronometer(content.getStartTime());
        Separator separator = new Separator();
        separator.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, 1));
        content.addView(separator);
        content.addView(chronometer);
        chronometer.start();
    } else {
        Chronometer chronometer = (Chronometer) content.findViewById(R.id.chronometer);
        Separator separator = (Separator) content.findViewById(R.id.separator);
        if (chronometer != null) {
            chronometer.setVisibility(View.GONE);
        }
        if (separator != null) {
            separator.setVisibility(View.GONE);
        }
    }
}",48.23733821439459,2.785268250999205,55.164084606579166,60.0,75.0
47,java,"public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(mCallback);
    }
}","public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(this);
    }
}","public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(this);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if",74.36357747171822,79.10665071754359,79.88612070779082,38.46153846153847,100.0
48,java,"public void onCallRemoved(Call call) {
    mCurrentCall = null;
    mCardContent = null;
    mPresenter.onModelUpdated(this);
    if (call != null) {
        call.unregisterCallback(mCallback);
    }
}","public void onCallRemoved(Call call) {
    call.clear();
    call.setCardContent(null);
    presenter.onModelUpdated();
    call.unregisterCallback(this);
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    return 0;
}

static boolean isMajority(int arr[], int n, int x) {
    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    if (findPair(arr, n)) {
        cout << ""Pair Found"" << endl;
    } else {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

static boolean findPair(int arr[], int n) {
    int size = arr.length;
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == 1) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < 1) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    cout << ""Maximum sum of non-adjacent elements: "" << FindMaxSum(arr, n) << endl;

    return 0;
}

int FindMaxSum(int arr[], int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    return ((incl > excl) ? incl : excl);
}

#include <iostream>
#include <vector>
#include","public void onCallRemoved(Call call) {
    call.clear();
    call.setCardContent(null);
    presenter.onModelUpdated();
    call.unregisterCallback(this);
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    return 0;
}

static boolean isMajority(int arr[], int n, int x) {
    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    if (findPair(arr, n)) {
        cout << ""Pair Found"" << endl;
    } else {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

static boolean findPair(int arr[], int n) {
    int size = arr.length;
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == 1) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < 1) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    cout << ""Maximum sum of non-adjacent elements: "" << FindMaxSum(arr, n) << endl;

    return 0;
}

int FindMaxSum(int arr[], int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    return ((incl > excl) ? incl : excl);
}

#include <iostream>
#include <vector>
#include <algorithm>",31.89133806468557,1.1950336531625794,24.94174717700826,30.0,71.42857142857143
49,java,"void updateModelWithPhoneNumber(String number) {
    String formattedNumber = TelecomUtils.getFormattedNumber(mContext, number);
    mCardContent = new DescriptiveTextWithControlsView(null, formattedNumber,
            mOngoingCallSubtitle, mElapsedTimeClock.millis(), mMuteButton, mEndCallButton,
            mDialpadButton);
    mPresenter.onModelUpdated(this);
}","void updateModelWithPhoneNumber(String number) {
    DescriptiveTextWithControlsView view = new DescriptiveTextWithControlsView(number);
    presenter.onModelUpdated(view);
}","void updateModelWithPhoneNumber(String number) {
    DescriptiveTextWithControlsView view = new DescriptiveTextWithControlsView(number);
    presenter.onModelUpdated(view);
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    // Determine if a given element x is the majority in a sorted array
    int x = 3;
    int last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    bool isMajority = false;
    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            isMajority = true;
            break;
        }
    }

    if (isMajority) {
        cout << ""Element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""Element "" << x << "" is not a majority element."" << endl;
    }

    // Find if a pair of elements with a given difference n exists in a sorted array
    int n_diff = 2;
    bool foundPair = false;
    int i = 0, j = 1;

    while (i < n && j < n) {
        if (i != j && arr[j] - arr[i] == n_diff) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            foundPair = true;
            break;
        } else if (arr[j] - arr[i] < n_diff) {
            j++;
        } else {
            i++;
        }
    }

    if (!foundPair) {
        cout << ""No such pair found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    // Find the maximum sum of a subsequence of non-adjacent elements
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    int maxSum = (incl > excl) ? incl : excl;

    cout << ""Maximum sum of non-adjacent elements: "" <<",14.306789336892923,11.682950752097785,15.6830954843628,11.11111111111111,18.75
50,java,"private void initializeAudioControls() {
    mMuteButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_mic_off),
            v -> {
                mInCallService.setMuted(mMuteCallToggle);
                mMuteCallToggle = !mMuteCallToggle;
            });
    mEndCallButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_call_end_button),
            v -> mCurrentCall.disconnect());
    mDialpadButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_dialpad), this::onClick);
}","private void initializeAudioControls() {
    muteButton.setIcon(muteIcon);
    muteButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            toggleMute();
        }
    });

    endCallButton.setIcon(endCallIcon);
    endCallButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            endCall();
        }
    });

    dialpadButton.setIcon(dialpadIcon);
    dialpadButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            showDialpad();
        }
    });
}

```java
private void initializeAudioControls() {
    muteButton.setIcon(muteIcon);
    muteButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            toggleMute();
        }
    });

    endCallButton.setIcon(endCallIcon);
    endCallButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            endCall();
        }
    });

    dialpadButton.setIcon(dialpadIcon);
    dialpadButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            showDialpad();
        }
    });
}
```

```java
private void initializeAudioControls() {
    muteButton.setIcon(muteIcon);
    muteButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            toggleMute();
        }
    });

    endCallButton.setIcon(endCallIcon);
    endCallButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            endCall();
        }
    });

    dialpadButton.setIcon(dialpadIcon);
    dialpadButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            showDialpad();
        }
    });
}
```

```java
private void initializeAudioControls() {
    muteButton.setIcon(muteIcon);
    muteButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            toggleMute();
        }
    });

    endCallButton.setIcon(endCallIcon);
    endCallButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            endCall();
        }
    });

    dialpadButton.setIcon(dialpadIcon);
    dialpadButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            showDialpad();
        }
    });
}
```

```java
private void initializeAudioControls() {
    muteButton.setIcon(muteIcon);
    muteButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            toggleMute();
        }
    });

    endCallButton.setIcon(endCallIcon);
    endCallButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            endCall();
        }
    });

    dialpadButton","private void initializeAudioControls() {
    muteButton.setIcon(muteIcon);
    muteButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            toggleMute();
        }
    });

    endCallButton.setIcon(endCallIcon);
    endCallButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            endCall();
        }
    });

    dialpadButton.setIcon(dialpadIcon);
    dialpadButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            showDialpad();
        }
    });
}",25.29778207805309,1.1980071205088731,8.950340443040359,20.454545454545457,70.58823529411765
53,cpp,"void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    (void)_subscription;
    if (dbusConnection_->isConnected())
        _listener(AvailabilityStatus::AVAILABLE);
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (isAvailable()) {
        _listener.notify(AVAILABLE);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 5;

    bool found_pair = findPair(arr2, size2, n2);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int n3 = arr3.size();
    int max_sum = FindMaxSum(arr3, n3);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 5;

    bool found_pair = findPair(arr2, size2, n2);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int n3 = arr3.size();
    int max_sum = FindMaxSum(arr3, n3);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n =","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (isAvailable()) {
        _listener.notify(AVAILABLE);
    }
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 5;

    bool found_pair = findPair(arr2, size2, n2);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int n3 = arr3.size();
    int max_sum = FindMaxSum(arr3, n3);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n =",54.939463536947876,2.067026526731472,61.16908849062524,56.52173913043478,100.0
54,cpp,"void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (connections_.end() != connections_.find(conn)) {
        bool found(false);
        std::vector<std::thread*>::const_iterator it = threads_.begin();
        while (!found && it != threads_.end()) {
            found = (&t == *it++);
        }
        if (!found) {
            threads_.push_back(&t);
        }
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lk(exit_mutex_);
    if (conn_active(conn) && !is_thread_registered(t)) {
        exit_threads_.push_back(t);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int diff = 2;

    bool found = findPair(arr.data(), n, diff);

    if (found) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 5, 10, 100, 10, 5};
    int n = arr.size();

    int max_sum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int diff = 2;

    bool found = findPair(arr.data(), n, diff);

    if (found) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 5, 10, 100, 10, 5};
    int n","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lk(exit_mutex_);
    if (conn_active(conn) && !is_thread_registered(t)) {
        exit_threads_.push_back(t);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int diff = 2;

    bool found = findPair(arr.data(), n, diff);

    if (found) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 5, 10, 100, 10, 5};
    int n = arr.size();

    int max_sum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int diff = 2;

    bool found = findPair(arr.data(), n, diff);

    if (found) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 5, 10, 100, 10, 5};
    int n = arr.size();

    int max_sum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x <<",41.335197503022876,2.6643648308810923,23.631241890502817,44.927536231884055,94.11764705882352
56,cpp,"void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (NULL == static_cast<WatchContext*>(data)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data (WatchContext) == NULL"");
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));
    if (dbusWatch != NULL) {
        if(dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
        }
        dbus_watch_set_data(libdbusWatch, NULL, NULL);
    }
}","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch) {
        libdbusWatch->stopMonitoring();
        libdbusWatch->unref();
    }
}","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch) {
        libdbusWatch->stopMonitoring();
        libdbusWatch->unref();
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool isMajorityElement = isMajority(arr, n, x);

    if (isMajorityElement) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int n_val = 2;

    bool found = findPair(arr, n, n_val);

    if (found) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl =",21.275726049621056,9.838815023000661,19.658028569422953,28.333333333333332,27.27272727272727
57,cpp,"void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    WatchContext* watchContext = static_cast<WatchContext*>(data);

    if (NULL == watchContext) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""watchContext == NULL"");
        return;
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));

    if (dbusWatch == NULL) {
        DBusWatch* dbusWatch = new DBusWatch(libdbusWatch, watchContext->mainLoopContext_, watchContext->dbusConnection_);
        dbusWatch->addDependentDispatchSource(watchContext->dispatchSource_);
        dbus_watch_set_data(libdbusWatch, dbusWatch, NULL);

        if (dbusWatch->isReadyToBeWatched()) {
            dbusWatch->startWatching();
        }
    } else {
        if (!dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
            dbus_watch_set_data(libdbusWatch, NULL, NULL);
        } else {
            dbusWatch->startWatching();
        }
    }
}","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    auto* watch = static_cast<DBusWatch*>(data);
    if (watch->isReady()) {
        libdbus_connection_signal_watch_enabled(connection, libdbusWatch, true);
    } else {
        libdbus_connection_signal_watch_enabled(connection, libdbusWatch, false);
    }
}
 
void DBusConnection::toggleWatch(DBusWatch* watch) {
    if (watch->isReady()) {
        libdbus_connection_signal_watch_enabled(connection, watch->getLibdbusWatch(), true);
    } else {
        libdbus_connection_signal_watch_enabled(connection, watch->getLibdbusWatch(), false);
    }
}

DBusWatch::DBusWatch(DBusConnection* connection, ::DBusWatch* libdbusWatch)
    : connection(connection), libdbusWatch(libdbusWatch), isReady(false) {
    libdbus_connection_signal_watch_ready(connection->connection, libdbusWatch,
                                         [](void* data, bool ready) {
                                             auto* watch = static_cast<DBusWatch*>(data);
                                             watch->isReady = ready;
                                         },
                                         this);
}

::DBusWatch* DBusWatch::getLibdbusWatch() const {
    return libdbusWatch;
}

bool DBusWatch::isReady() const {
    return isReady;
}
 
void DBusConnection::removeWatch(DBusWatch* watch) {
    libdbus_connection_signal_watch_enabled(connection, watch->getLibdbusWatch(), false);
    libdbus_connection_signal_watch_unref(connection, watch->getLibdbusWatch());
}
 
void DBusConnection::addWatch(DBusWatch* watch) {
    libdbus_connection_signal_watch_ref(connection, watch->getLibdbusWatch());
}
 
DBusWatch* DBusConnection::getWatch(const std::string& path, const std::string& interface,
                                    const std::string& signal) {
    auto it = watches.find(std::make_tuple(path, interface, signal));
    if (it != watches.end()) {
        return it->second;
    }
    auto* watch = new DBusWatch(this, libdbus_connection_signal_watch_new(connection, path.c_str(),
                                                                          interface.c_str(),
                                                                          signal.c_str()));
    watches.insert(std::make_tuple(path, interface, signal), watch);
    return watch;
}
 
void DBusConnection::removeWatches() {
    for (auto& it : watches) {
        removeWatch(it.second);
    }
    watches.clear();
}
 
void DBusConnection::addWatches(const std::vector<std::tuple<std::string, std::string,
                                                           std::string>>& watches) {
    for (const auto& watch : watches) {
        addWatch(getWatch(std::get<0>(watch), std::get<1>(watch), std::get<2>(watch)));
    }
}
 
void DBusConnection::removeWatch(const std::string& path, const std::string& interface,","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    auto* watch = static_cast<DBusWatch*>(data);
    if (watch->isReady()) {
        libdbus_connection_signal_watch_enabled(connection, libdbusWatch, true);
    } else {
        libdbus_connection_signal_watch_enabled(connection, libdbusWatch, false);
    }
}

void DBusConnection::toggleWatch(DBusWatch* watch) {
    if (watch->isReady()) {
        libdbus_connection_signal_watch_enabled(connection, watch->getLibdbusWatch(), true);
    } else {
        libdbus_connection_signal_watch_enabled(connection, watch->getLibdbusWatch(), false);
    }
}

DBusWatch::DBusWatch(DBusConnection* connection, ::DBusWatch* libdbusWatch)
    : connection(connection), libdbusWatch(libdbusWatch), isReady(false) {
    libdbus_connection_signal_watch_ready(connection->connection, libdbusWatch,
                                         [](void* data, bool ready) {
                                             auto* watch = static_cast<DBusWatch*>(data);
                                             watch->isReady = ready;
                                         },
                                         this);
}

::DBusWatch* DBusWatch::getLibdbusWatch() const {
    return libdbusWatch;
}

bool DBusWatch::isReady() const {
    return isReady;
}

void DBusConnection::removeWatch(DBusWatch* watch) {
    libdbus_connection_signal_watch_enabled(connection, watch->getLibdbusWatch(), false);
    libdbus_connection_signal_watch_unref(connection, watch->getLibdbusWatch());
}

void DBusConnection::addWatch(DBusWatch* watch) {
    libdbus_connection_signal_watch_ref(connection, watch->getLibdbusWatch());
}

DBusWatch* DBusConnection::getWatch(const std::string& path, const std::string& interface,
                                    const std::string& signal) {
    auto it = watches.find(std::make_tuple(path, interface, signal));
    if (it != watches.end()) {
        return it->second;
    }
    auto* watch = new DBusWatch(this, libdbus_connection_signal_watch_new(connection, path.c_str(),
                                                                          interface.c_str(),
                                                                          signal.c_str()));
    watches.insert(std::make_tuple(path, interface, signal), watch);
    return watch;
}

void DBusConnection::removeWatches() {
    for (auto& it : watches) {
        removeWatch(it.second);
    }
    watches.clear();
}

void DBusConnection::addWatches(const std::vector<std::tuple<std::string, std::string,
                                                           std::string>>& watches) {
    for (const auto& watch : watches) {
        addWatch(getWatch(std::get<0>(watch), std::get<1>(watch), std::get<2>(watch)));
    }
}

void DBusConnection::removeWatch(const std::string& path, const std::string& interface,
                                 const std::string& signal) {
    auto it = watches",37.9774594787923,5.299692830123718,16.34596482086521,49.494949494949495,80.76923076923077
58,cpp,"const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> itsLock(objectManagerGuard_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return dbusObjectManager_;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    std::lock_guard<std::mutex> lock(dbus_object_manager_mutex_);
    if (!dbus_object_manager_) {
        dbus_object_manager_ = std::make_shared<DBusObjectManager>(dbus_);
    }
    return dbus_object_manager_;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int n_val = 2;
    bool found_pair = findPair(arr.data(), n, n_val);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    int max_sum = FindMaxSum(arr, n);
    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int n_val = 2;
    bool found_pair = findPair(arr.data(), n, n_val);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    int max_sum = FindMaxSum(arr, n);
    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int n_val = 2;
    bool found_pair = findPair(arr.data(), n, n_val);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    std::lock_guard<std::mutex> lock(dbus_object_manager_mutex_);
    if (!dbus_object_manager_) {
        dbus_object_manager_ = std::make_shared<DBusObjectManager>(dbus_);
    }
    return dbus_object_manager_;
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int n_val = 2;
    bool found_pair = findPair(arr.data(), n, n_val);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    int max_sum = FindMaxSum(arr, n);
    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int n_val = 2;
    bool found_pair = findPair(arr.data(), n, n_val);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    int max_sum = FindMaxSum(arr, n);
    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int n_val = 2;
    bool found_pair = findPair(arr.data(), n, n_val);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    int",34.92837455497702,1.025278607510082,19.457450381628767,69.23076923076923,50.0
59,cpp,"bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    DBusError dbusError;
    bool isServiceNameReleased = false;
    std::lock_guard<std::recursive_mutex> dbusConnectionLock(connectionGuard_);
    auto conIter = connectionNameCount_.find(serviceName);
    if (conIter != connectionNameCount_.end()) {
        if (conIter->second == 1) {
            const int libdbusStatus = dbus_bus_release_name(connection_,
                            serviceName.c_str(),
                            &dbusError.libdbusError_);
            isServiceNameReleased = (libdbusStatus == DBUS_RELEASE_NAME_REPLY_RELEASED);
            if (isServiceNameReleased) {
                connectionNameCount_.erase(conIter);
            }
        } else {
            conIter->second--;
            isServiceNameReleased = true;
        }
    }
    return isServiceNameReleased;
}","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    std::lock_guard<std::mutex> itsLock(serviceNamesMutex_);
    auto it = serviceNames_.find(serviceName);
    if (it != serviceNames_.end()) {
        it->second--;
        if (it->second == 0) {
            serviceNames_.erase(it);
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    bool isMajority = isMajority(arr, n, x);

    if (isMajority) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int n_val = 2;

    bool found = findPair(arr, n, n_val);

    if (found) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 5, 10, 100, 10, 5};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1;","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    std::lock_guard<std::mutex> itsLock(serviceNamesMutex_);
    auto it = serviceNames_.find(serviceName);
    if (it != serviceNames_.end()) {
        it->second--;
        if (it->second == 0) {
            serviceNames_.erase(it);
            return true;
        }
    }
    return false;
}",41.7061941795905,2.924605568888665,19.614456863759003,64.28571428571429,80.0
60,cpp,"DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (NULL == _libdbusPendingCall) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""_libdbusPendingCall == NULL"");
        return DBusMessage();
    }

    ::DBusMessage* libdbusMessage = dbus_pending_call_steal_reply(_libdbusPendingCall);
    const bool increaseLibdbusMessageReferenceCount = false;
    DBusMessage dbusMessage(libdbusMessage, increaseLibdbusMessageReferenceCount);

    return dbusMessage;
}","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (_libdbusPendingCall == nullptr) {
        return DBusMessage();
    }

    DBusMessage message;
    message.set_reply(_libdbusPendingCall);
    return message;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    int n_val = 2;
    bool found_pair = findPair(arr.data(), n, n_val);

    if (found_pair) {
        cout << ""A pair with difference "" << n_val << "" was found."" << endl;
    } else {
        cout << ""No pair with difference "" << n_val << "" was found."" << endl;
    }

    int max_sum = FindMaxSum(arr, n);
    cout << ""The maximum sum of a subsequence of non-adjacent elements is: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (_libdbusPendingCall == nullptr) {
        return DBusMessage();
    }

    DBusMessage message;
    message.set_reply(_libdbusPendingCall);
    return message;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    int n_val = 2;
    bool found_pair = findPair(arr.data(), n, n_val);

    if (found_pair) {
        cout << ""A pair with difference "" << n_val << "" was found."" << endl;
    } else {
        cout << ""No pair with difference "" << n_val << "" was found."" << endl;
    }

    int max_sum = FindMaxSum(arr, n);
    cout << ""The maximum sum of a subsequence of non-adjacent elements is: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl",38.9364620517899,1.4515759871155618,19.037861963633805,43.58974358974359,91.66666666666666
61,cpp,"void DBusConnection::deleteAsyncHandlers() {
    std::vector<DBusMessageReplyAsyncHandler*> asyncHandlers;
    {
        std::lock_guard<std::mutex> asyncHandlersLock(asyncHandlersToDeleteMutex_);
        asyncHandlers = asyncHandlersToDelete_;
        asyncHandlersToDelete_.clear();
    }

    auto it = asyncHandlers.begin();
    while(it != asyncHandlers.end()) {
        delete *it;
        it = asyncHandlers.erase(it);
    }
}","void DBusConnection::deleteAsyncHandlers() {
    std::unique_lock<std::mutex> itsLock(itsAsyncHandlersMutex);
    std::vector<DBusAsyncHandler*> handlers = itsAsyncHandlers;
    itsAsyncHandlers.clear();
    for (DBusAsyncHandler* handler : handlers) {
        delete handler;
    }
}","void DBusConnection::deleteAsyncHandlers() {
    std::unique_lock<std::mutex> itsLock(itsAsyncHandlersMutex);
    std::vector<DBusAsyncHandler*> handlers = itsAsyncHandlers;
    itsAsyncHandlers.clear();
    for (DBusAsyncHandler* handler : handlers) {
        delete handler;
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool isMajority = isMajority(arr, n, x);

    if (isMajority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool isMajority = isMajority(arr.data(), n, x);

    if (isMajority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i +",27.289870640527212,4.855047084154351,5.494911668430703,57.14285714285714,41.66666666666667
62,cpp,"void DBusConnection::handleSignalStates() {
    std::map<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>, std::set<uint32_t>> tmpHandlers;
    {
        std::lock_guard<std::mutex> itsLock(signalStateHandlersMutex_);
        tmpHandlers = signalStateHandlers_;
    }
    for (auto itsHandler : tmpHandlers) {
        for (uint32_t tag : itsHandler.second) {
            itsHandler.first->onSpecificError(CommonAPI::CallStatus::SUCCESS, tag);
        }
    }
}","void DBusConnection::handleSignalStates() {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    for (auto& signal : itsSignals) {
        if (signal.second.status == SUCCESS) {
            for (auto& handler : signal.second.handlers) {
                handler.onSpecificError(signal.first, SUCCESS);
            }
        }
    }
}","void DBusConnection::handleSignalStates() {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    for (auto& signal : itsSignals) {
        if (signal.second.status == SUCCESS) {
            for (auto& handler : signal.second.handlers) {
                handler.onSpecificError(signal.first, SUCCESS);
            }
        }
    }
}",28.192812108967914,7.243330534988143,7.701830944361772,47.82608695652174,50.0
63,cpp,"void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::recursive_mutex> itsConnectionGuard(connectionsMutex_);
    auto itsConnection = connections_.find(_connectionId);

    if (itsConnection != connections_.end()) {
        connections_.erase(_connectionId);
    }
}","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool isMajorityElement = isMajority(arr, n, x);

    if (isMajorityElement) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int n_diff = 2;

    bool found = findPair(arr, n, n_diff);

    if (found) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(mutex_);
    auto it = connections_.find(_connectionId);
    if (it != connections_.end()) {
        connections_.erase(it);
    }
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool isMajorityElement = isMajority(arr, n, x);

    if (isMajorityElement) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int n_diff = 2;

    bool found = findPair(arr, n, n_diff);

    if (found) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new",55.3820784461682,1.648110824341124,35.237345817474555,97.14285714285714,87.5
64,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.hasMemberName(""InterfacesAdded"")) {
        instanceAvblStatusEvent_->onInterfacesAddedSignal(dbusMessage);
    } else if (dbusMessage.hasMemberName(""InterfacesRemoved"")) {
        instanceAvblStatusEvent_->onInterfacesRemovedSignal(dbusMessage);
   }
}","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.getMember() == ""InterfacesAdded"") {
        onInterfacesAdded(dbusMessage);
    } else if (dbusMessage.getMember() == ""InterfacesRemoved"") {
        onInterfacesRemoved(dbusMessage);
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int n_diff = 2;

    bool result = findPair(arr, n, n_diff);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""No such pair."" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 10, 4, 3, 7, 9, 2};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n;","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.getMember() == ""InterfacesAdded"") {
        onInterfacesAdded(dbusMessage);
    } else if (dbusMessage.getMember() == ""InterfacesRemoved"") {
        onInterfacesRemoved(dbusMessage);
    }
}
 
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int n_diff = 2;

    bool result = findPair(arr, n, n_diff);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""No such pair."" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 10, 4, 3, 7, 9, 2};
    int n = arr.size();

    int maxSum = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << maxSum << endl;

    return 0;
}

int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {",47.32568711397055,1.7579528684862695,42.09025013285051,45.45454545454545,100.0
65,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(
        CommonAPI::CallStatus &_status,
        std::vector<DBusAddress> &_availableServiceInstances) {

    _availableServiceInstances.clear();
    DBusObjectManagerStub::DBusObjectPathAndInterfacesDict itsAvailableServiceInstances;
    registry_->getAvailableServiceInstances(proxy_.getDBusAddress().getService(),
            proxy_.getDBusAddress().getObjectPath(),
            itsAvailableServiceInstances);

    _status = CommonAPI::CallStatus::SUCCESS;
    translate(itsAvailableServiceInstances, _availableServiceInstances);
}","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    std::shared_ptr<DBus> dbus = std::make_shared<DBus>();
    dbus->init();

    std::vector<std::string> serviceInstances;
    dbus->getAvailableServiceInstances(serviceInstances);

    _availableServiceInstances.clear();
    for (const auto &serviceInstance : serviceInstances) {
        _availableServiceInstances.push_back(DBusAddress(serviceInstance));
    }

    _status = CommonAPI::CallStatus::SUCCESS;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = findPair(arr, n, x);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""Majority element found."" << endl;
    } else {
        cout << ""Majority element not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    int result = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << result << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = findPair(arr, n, x);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""Majority element found."" << endl;
    } else {
        cout << ""Majority element not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    std::shared_ptr<DBus> dbus = std::make_shared<DBus>();
    dbus->init();

    std::vector<std::string> serviceInstances;
    dbus->getAvailableServiceInstances(serviceInstances);

    _availableServiceInstances.clear();
    for (const auto &serviceInstance : serviceInstances) {
        _availableServiceInstances.push_back(DBusAddress(serviceInstance));
    }

    _status = CommonAPI::CallStatus::SUCCESS;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = findPair(arr, n, x);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""Majority element found."" << endl;
    } else {
        cout << ""Majority element not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    int result = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << result << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = findPair(arr, n, x);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""Majority element found."" << endl;
    } else {
        cout << ""Majority element not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;",46.87308290659424,1.1271040898642977,20.780811952097086,72.72727272727273,92.85714285714286
66,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(
        const std::string &_instance,
        CallStatus &_callStatus,
        AvailabilityStatus &_availabilityStatus) {

    CommonAPI::Address itsAddress(""local"", observedCapiInterfaceName_, _instance);
    DBusAddress itsDBusAddress;
    DBusAddressTranslator::get()->translate(itsAddress, itsDBusAddress);

    _availabilityStatus = AvailabilityStatus::NOT_AVAILABLE;
    if (registry_->isServiceInstanceAlive(
            itsDBusAddress.getInterface(),
            itsDBusAddress.getService(),
            itsDBusAddress.getObjectPath())) {
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
    }
    _callStatus = CallStatus::SUCCESS;
}","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    std::string dbusAddress = _instance;
    dbusAddress += "".service"";
    std::shared_ptr<DBusConnection> connection = std::make_shared<DBusConnection>();
    if (!connection->connect()) {
        _callStatus = CallStatus::CONNECTION_ERROR;
        return;
    }

    std::shared_ptr<DBusObject> object = connection->getObject(dbusAddress);
    if (!object) {
        _callStatus = CallStatus::OBJECT_NOT_FOUND;
        return;
    }

    std::shared_ptr<DBusMethod> method = object->getMethod(""org.freedesktop.DBus.Introspect.GetProperties"");
    if (!method) {
        _callStatus = CallStatus::METHOD_NOT_FOUND;
        return;
    }

    std::shared_ptr<DBusVariant> result = method->call();
    if (!result) {
        _callStatus = CallStatus::METHOD_CALL_ERROR;
        return;
    }

    _availabilityStatus = result->get<AvailabilityStatus>();
    _callStatus = CallStatus::SUCCESS;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool found = findPair(arr, n, x);

    if (found) {
        cout << ""Pair found!"" << endl;
    } else {
        cout << ""Pair not found!"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool found = isMajority(arr, n, x);

    if (found) {
        cout << ""Majority found!"" << endl;
    } else {
        cout << ""Majority not found!"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    std::string dbusAddress = _instance;
    dbusAddress += "".service"";
    std::shared_ptr<DBusConnection> connection = std::make_shared<DBusConnection>();
    if (!connection->connect()) {
        _callStatus = CallStatus::CONNECTION_ERROR;
        return;
    }

    std::shared_ptr<DBusObject> object = connection->getObject(dbusAddress);
    if (!object) {
        _callStatus = CallStatus::OBJECT_NOT_FOUND;
        return;
    }

    std::shared_ptr<DBusMethod> method = object->getMethod(""org.freedesktop.DBus.Introspect.GetProperties"");
    if (!method) {
        _callStatus = CallStatus::METHOD_NOT_FOUND;
        return;
    }

    std::shared_ptr<DBusVariant> result = method->call();
    if (!result) {
        _callStatus = CallStatus::METHOD_CALL_ERROR;
        return;
    }

    _availabilityStatus = result->get<AvailabilityStatus>();
    _callStatus = CallStatus::SUCCESS;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool found = findPair(arr, n, x);

    if (found) {
        cout << ""Pair found!"" << endl;
    } else {
        cout << ""Pair not found!"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool found = isMajority(arr, n, x);

    if (found) {
        cout << ""Majority found!"" << endl;
    } else {
        cout << ""Majority not found!"" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {",35.267502376420914,2.8600912132872627,27.098807181285306,66.66666666666666,44.44444444444444
67,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    DBusInputStream dbusInputStream(_message);
    std::string dbusObjectPath;
    std::vector<std::string> dbusInterfaceNames;

    dbusInputStream >> dbusObjectPath;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read object path"");
    }

    dbusInputStream >> dbusInterfaceNames;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read interface names"");
    }

    for (const auto& dbusInterfaceName : dbusInterfaceNames) {
        if(auto itsProxy = proxyWeakPtr_.lock() &&
                dbusInterfaceName == observedDbusInterfaceName_ &&
                removeInterface(dbusObjectPath, dbusInterfaceName)) {
            (void)itsProxy;
            notifyInterfaceStatusChanged(dbusObjectPath, dbusInterfaceName, AvailabilityStatus::NOT_AVAILABLE);
        }
    }
}","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    DBusMessage message = _message.createReply();
    DBusError error;
    DBusObjectPath objectPath;
    DBusInterfaceName interfaceName;
    DBusConnection::get(message, error, objectPath, interfaceName);

    if (error.hasError()) {
        return;
    }

    if (objectPath == observedObjectPath_ && interfaceName == observedInterfaceName_) {
        observedInterfaceStatus_ = NOT_AVAILABLE;
        notifyListeners();
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int n_val = 2;

    bool result = findPair(arr, n, n_val);

    if (result) {
        cout << ""Pair Found"" << endl;
    } else {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5};
    int n = arr.size();
    int x = 5;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""The element "" << x << "" is a","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    DBusMessage message = _message.createReply();
    DBusError error;
    DBusObjectPath objectPath;
    DBusInterfaceName interfaceName;
    DBusConnection::get(message, error, objectPath, interfaceName);

    if (error.hasError()) {
        return;
    }

    if (objectPath == observedObjectPath_ && interfaceName == observedInterfaceName_) {
        observedInterfaceStatus_ = NOT_AVAILABLE;
        notifyListeners();
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int n_val = 2;

    bool result = findPair(arr, n, n_val);

    if (result) {
        cout << ""Pair Found"" << endl;
    } else {
        cout << ""No such pair"" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5};
    int n = arr.size();
    int x = 5;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""The element "" << x << "" is a majority element."" <<",28.92516183135392,1.547194952284378,9.025247244926158,35.8974358974359,69.23076923076923
68,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(
        const std::string &_objectPath,
        const std::string &_interfaceName,
        const AvailabilityStatus &_availability) {
    CommonAPI::Address itsAddress;
    DBusAddress itsDBusAddress(proxy_.getDBusAddress().getService(),
                               _objectPath,
                               _interfaceName);

    DBusAddressTranslator::get()->translate(itsDBusAddress, itsAddress);

    notifyListeners(itsAddress.getAddress(), _availability);
}","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    std::string commonAPIAddress = _objectPath + ""/"" + _interfaceName;
    notifyListeners(commonAPIAddress, _availability);
}
 
void DBusInstanceAvailabilityStatusChangedEvent::notifyListeners(const std::string &_commonAPIAddress, const AvailabilityStatus &_availability) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    for (auto listener : itsListeners) {
        listener->onDBusInstanceAvailabilityStatusChanged(_commonAPIAddress, _availability);
    }
}
 
void DBusInstanceAvailabilityStatusChangedEvent::addDBusAvailabilityListener(DBusAvailabilityListener *listener) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(listener);
}
 
void DBusInstanceAvailabilityStatusChangedEvent::removeDBusAvailabilityListener(DBusAvailabilityListener *listener) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    for (auto it = itsListeners.begin(); it != itsListeners.end(); ++it) {
        if (*it == listener) {
            itsListeners.erase(it);
            break;
        }
    }
}
 
DBusInstanceAvailabilityStatusChangedEvent::DBusInstanceAvailabilityStatusChangedEvent() {
}
 
DBusInstanceAvailabilityStatusChangedEvent::~DBusInstanceAvailabilityStatusChangedEvent() {
}
 
void DBusInstanceAvailabilityStatusChangedEvent::clear() {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.clear();
}
 
void DBusInstanceAvailabilityStatusChangedEvent::setAvailability(const AvailabilityStatus &_availability) {
    itsAvailability = _availability;
}
 
AvailabilityStatus DBusInstanceAvailabilityStatusChangedEvent::getAvailability() const {
    return itsAvailability;
}
 
void DBusInstanceAvailabilityStatusChangedEvent::setObjectPath(const std::string &_objectPath) {
    itsObjectPath = _objectPath;
}
 
std::string DBusInstanceAvailabilityStatusChangedEvent::getObjectPath() const {
    return itsObjectPath;
}
 
void DBusInstanceAvailabilityStatusChangedEvent::setInterfaceName(const std::string &_interfaceName) {
    itsInterfaceName = _interfaceName;
}
 
std::string DBusInstanceAvailabilityStatusChangedEvent::getInterfaceName() const {
    return itsInterfaceName;
}
 
void DBusInstanceAvailabilityStatusChangedEvent::setDBusAvailabilityListener(DBusAvailabilityListener *listener) {
    itsDBusAvailabilityListener = listener;
}
 
DBusAvailabilityListener *DBusInstanceAvailabilityStatusChangedEvent::getDBusAvailabilityListener() const {
    return itsDBusAvailabilityListener;
}
 
void DBusInstanceAvailabilityStatusChangedEvent::setDBusAvailabilityListenerInterface(DBusAvailabilityListenerInterface *listener) {
    itsDBusAvailabilityListenerInterface = listener;
}
 
DBusAvailabilityListenerInterface *DBusInstanceAvailabilityStatusChangedEvent::getDBusAvailabilityListenerInterface() const {
    return itsDBusAvailabilityListenerInterface;
}
 
void DBusInstanceAvailabilityStatusChangedEvent::setDBusAvailabilityListenerProxy(DBusAvailabilityListenerProxy *listener) {
    itsDBusAvailabilityListenerProxy = listener;
}
 
DBusAvailabilityListenerProxy *DBusInstanceAvailabilityStatusChangedEvent::getDBusAvailabilityListenerProxy()","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    std::string commonAPIAddress = _objectPath + ""/"" + _interfaceName;
    notifyListeners(commonAPIAddress, _availability);
}

void DBusInstanceAvailabilityStatusChangedEvent::notifyListeners(const std::string &_commonAPIAddress, const AvailabilityStatus &_availability) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    for (auto listener : itsListeners) {
        listener->onDBusInstanceAvailabilityStatusChanged(_commonAPIAddress, _availability);
    }
}

void DBusInstanceAvailabilityStatusChangedEvent::addDBusAvailabilityListener(DBusAvailabilityListener *listener) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(listener);
}

void DBusInstanceAvailabilityStatusChangedEvent::removeDBusAvailabilityListener(DBusAvailabilityListener *listener) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    for (auto it = itsListeners.begin(); it != itsListeners.end(); ++it) {
        if (*it == listener) {
            itsListeners.erase(it);
            break;
        }
    }
}

DBusInstanceAvailabilityStatusChangedEvent::DBusInstanceAvailabilityStatusChangedEvent() {
}

DBusInstanceAvailabilityStatusChangedEvent::~DBusInstanceAvailabilityStatusChangedEvent() {
}

void DBusInstanceAvailabilityStatusChangedEvent::clear() {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.clear();
}

void DBusInstanceAvailabilityStatusChangedEvent::setAvailability(const AvailabilityStatus &_availability) {
    itsAvailability = _availability;
}

AvailabilityStatus DBusInstanceAvailabilityStatusChangedEvent::getAvailability() const {
    return itsAvailability;
}

void DBusInstanceAvailabilityStatusChangedEvent::setObjectPath(const std::string &_objectPath) {
    itsObjectPath = _objectPath;
}

std::string DBusInstanceAvailabilityStatusChangedEvent::getObjectPath() const {
    return itsObjectPath;
}

void DBusInstanceAvailabilityStatusChangedEvent::setInterfaceName(const std::string &_interfaceName) {
    itsInterfaceName = _interfaceName;
}

std::string DBusInstanceAvailabilityStatusChangedEvent::getInterfaceName() const {
    return itsInterfaceName;
}

void DBusInstanceAvailabilityStatusChangedEvent::setDBusAvailabilityListener(DBusAvailabilityListener *listener) {
    itsDBusAvailabilityListener = listener;
}

DBusAvailabilityListener *DBusInstanceAvailabilityStatusChangedEvent::getDBusAvailabilityListener() const {
    return itsDBusAvailabilityListener;
}

void DBusInstanceAvailabilityStatusChangedEvent::setDBusAvailabilityListenerInterface(DBusAvailabilityListenerInterface *listener) {
    itsDBusAvailabilityListenerInterface = listener;
}

DBusAvailabilityListenerInterface *DBusInstanceAvailabilityStatusChangedEvent::getDBusAvailabilityListenerInterface() const {
    return itsDBusAvailabilityListenerInterface;
}

void DBusInstanceAvailabilityStatusChangedEvent::setDBusAvailabilityListenerProxy(DBusAvailabilityListenerProxy *listener) {
    itsDBusAvailabilityListenerProxy = listener;
}

DBusAvailabilityListenerProxy *DBusInstanceAvailabilityStatusChangedEvent::getDBusAvailabilityListenerProxy()
{
    return itsDBusAvailabilityListenerProxy;
}

void DBusInstanceAvailabilityStatusChangedEvent::setDBusAvailabilityListenerInterfaceProxy(DBusAvailabilityListener",50.21429792109973,4.77079197718372,41.76267465178283,63.41463414634146,90.9090909090909
69,cpp,"void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener,
                                           const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);

   std::weak_ptr<DBusProxy> itsdbusProxy = dbusProxy_->shared_from_this();
    dbusProxy_->getDBusConnection()->proxyPushFunctionToMainLoop<DBusConnection>(
            DBusProxy::notifySpecificListener,
            itsdbusProxy,
            _listener,
            _subscription);
}","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto listener_added = [this, _listener, _subscription]() {
        auto it = std::find_if(listeners_.begin(), listeners_.end(),
                               [&_listener](const auto &l) { return l.first == _listener; });
        if (it != listeners_.end()) {
            it->second.push_back(_subscription);
        } else {
            listeners_.push_back({_listener, {_subscription}});
        }
    };
    main_event_loop_->postEvent(listener_added);
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 5;

    bool found_pair = findPair(arr2, size2, n2);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int n3 = arr3.size();
    int max_sum = FindMaxSum(arr3, n3);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 5;

    bool found_pair = findPair(arr2, size2, n2);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto listener_added = [this, _listener, _subscription]() {
        auto it = std::find_if(listeners_.begin(), listeners_.end(),
                               [&_listener](const auto &l) { return l.first == _listener; });
        if (it != listeners_.end()) {
            it->second.push_back(_subscription);
        } else {
            listeners_.push_back({_listener, {_subscription}});
        }
    };
    main_event_loop_->postEvent(listener_added);
}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 5;

    bool found_pair = findPair(arr2, size2, n2);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int n3 = arr3.size();
    int max_sum = FindMaxSum(arr3, n3);

    cout << ""Maximum sum of non-adjacent elements: "" << max_sum << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool is_majority = isMajority(arr.data(), n, x);

    if (is_majority) {
        cout << x << "" is a majority element."" << endl;
    } else {
        cout << x << "" is not a majority element."" << endl;
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 5;

    bool found_pair = findPair(arr2, size2, n2);

    if (found_pair) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int",51.071412123714886,2.218481200335268,39.567167294524296,62.5,100.0
70,cpp,"void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener,
                                             const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);
    (void)_listener;
    auto listenerIt = listeners_.begin();
    while(listenerIt != listeners_.end()) {
        if(listenerIt->first == _subscription)
            listenerIt = listeners_.erase(listenerIt);
        else
            ++listenerIt;
    }
}","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::remove_if(itsListeners.begin(), itsListeners.end(),
                             [&](const Listener& listener) {
                                 return listener.subscription == _subscription;
                             });
    itsListeners.erase(it, itsListeners.end());
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    int arr2[] = {1, 3, 5, 7, 9};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 2;

    if (findPair(arr2, size2, n2)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int n3 = arr3.size();

    cout << ""Max sum of non-adjacent elements: "" << FindMaxSum(arr3, n3) << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    int arr2[] = {1, 3, 5, 7, 9};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 2;

    if (findPair(arr2, size2, n2)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int n3 = arr3.size();

    cout << ""Max sum of non-adjacent elements: "" << FindMaxSum(arr3, n3) << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::remove_if(itsListeners.begin(), itsListeners.end(),
                             [&](const Listener& listener) {
                                 return listener.subscription == _subscription;
                             });
    itsListeners.erase(it, itsListeners.end());
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    int arr2[] = {1, 3, 5, 7, 9};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 2;

    if (findPair(arr2, size2, n2)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int n3 = arr3.size();

    cout << ""Max sum of non-adjacent elements: "" << FindMaxSum(arr3, n3) << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not a majority element"" << endl;
    }

    int arr2[] = {1, 3, 5, 7, 9};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    int n2 = 2;

    if (findPair(arr2, size2, n2)) {
        cout << ""Pair found"" << endl;
    } else {
        cout << ""Pair not found"" << endl;
    }

    vector<int> arr3 = {5, 5, 10, 100, 10, 5};
    int n3 = arr3.size();

    cout << ""Max sum of non-adjacent elements: "" << FindMaxSum(arr3, n3) << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 1};
    int n = arr.size();
    int x = 2;

    if (isMajority(arr, n, x)) {
        cout << x << "" is a majority element"" << endl;
    } else {
        cout << x << "" is not",42.70376901120775,2.3036465221259403,29.523334284609824,60.416666666666664,78.57142857142857
71,cpp,"void DBusProxyBase::addSignalStateHandler(
            std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler,
            const uint32_t _subscription) {
    connection_->addSignalStateHandler(_handler, _subscription);
}","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->addSignalStateHandler(_handler, _subscription);
}
 
void DBusProxyBase::removeSignalStateHandler(const uint32_t _subscription) {
    _connection->removeSignalStateHandler(_subscription);
}
 
void DBusProxyBase::removeAllSignalStateHandlers() {
    _connection->removeAllSignalStateHandlers();
}
 
std::shared_ptr<DBusProxyConnection::DBusSignalHandler> DBusProxyBase::getSignalStateHandler(const uint32_t _subscription) {
    return _connection->getSignalStateHandler(_subscription);
}
 
std::vector<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>> DBusProxyBase::getSignalStateHandlers() {
    return _connection->getSignalStateHandlers();
}
 
void DBusProxyBase::addSignalStateHandlers(const std::vector<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>>& _handlers) {
    _connection->addSignalStateHandlers(_handlers);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForInterface(const std::string& _interface) {
    _connection->removeAllSignalStateHandlersForInterface(_interface);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForMember(const std::string& _interface, const std::string& _member) {
    _connection->removeAllSignalStateHandlersForMember(_interface, _member);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForSubscription(const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlersForSubscription(_subscription);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForInterfaceAndMember(const std::string& _interface, const std::string& _member) {
    _connection->removeAllSignalStateHandlersForInterfaceAndMember(_interface, _member);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForInterfaceAndSubscription(const std::string& _interface, const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlersForInterfaceAndSubscription(_interface, _subscription);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForMemberAndSubscription(const std::string& _member, const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlersForMemberAndSubscription(_member, _subscription);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForInterfaceMemberAndSubscription(const std::string& _interface, const std::string& _member, const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlersForInterfaceMemberAndSubscription(_interface, _member, _subscription);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForInterfaceMember(const std::string& _interface, const std::string& _member) {
    _connection->removeAllSignalStateHandlersForInterfaceMember(_interface, _member);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForMember(const std::string& _member) {
    _connection->removeAllSignalStateHandlersForMember(_member);
}
 
void DBusProxyBase::removeAllSignalStateHandlersForInterface(const std::string& _interface) {
    _connection->removeAllSignalStateHandlersForInterface(_interface);
}
 
void DBusProxyBase::removeAllSignalStateHandlers() {
    _connection","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    _connection->addSignalStateHandler(_handler, _subscription);
}

void DBusProxyBase::removeSignalStateHandler(const uint32_t _subscription) {
    _connection->removeSignalStateHandler(_subscription);
}

void DBusProxyBase::removeAllSignalStateHandlers() {
    _connection->removeAllSignalStateHandlers();
}

std::shared_ptr<DBusProxyConnection::DBusSignalHandler> DBusProxyBase::getSignalStateHandler(const uint32_t _subscription) {
    return _connection->getSignalStateHandler(_subscription);
}

std::vector<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>> DBusProxyBase::getSignalStateHandlers() {
    return _connection->getSignalStateHandlers();
}

void DBusProxyBase::addSignalStateHandlers(const std::vector<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>>& _handlers) {
    _connection->addSignalStateHandlers(_handlers);
}

void DBusProxyBase::removeAllSignalStateHandlersForInterface(const std::string& _interface) {
    _connection->removeAllSignalStateHandlersForInterface(_interface);
}

void DBusProxyBase::removeAllSignalStateHandlersForMember(const std::string& _interface, const std::string& _member) {
    _connection->removeAllSignalStateHandlersForMember(_interface, _member);
}

void DBusProxyBase::removeAllSignalStateHandlersForSubscription(const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlersForSubscription(_subscription);
}

void DBusProxyBase::removeAllSignalStateHandlersForInterfaceAndMember(const std::string& _interface, const std::string& _member) {
    _connection->removeAllSignalStateHandlersForInterfaceAndMember(_interface, _member);
}

void DBusProxyBase::removeAllSignalStateHandlersForInterfaceAndSubscription(const std::string& _interface, const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlersForInterfaceAndSubscription(_interface, _subscription);
}

void DBusProxyBase::removeAllSignalStateHandlersForMemberAndSubscription(const std::string& _member, const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlersForMemberAndSubscription(_member, _subscription);
}

void DBusProxyBase::removeAllSignalStateHandlersForInterfaceMemberAndSubscription(const std::string& _interface, const std::string& _member, const uint32_t _subscription) {
    _connection->removeAllSignalStateHandlersForInterfaceMemberAndSubscription(_interface, _member, _subscription);
}

void DBusProxyBase::removeAllSignalStateHandlersForInterfaceMember(const std::string& _interface, const std::string& _member) {
    _connection->removeAllSignalStateHandlersForInterfaceMember(_interface, _member);
}

void DBusProxyBase::removeAllSignalStateHandlersForMember(const std::string& _member) {
    _connection->removeAllSignalStateHandlersForMember(_member);
}

void DBusProxyBase::removeAllSignalStateHandlersForInterface(const std::string& _interface) {
    _connection->removeAllSignalStateHandlersForInterface(_interface);
}

void DBusProxyBase::removeAllSignalStateHandlers() {
    _connection->removeAllSignalStateHandlers();
}
 
void DBusProxyBase::removeAllSignalStateHandlers() {
    _connection->removeAllSignalStateHandlers",60.3026121221564,2.824894427979132,43.94110961620203,94.44444444444444,100.0
72,cpp,"void
DBusProxyManager::instancesAsyncCallback(
        std::shared_ptr<Proxy> _proxy,
        const CommonAPI::CallStatus &_status,
        const std::vector<DBusAddress> &_availableServiceInstances,
        GetAvailableInstancesCallback &_call) {
    (void)_proxy;
    std::vector<std::string> itsAvailableInstances;
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        translate(_availableServiceInstances, itsAvailableInstances);
    }
    _call(_status, itsAvailableInstances);
}","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> availableServiceInstances;
        for (const auto &_serviceInstance : _availableServiceInstances) {
            availableServiceInstances.push_back(_serviceInstance.toString());
        }
        _call(CommonAPI::CallStatus::SUCCESS, availableServiceInstances);
    } else {
        _call(_status, std::vector<std::string>());
    }
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = findPair(arr, n, x);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""Majority element found."" << endl;
    } else {
        cout << ""Majority element not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    int result = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << result << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = findPair(arr, n, x);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""Majority element found."" << endl;
    } else {
        cout << ""Majority element not found."" << endl;
    }

    return 0;
}

#include <iostream>","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> availableServiceInstances;
        for (const auto &_serviceInstance : _availableServiceInstances) {
            availableServiceInstances.push_back(_serviceInstance.toString());
        }
        _call(CommonAPI::CallStatus::SUCCESS, availableServiceInstances);
    } else {
        _call(_status, std::vector<std::string>());
    }
}",56.73030533391352,3.9894322917863927,51.265122377201045,80.0,91.66666666666666
73,cpp,"bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    const char* objectPath = dbusMessage.getObjectPath();
    const char* interfaceName = dbusMessage.getInterface();

    if (NULL == objectPath) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" objectPath == NULL"");
    }
    if (NULL == interfaceName) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" interfaceName == NULL"");
    }

    DBusInterfaceHandlerPath handlerPath(objectPath, interfaceName);

    std::unique_lock<std::recursive_mutex> itsLock(objectPathLock_);

    auto handlerIterator = dbusRegisteredObjectsTable_.find(handlerPath);
    const bool foundDBusInterfaceHandler = handlerIterator != dbusRegisteredObjectsTable_.end();
    bool dbusMessageHandled = false;

    if (foundDBusInterfaceHandler) {
        std::shared_ptr<DBusInterfaceHandler> dbusStubAdapterBase = handlerIterator->second.front();
        itsLock.unlock();
        dbusMessageHandled = dbusStubAdapterBase->onInterfaceDBusMessage(dbusMessage);
        return dbusMessageHandled;
    } else if (dbusMessage.hasInterfaceName(""org.freedesktop.DBus.Introspectable"")) {
        dbusMessageHandled = onIntrospectableInterfaceDBusMessage(dbusMessage);
    }

    return dbusMessageHandled;
}","bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.isMethodCall()) {
        const std::string_view interface = dbusMessage.getInterface();
        const std::string_view objectPath = dbusMessage.getObjectPath();

        auto it = handlers_.find(objectPath);
        if (it != handlers_.end()) {
            auto handler = it->second.find(interface);
            if (handler != it->second.end()) {
                return handler->second(dbusMessage);
            }
        }
    } else if (dbusMessage.isSignal()) {
        return false;
    } else if (dbusMessage.isError()) {
        return false;
    } else if (dbusMessage.isReply()) {
        return false;
    } else if (dbusMessage.isMethodReturn()) {
        return false;
    } else if (dbusMessage.isMethodError()) {
        return false;
    } else if (dbusMessage.isEndOfMessage()) {
        return false;
    } else if (dbusMessage.isDispatchStatus()) {
        return false;
    } else if (dbusMessage.isErrorName()) {
        return false;
    } else if (dbusMessage.isErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfo()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfo()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodSignature()) {
        return false;
    } else if (dbusMessage.isMethodSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnSignature()) {
        return false;
    } else if (dbusMessage.isMethodReturnSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorSignature()) {
        return false;
    } else if (dbusMessage.isMethodErrorSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoSignature()) {
        return false;
    } else if (dbusMessage.isMethodInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoSignature()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorSignatureReply","bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.isMethodCall()) {
        const std::string_view interface = dbusMessage.getInterface();
        const std::string_view objectPath = dbusMessage.getObjectPath();

        auto it = handlers_.find(objectPath);
        if (it != handlers_.end()) {
            auto handler = it->second.find(interface);
            if (handler != it->second.end()) {
                return handler->second(dbusMessage);
            }
        }
    } else if (dbusMessage.isSignal()) {
        return false;
    } else if (dbusMessage.isError()) {
        return false;
    } else if (dbusMessage.isReply()) {
        return false;
    } else if (dbusMessage.isMethodReturn()) {
        return false;
    } else if (dbusMessage.isMethodError()) {
        return false;
    } else if (dbusMessage.isEndOfMessage()) {
        return false;
    } else if (dbusMessage.isDispatchStatus()) {
        return false;
    } else if (dbusMessage.isErrorName()) {
        return false;
    } else if (dbusMessage.isErrorReply()) {
        return false;
    } else if (dbusMessage.isMethodInfo()) {
        return false;
    } else if (dbusMessage.isMethodInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfo()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoReply()) {
        return false;
    } else if (dbusMessage.isMethodSignature()) {
        return false;
    } else if (dbusMessage.isMethodSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnSignature()) {
        return false;
    } else if (dbusMessage.isMethodReturnSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorSignature()) {
        return false;
    } else if (dbusMessage.isMethodErrorSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoSignature()) {
        return false;
    } else if (dbusMessage.isMethodInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoSignature()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorInfoSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodReturnSignatureReply()) {
        return false;
    } else if (dbusMessage.isMethodErrorSignatureReply()) {
        return false",23.47042012123974,2.9207551668018854,10.217682074913833,37.5,43.24324324324324
74,cpp,"bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath,
                                                std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    const auto& dbusRegisteredObjectsTableIter = dbusRegisteredObjectsTable_.find(dbusInterfaceHandlerPath);
    const bool isDBusInterfaceHandlerAlreadyAdded = (dbusRegisteredObjectsTableIter != dbusRegisteredObjectsTable_.end());

    if (isDBusInterfaceHandlerAlreadyAdded) {

        auto handler = find(dbusRegisteredObjectsTableIter->second.begin(), dbusRegisteredObjectsTableIter->second.end(), dbusInterfaceHandler);
        if (handler != dbusRegisteredObjectsTableIter->second.end()) {
            if (dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.ObjectManager"" ||
                    dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.Properties"") {
                return true;
            }
            return false;
        }
    }

    auto insertSuccess = addToRegisteredObjectsTable(dbusInterfaceHandlerPath, dbusInterfaceHandler);
    return insertSuccess;
}","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = dbusInterfaceHandlerPaths_.find(dbusInterfaceHandlerPath);
    if (it != dbusInterfaceHandlerPaths_.end()) {
        if (it->second == dbusInterfaceHandler) {
            return false;
        }
        if (dbusInterfaceHandlerPath.interface == DBUS_INTERFACE_OBJECT_MANAGER || dbusInterfaceHandlerPath.interface == DBUS_INTERFACE_PROPERTIES) {
            return true;
        }
    }
    dbusInterfaceHandlerPaths_[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
    return true;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = findPair(arr, n, x);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""Majority element found."" << endl;
    } else {
        cout << ""Majority element not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    int result = FindMaxSum(arr, n);

    cout << ""Maximum sum of non-adjacent elements: "" << result << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = findPair(arr, n, x);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""Pair not found."" << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""Majority element found."" << endl;
    } else {","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    std::lock_guard<std::mutex> lock(mutex_);
    auto it = dbusInterfaceHandlerPaths_.find(dbusInterfaceHandlerPath);
    if (it != dbusInterfaceHandlerPaths_.end()) {
        if (it->second == dbusInterfaceHandler) {
            return false;
        }
        if (dbusInterfaceHandlerPath.interface == DBUS_INTERFACE_OBJECT_MANAGER || dbusInterfaceHandlerPath.interface == DBUS_INTERFACE_PROPERTIES) {
            return true;
        }
    }
    dbusInterfaceHandlerPaths_[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
    return true;
}",41.99558853974095,3.7143194091464866,21.609304591087174,56.94444444444444,85.71428571428571
75,cpp,"bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    auto handlerRecord = dbusRegisteredObjectsTable_.find(ifpath);
    if (handlerRecord == dbusRegisteredObjectsTable_.end()) {
        dbusRegisteredObjectsTable_.insert({
            ifpath,
            std::vector<std::shared_ptr<DBusInterfaceHandler>>({handler})
        });
    }
    else {
        std::vector<std::shared_ptr<DBusInterfaceHandler>> handlerList = handlerRecord->second;
        auto adapter = find(handlerList.begin(), handlerList.end(), handler);
        if (adapter != handlerList.end()) {
            return false;
        }
        else {
            handlerList.push_back(handler);
            handlerRecord->second = handlerList;
        }
    }
    return true;
}","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    if (registeredObjectsTable.find(ifpath) == registeredObjectsTable.end()) {
        registeredObjectsTable[ifpath] = handler;
        return true;
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int diff = 2;

    bool result = findPair(arr, n, diff);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""No such pair exists."" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    if (registeredObjectsTable.find(ifpath) == registeredObjectsTable.end()) {
        registeredObjectsTable[ifpath] = handler;
        return true;
    }
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int x = 3;

    bool result = isMajority(arr, n, x);

    if (result) {
        cout << ""The element "" << x << "" is a majority element."" << endl;
    } else {
        cout << ""The element "" << x << "" is not a majority element."" << endl;
    }

    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int n = arr.size();
    int diff = 2;

    bool result = findPair(arr, n, diff);

    if (result) {
        cout << ""Pair found."" << endl;
    } else {
        cout << ""No such pair exists."" << endl;
    }

    return 0;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> arr = {5, 5, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,",37.371501751665434,3.1440378432128373,22.149198079111564,48.19277108433735,76.0
78,c,"void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t positive_sid = UDS_SID_ECU_RESET + 0x40;

  uint8_t tx_data[] = {positive_sid, reset_type};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_positive_reset_response(uint8_t reset_type) {
    uint8_t ecu_reset_response[2];
    ecu_reset_response[0] = 0x7E;
    ecu_reset_response[1] = reset_type;

    if (can_send_message(ecu_reset_response, 2) != 0) {
        printf(""Error sending ECU reset response\n"");
    }
}","void send_positive_reset_response(uint8_t reset_type) {
    uint8_t ecu_reset_response[2];
    ecu_reset_response[0] = 0x7E;
    ecu_reset_response[1] = reset_type;

    if (can_send_message(ecu_reset_response, 2) != 0) {
        printf(""Error sending ECU reset response\n"");
    }
}",12.463691607443945,6.362372418971438,7.841770124886338,12.121212121212121,23.52941176470588
79,c,"void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    return;
  }

  uint8_t reset_type = data[1];

  if (reset_type == UDS_RESET_TYPE_HARD) {
    send_positive_reset_response(UDS_RESET_TYPE_HARD);

    k_sleep(K_MSEC(100));

    LOG_DBG(""Hard reset\n"");
    sys_reboot(SYS_REBOOT_COLD);
  } else {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_SUBFUNCTION_NOT_SUPPORTED);
  }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
    if (len != 2) {
        send_negative_response();
        return;
    }

    uint8_t reset_type = data[1];

    if (reset_type == 0x01) {
        send_positive_response();
        system_reboot();
    } else {
        send_negative_response();
    }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
    if (len != 2) {
        send_negative_response();
        return;
    }

    uint8_t reset_type = data[1];

    if (reset_type == 0x01) {
        send_positive_response();
        system_reboot();
    } else {
        send_negative_response();
    }
}",50.92114537078282,54.81320018219152,56.623319285435855,25.581395348837212,66.66666666666666
80,c,"void send_request_download_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_DOWNLOAD + 0x40;


  uint8_t tx_data[] = {
    positive_sid,
    0x20,  // positive response code
    0x00,
    0xD2,  // block size = 258 - 2
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","```c
void send_request_download_response() {
    uint8_t ecu_id = 0x12;
    uint8_t service_id = 0x31;
    uint8_t payload[4] = {0x00, 0xD2, 0x00, 0x00};
    uint8_t ecu_id_byte = ecu_id;
    uint8_t service_id_byte = service_id;
    uint8_t data_length_byte = 0x04;
    uint8_t data_length_high_byte = 0x00;
    uint8_t data_length_low_byte = 0x04;
    uint8_t ecu_id_high_byte = 0x00;
    uint8_t ecu_id_low_byte = ecu_id;
    uint8_t message_type_byte = 0x01;
    uint8_t message_type_high_byte = 0x00;
    uint8_t message_type_low_byte = 0x01;
    uint8_t payload_length_byte = 0x04;
    uint8_t payload_length_high_byte = 0x00;
    uint8_t payload_length_low_byte = 0x04;
    uint8_t ecu_id_high_byte_2 = 0x00;
    uint8_t ecu_id_low_byte_2 = ecu_id;
    uint8_t service_id_byte_2 = service_id;
    uint8_t data_length_byte_2 = 0x04;
    uint8_t data_length_high_byte_2 = 0x00;
    uint8_t data_length_low_byte_2 = 0x04;
    uint8_t ecu_id_high_byte_3 = 0x00;
    uint8_t ecu_id_low_byte_3 = ecu_id;
    uint8_t service_id_byte_3 = service_id;
    uint8_t data_length_byte_3 = 0x04;
    uint8_t data_length_high_byte_3 = 0x00;
    uint8_t data_length_low_byte_3 = 0x04;
    uint8_t ecu_id_high_byte_4 = 0x00;
    uint8_t ecu_id_low_byte_4 = ecu_id;
    uint8_t service_id_byte_4 = service_id;
    uint8_t data_length_byte_4 = 0x04;
    uint8_t data_length_high_byte_4 = 0x00;
    uint8_t data_length_low_byte_4 = 0x04;
    uint8_t ecu_id_high_byte_5 = 0x00;
    uint8_t ecu_id_low_byte_5 = ecu_id;
    uint8_t service_id_byte_5 = service_id;
    uint8_t data_length_byte_5 = 0x04;
    uint8_t data_length_high_byte_5 = 0x00;
    uint","```c
void send_request_download_response() {
    uint8_t ecu_id = 0x12;
    uint8_t service_id = 0x31;
    uint8_t payload[4] = {0x00, 0xD2, 0x00, 0x00};
    uint8_t ecu_id_byte = ecu_id;
    uint8_t service_id_byte = service_id;
    uint8_t data_length_byte = 0x04;
    uint8_t data_length_high_byte = 0x00;
    uint8_t data_length_low_byte = 0x04;
    uint8_t ecu_id_high_byte = 0x00;
    uint8_t ecu_id_low_byte = ecu_id;
    uint8_t message_type_byte = 0x01;
    uint8_t message_type_high_byte = 0x00;
    uint8_t message_type_low_byte = 0x01;
    uint8_t payload_length_byte = 0x04;
    uint8_t payload_length_high_byte = 0x00;
    uint8_t payload_length_low_byte = 0x04;
    uint8_t ecu_id_high_byte_2 = 0x00;
    uint8_t ecu_id_low_byte_2 = ecu_id;
    uint8_t service_id_byte_2 = service_id;
    uint8_t data_length_byte_2 = 0x04;
    uint8_t data_length_high_byte_2 = 0x00;
    uint8_t data_length_low_byte_2 = 0x04;
    uint8_t ecu_id_high_byte_3 = 0x00;
    uint8_t ecu_id_low_byte_3 = ecu_id;
    uint8_t service_id_byte_3 = service_id;
    uint8_t data_length_byte_3 = 0x04;
    uint8_t data_length_high_byte_3 = 0x00;
    uint8_t data_length_low_byte_3 = 0x04;
    uint8_t ecu_id_high_byte_4 = 0x00;
    uint8_t ecu_id_low_byte_4 = ecu_id;
    uint8_t service_id_byte_4 = service_id;
    uint8_t data_length_byte_4 = 0x04;
    uint8_t data_length_high_byte_4 = 0x00;
    uint8_t data_length_low_byte_4 = 0x04;
    uint8_t ecu_id_high_byte_5 = 0x00;
    uint8_t ecu_id_low_byte_5 = ecu_id;
    uint8_t service_id_byte_5 = service_id;
    uint8_t data_length_byte_5 = 0x04;
    uint8_t data_length_high_byte_5 = 0x00;
    uint",10.631236530280042,0.7494843770651934,2.1921284107216423,6.25,33.33333333333333
81,c,"static void send_transfer_data_response(uint8_t block_sequence_counter) {
  int ret;
  uint8_t positive_sid = UDS_SID_TRANSFER_DATA + 0x40;

  uint8_t tx_data[] = {positive_sid, block_sequence_counter};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
    uint8_t data[2];
    data[0] = 0x78;
    data[1] = block_sequence_counter;

    if (can_send_message(0x180, data, 2) != 0) {
        printf(""Error sending transfer data response\n"");
    }
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 3;

    if (isMajority(arr, n, x)) {
        printf(""The element %d is a majority element in the array.\n"", x);
    } else {
        printf(""The element %d is not a majority element in the array.\n"", x);
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int n3 = 5;

    if (findPair(arr2, n2, n3)) {
        printf(""Pair found.\n"");
    } else {
        printf(""No such pair found.\n"");
    }

    int arr3[] = {5, 5, 10, 10, 10, 10, 10, 10, 10, 10};
    int n4 = sizeof(arr3) / sizeof(arr3[0]);
    int x2 = 10;

    if (isMajority(arr3, n4, x2)) {
        printf(""The element %d is a majority element in the array.\n"", x2);
    } else {
        printf(""The element %d is not a majority element in the array.\n"", x2);
    }

    int arr4[] = {1, 2, 3, 4, 5};
    int n5 = sizeof(arr4) / sizeof(arr4[0]);
    int x3 = 10;

    if (isMajority(arr4, n5, x3)) {
        printf(""The element %d is a majority element in the array.\n"", x3);
    } else {
        printf(""The element %d is not a majority element in the array.\n"", x3);
    }

    int arr5[] = {1, 2, 3, 4, 5};
    int n6 = sizeof(arr5) / sizeof(arr5[0]);
    int n7 = 2;

    if (findPair(arr5, n6, n7)) {
        printf(""Pair found.\n"");
    } else {
        printf(""No such pair found.\n"");
    }

    int arr6[] = {1, 2, 3, 4, 5};
    int n8 = sizeof(arr6) / sizeof(arr6[0]);
    int n9 = 10;

    if (findPair(arr6, n8, n9)) {
        printf(""Pair found.\n"");
    } else {
        printf(""No such pair found.\n"");","static void send_transfer_data_response(uint8_t block_sequence_counter) {
    uint8_t data[2];
    data[0] = 0x78;
    data[1] = block_sequence_counter;

    if (can_send_message(0x180, data, 2) != 0) {
        printf(""Error sending transfer data response\n"");
    }
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int can_send_message(uint8_t id, uint8_t *data, int len) {
    return 0;
}

bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = (n % 2) ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}

bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            printf(""Pair Found: (%d, %d)\n"", arr[i], arr[j]);
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    printf(""No such pair\n"");
    return false;
}
 
int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 3;

    if (isMajority(arr, n, x)) {
        printf(""The element %d is a majority element in the array.\n"", x);
    } else {
        printf(""The element %d is not a majority element in the array.\n"", x);
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int n3 = 5;

    if (findPair(arr2, n2, n3)) {
        printf(""Pair found.\n"");
    } else {
        printf(""No such pair found.\n"");
    }

    int arr3[] = {1, 2, 3, 4, 5};
    int n4 = sizeof(arr3) / sizeof(arr3[0]);
    int x2 = 10;

    if (isMajority(arr3, n4, x2)) {
        printf(""The element %d is a majority element in the array.\n"", x2);
    } else {
        printf(""The element %d is not a majority element in the array.\n"", x2);
    }

    int arr4[] = {1, 2, 3, 4, 5};
    int n5 = sizeof(arr4) / sizeof(arr4[0",25.591860086587413,1.7249283245374594,12.407217904165133,23.52941176470588,64.70588235294117
82,c,"static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
  int ret;
  uint8_t positive_sid = UDS_SID_ROUTINE_CONTROL + 0x40;

  uint8_t tx_data[] = {positive_sid, 0x1, (routine_id >> 8) & 0xFF,
                       routine_id & 0xFF, result};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
    uint8_t data[5];
    data[0] = 0x7E;
    data[1] = 0x00;
    data[2] = 0x00;
    data[3] = (uint8_t)(routine_id >> 8);
    data[4] = (uint8_t)routine_id;

    if (iso_tp_send_message(0x180, data, 5) != 0) {
        printf(""Error sending routine control result\n"");
    }
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 3;

    if (isMajority(arr, n, x)) {
        printf(""The element %d is a majority element.\n"", x);
    } else {
        printf(""The element %d is not a majority element.\n"", x);
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int n3 = 5;

    if (findPair(arr2, n2, n3)) {
        printf(""Pair found.\n"");
    } else {
        printf(""Pair not found.\n"");
    }

    int arr3[] = {5, 5, 10, 10, 10, 10, 10, 10, 10, 10};
    int n4 = sizeof(arr3) / sizeof(arr3[0]);
    int x2 = 10;

    if (isMajority(arr3, n4, x2)) {
        printf(""The element %d is a majority element.\n"", x2);
    } else {
        printf(""The element %d is not a majority element.\n"", x2);
    }

    int arr4[] = {1, 2, 3, 4, 5};
    int n5 = sizeof(arr4) / sizeof(arr4[0]);
    int x3 = 10;

    if (isMajority(arr4, n5, x3)) {
        printf(""The element %d is a majority element.\n"", x3);
    } else {
        printf(""The element %d is not a majority element.\n"", x3);
    }

    int arr5[] = {1, 2, 3, 4, 5};
    int n6 = sizeof(arr5) / sizeof(arr5[0]);
    int n7 = 2;

    if (findPair(arr5, n6, n7)) {
        printf(""Pair found.\n"");
    } else {
        printf(""Pair not found.\n"");
    }

    int arr6[] = {1, 2, 3, 4, 5};
    int n8 = sizeof(arr6) / sizeof(arr6[0]);
    int n9 = 10;

    if (findPair","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
    uint8_t data[5];
    data[0] = 0x7E;
    data[1] = 0x00;
    data[2] = 0x00;
    data[3] = (uint8_t)(routine_id >> 8);
    data[4] = (uint8_t)routine_id;

    if (iso_tp_send_message(0x180, data, 5) != 0) {
        printf(""Error sending routine control result\n"");
    }
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 3;

    if (isMajority(arr, n, x)) {
        printf(""The element %d is a majority element.\n"", x);
    } else {
        printf(""The element %d is not a majority element.\n"", x);
    }

    int arr2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n2 = sizeof(arr2) / sizeof(arr2[0]);
    int n3 = 5;

    if (findPair(arr2, n2, n3)) {
        printf(""Pair found.\n"");
    } else {
        printf(""Pair not found.\n"");
    }

    int arr3[] = {5, 5, 10, 10, 10, 10, 10, 10, 10, 10};
    int n4 = sizeof(arr3) / sizeof(arr3[0]);
    int x2 = 10;

    if (isMajority(arr3, n4, x2)) {
        printf(""The element %d is a majority element.\n"", x2);
    } else {
        printf(""The element %d is not a majority element.\n"", x2);
    }

    int arr4[] = {1, 2, 3, 4, 5};
    int n5 = sizeof(arr4) / sizeof(arr4[0]);
    int x3 = 10;

    if (isMajority(arr4, n5, x3)) {
        printf(""The element %d is a majority element.\n"", x3);
    } else {
        printf(""The element %d is not a majority element.\n"", x3);
    }

    int arr5[] = {1, 2, 3, 4, 5};
    int n6 = sizeof(arr5) / sizeof(arr5[0]);
    int n7 = 2;

    if (findPair(arr5, n6, n7)) {
        printf(""Pair found.\n"");
    } else {
        printf(""Pair not found.\n"");
    }

    int arr6[] = {1, 2, 3, 4, 5};
    int n8 = sizeof(arr6) / sizeof(arr6[0]);
    int n9 = 10;

    if (findPair(arr",28.97409462497713,2.750006957846135,14.813038208729049,33.33333333333333,65.0
83,c,"static void send_transer_exit_positive_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_TRANSFER_EXIT + 0x40;

  uint8_t tx_data[] = {positive_sid};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transer_exit_positive_response() {
    uint8_t ecu_id = 0x7E;
    uint8_t sid = 0x40;
    uint8_t data[1] = {0x01};
    uint8_t length = 1;
    uint8_t i;

    for (i = 0; i < 1; i++) {
        if (can_send_message(ecu_id, sid, data, length) != 0) {
            printf(""Error sending transfer exit positive response\n"");
        }
    }
}","static void send_transer_exit_positive_response() {
    uint8_t ecu_id = 0x7E;
    uint8_t sid = 0x40;
    uint8_t data[1] = {0x01};
    uint8_t length = 1;

    if (can_send_message(ecu_id, sid, data, length) != 0) {
        printf(""Error sending transfer exit positive response\n"");
    }
}",20.365437545540843,7.650725768801829,8.962539564876687,18.181818181818183,46.666666666666664
85,c,"static inline uint8_t map_from_can_id(uint32_t can_id) {
  for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
    if (id_mapping[i] == can_id) {
      return i;
    }
  }

  return 0xff;
}","static inline uint8_t map_from_can_id(uint32_t can_id) {
    uint8_t i;
    for (i = 0; i < sizeof(id_mapping) / sizeof(id_mapping[0]); i++) {
        if (id_mapping[i] == can_id) {
            return i;
        }
    }
    return 0xff;
}
 
uint8_t* id_mapping = {
    0x100,
    0x101,
    0x102,
    0x103,
    0x104,
    0x105,
    0x106,
    0x107,
    0x108,
    0x109,
    0x10a,
    0x10b,
    0x10c,
    0x10d,
    0x10e,
    0x10f,
    0x110,
    0x111,
    0x112,
    0x113,
    0x114,
    0x115,
    0x116,
    0x117,
    0x118,
    0x119,
    0x11a,
    0x11b,
    0x11c,
    0x11d,
    0x11e,
    0x11f,
    0x120,
    0x121,
    0x122,
    0x123,
    0x124,
    0x125,
    0x126,
    0x127,
    0x128,
    0x129,
    0x12a,
    0x12b,
    0x12c,
    0x12d,
    0x12e,
    0x12f,
    0x130,
    0x131,
    0x132,
    0x133,
    0x134,
    0x135,
    0x136,
    0x137,
    0x138,
    0x139,
    0x13a,
    0x13b,
    0x13c,
    0x13d,
    0x13e,
    0x13f,
    0x140,
    0x141,
    0x142,
    0x143,
    0x144,
    0x145,
    0x146,
    0x147,
    0x148,
    0x149,
    0x14a,
    0x14b,
    0x14c,
    0x14d,
    0x14e,
    0x14f,
    0x150,
    0x151,
    0x152,
    0x153,
    0x154,
    0x155,","static inline uint8_t map_from_can_id(uint32_t can_id) {
    uint8_t i;
    for (i = 0; i < sizeof(id_mapping) / sizeof(id_mapping[0]); i++) {
        if (id_mapping[i] == can_id) {
            return i;
        }
    }
    return 0xff;
}
 
uint8_t* id_mapping = {
    0x100,
    0x101,
    0x102,
    0x103,
    0x104,
    0x105,
    0x106,
    0x107,
    0x108,
    0x109,
    0x10a,
    0x10b,
    0x10c,
    0x10d,
    0x10e,
    0x10f,
    0x110,
    0x111,
    0x112,
    0x113,
    0x114,
    0x115,
    0x116,
    0x117,
    0x118,
    0x119,
    0x11a,
    0x11b,
    0x11c,
    0x11d,
    0x11e,
    0x11f,
    0x120,
    0x121,
    0x122,
    0x123,
    0x124,
    0x125,
    0x126,
    0x127,
    0x128,
    0x129,
    0x12a,
    0x12b,
    0x12c,
    0x12d,
    0x12e,
    0x12f,
    0x130,
    0x131,
    0x132,
    0x133,
    0x134,
    0x135,
    0x136,
    0x137,
    0x138,
    0x139,
    0x13a,
    0x13b,
    0x13c,
    0x13d,
    0x13e,
    0x13f,
    0x140,
    0x141,
    0x142,
    0x143,
    0x144,
    0x145,
    0x146,
    0x147,
    0x148,
    0x149,
    0x14a,
    0x14b,
    0x14c,
    0x14d,
    0x14e,
    0x14f,
    0x150,
    0x151,
    0x152,
    0x153,
    0x154,
    0x155,
};",49.9868329168118,16.237975082099183,74.18554706133851,66.66666666666666,42.857142857142854
86,c,"static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
  struct lin2can_data *data = dev->data;

 if (filter_id == TRANSLATABLE_ADDRESSES_LEN) {
    for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
      data->incoming_callbacks[i].callback = 0;
    }

    return;
  }

  if (filter_id >= TRANSLATABLE_ADDRESSES_LEN) {
    return;
  }
  data->incoming_callbacks[filter_id].callback = 0;
}","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	int i;

	if (filter_id == -1) {
		for (i = 0; i < ARRAY_SIZE(dev->rx_filters); i++) {
			dev->rx_filters[i].cb = NULL;
		}
	} else if (filter_id >= 0 && filter_id < ARRAY_SIZE(dev->rx_filters)) {
		dev->rx_filters[filter_id].cb = NULL;
	}
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	int i;

	if (filter_id == -1) {
		for (i = 0; i < ARRAY_SIZE(dev->rx_filters); i++) {
			dev->rx_filters[i].cb = NULL;
		}
	} else if (filter_id >= 0 && filter_id < ARRAY_SIZE(dev->rx_filters)) {
		dev->rx_filters[filter_id].cb = NULL;
	}
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h",31.581047702715324,5.941189118883797,34.047597965269446,42.857142857142854,43.47826086956522
87,c,"static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  struct lin2can_data *data = dev->data;
  struct k_msgq *outgoing_frame_buffer = data->outgoing_frame_queue;

  struct lin2can_outgoing_frame_t outgoing;
  if (k_msgq_get(outgoing_frame_buffer, &outgoing, K_NO_WAIT)) {
    return false;
  }

  memcpy(frame, &outgoing.frame, sizeof(*frame));

  LOG_DBG(""Calling can tx callback"");

  outgoing.callback(dev, 0, outgoing.user_data);

  return true;
}","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
    struct lin_context *ctx = (struct lin_context *)user_data;
    struct lin_frame *out_frame;

    if (list_empty(&ctx->out_queue)) {
        return false;
    }

    out_frame = list_first_entry(&ctx->out_queue, struct lin_frame, list);
    memcpy(frame, out_frame, sizeof(struct lin_frame));
    list_del(&out_frame->list);
    ctx->frame_cb(out_frame);
    return true;
}
docs/api/c/README.md
# API Reference

## Overview

This document describes the API for the Linux kernel's CAN and LIN drivers.

## CAN

### CAN Controller Driver

The CAN controller driver provides a generic interface for CAN controllers.

### CAN Bus Driver

The CAN bus driver provides a generic interface for CAN buses.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
    struct lin_context *ctx = (struct lin_context *)user_data;
    struct lin_frame *out_frame;

    if (list_empty(&ctx->out_queue)) {
        return false;
    }

    out_frame = list_first_entry(&ctx->out_queue, struct lin_frame, list);
    memcpy(frame, out_frame, sizeof(struct lin_frame));
    list_del(&out_frame->list);
    ctx->frame_cb(out_frame);
    return true;
}
docs/api/c/README.md
# API Reference

## Overview

This document describes the API for the Linux kernel's CAN and LIN drivers.

## CAN

### CAN Controller Driver

The CAN controller driver provides a generic interface for CAN controllers.

### CAN Bus Driver

The CAN bus driver provides a generic interface for CAN buses.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.

### CAN Controller

The CAN controller structure is used to represent a CAN controller.

### CAN Bus

The CAN bus structure is used to represent a CAN bus.

### CAN Frame

The CAN frame structure is used to represent a CAN frame.

### CAN Message

The CAN message structure is used to represent a CAN message.",35.267647461507174,1.9968854040378483,24.246118235094304,44.827586206896555,70.0
88,c,"static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  const struct lin2can_data *data = dev->data;

 uint8_t mapped_id = frame->data[0] >> 6;

  __ASSERT(mapped_id < TRANSLATABLE_ADDRESSES_LEN, ""Unexpected LIN-ID: %x"",
           mapped_id);

  LOG_DBG(""Incoming can frame with can id %x"", id_mapping[mapped_id]);

 if (!data->incoming_callbacks[mapped_id].callback) {
    return;
  }

  struct can_frame translated = {
    .id = id_mapping[mapped_id],
    .dlc = 8,
  };
  memcpy(translated.data, frame->data, frame->len);

  translated.data[0] = frame->data[0] & 0x3f;

  LOG_DBG(""Calling according can callback"");

  data->incoming_callbacks[mapped_id].callback(
      dev, &translated, data->incoming_callbacks[mapped_id].user_data);
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
    uint8_t can_id_index = (frame->data[0] >> 6) & 0x03;
    uint32_t can_id = 0;
    uint8_t can_dlc = 0;
    uint8_t *can_data = NULL;

    switch (can_id_index) {
        case 0:
            can_id = 0x123;
            can_dlc = 8;
            can_data = (uint8_t *)user_data;
            break;
        case 1:
            can_id = 0x456;
            can_dlc = 8;
            can_data = (uint8_t *)user_data;
            break;
        case 2:
            can_id = 0x789;
            can_dlc = 8;
            can_data = (uint8_t *)user_data;
            break;
        case 3:
            can_id = 0xabc;
            can_dlc = 8;
            can_data = (uint8_t *)user_data;
            break;
        default:
            return;
    }

    can_data[0] = frame->data[0] & 0x3f;
    memcpy(can_data + 1, frame->data + 1, frame->length - 1);

    struct can_frame can_frame;
    can_frame.id = can_id;
    can_frame.dlc = can_dlc;
    memcpy(can_frame.data, can_data, can_dlc);

    handler(can_frame);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
    uint8_t can_id_index = (frame->data[0] >> 6) & 0x03;
    uint32_t can_id = 0;
    uint8_t can_dlc = 0;
    uint8_t *can_data = NULL;

    switch (can_id_index) {
        case 0:
            can_id = 0x123;
            can_dlc = 8;
            can_data = (uint8_t *)user_data;
            break;
        case 1:
            can_id = 0x456;
            can_dlc = 8;
            can_data = (uint8_t *)user_data;
            break;
        case 2:
            can_id = 0x789;
            can_dlc = 8;
            can_data = (uint8_t *)user_data;
            break;
        case 3:
            can_id = 0xabc;
            can_dlc = 8;
            can_data = (uint8_t *)user_data;
            break;
        default:
            return;
    }

    can_data[0] = frame->data[0] & 0x3f;
    memcpy(can_data + 1, frame->data + 1, frame->length - 1);

    struct can_frame can_frame;
    can_frame.id = can_id;
    can_frame.dlc = can_dlc;
    memcpy(can_frame.data, can_data, can_dlc);

    handler(can_frame);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char",26.471639188977182,5.455364243019883,16.753031593348595,43.67816091954023,40.0
89,c,"static int hv_shield_init(const struct device* dev) {
  const struct hv_shield_config_t* config = dev->config;
  struct hv_shield_data_t* data = dev->data;

  int err = gpio_pin_configure_dt(&config->oe_gpio_spec, GPIO_OUTPUT_INACTIVE);
  if (err) {
    LOG_ERR(""Error setting up Output enable pin (%d)"", err);
    return err;
  }

  memset(&data->registers, 0, sizeof(data->registers));

  err = _hv_shield_update(dev);
  if (err) {
    LOG_ERR(""Error writing registers (%d)"", err);
    return err;
  }

  err = gpio_pin_set_dt(&config->oe_gpio_spec, 1);
  if (err) {
    LOG_ERR(""Error setting enabling output (%d)"", err);
  }

  return err;
}","static int hv_shield_init(const struct device* dev) {
    int ret;

    ret = gpio_request(dev->data->oe_gpio, ""hv_shield_oe"");
    if (ret) {
        dev_err(dev, ""Failed to request OE GPIO: %d\n"", ret);
        return ret;
    }

    ret = gpio_direction_output(dev->data->oe_gpio, dev->data->oe_gpio_state);
    if (ret) {
        dev_err(dev, ""Failed to set OE GPIO direction: %d\n"", ret);
        gpio_free(dev->data->oe_gpio);
        return ret;
    }

    memset(dev->data->hw_reg, 0, sizeof(dev->data->hw_reg));

    ret = gpio_set_value(dev->data->oe_gpio, dev->data->oe_gpio_state);
    if (ret) {
        dev_err(dev, ""Failed to set OE GPIO value: %d\n"", ret);
        gpio_free(dev->data->oe_gpio);
        return ret;
    }

    return 0;
}
docs/api/c/hv_shield.md
# HV Shield Driver

## Overview

The HV Shield driver provides a way to control the high-voltage shield of the HV-1000 power supply. The shield is used to protect the user from high voltages and is controlled by a GPIO pin.

## API

### `hv_shield_init()`

Initializes the HV shield by configuring its Output Enable (OE) GPIO, writing a zeroed state to its hardware registers, and then setting the OE pin to enable the device's outputs, logging errors at each step.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   0 on success
*   Negative error code on failure

### `hv_shield_enable()`

Enables the HV shield by setting the OE pin to high.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   0 on success
*   Negative error code on failure

### `hv_shield_disable()`

Disables the HV shield by setting the OE pin to low.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   0 on success
*   Negative error code on failure

### `hv_shield_get_status()`

Returns the current status of the HV shield.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   0 if the shield is enabled
*   1 if the shield is disabled
*   Negative error code on failure

### `hv_shield_set_status()`

Sets the current status of the HV shield.

**Parameters**

*   `dev` - The device struct.
*   `status` - The desired status of the shield (0 for enabled, 1 for disabled).

**Returns**

*   0 on success
*   Negative error code on failure

### `hv_shield_get_hw_reg()`

Returns the current state of the hardware registers.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   Pointer to the hardware registers.

### `hv_shield_set_hw_reg()`

Sets the current state of the hardware registers.

**Parameters**

*   `dev` - The device struct.
*   `hw_reg` - The desired state of the hardware registers.

**Returns**

*   0 on","static int hv_shield_init(const struct device* dev) {
    int ret;

    ret = gpio_request(dev->data->oe_gpio, ""hv_shield_oe"");
    if (ret) {
        dev_err(dev, ""Failed to request OE GPIO: %d\n"", ret);
        return ret;
    }

    ret = gpio_direction_output(dev->data->oe_gpio, dev->data->oe_gpio_state);
    if (ret) {
        dev_err(dev, ""Failed to set OE GPIO direction: %d\n"", ret);
        gpio_free(dev->data->oe_gpio);
        return ret;
    }

    memset(dev->data->hw_reg, 0, sizeof(dev->data->hw_reg));

    ret = gpio_set_value(dev->data->oe_gpio, dev->data->oe_gpio_state);
    if (ret) {
        dev_err(dev, ""Failed to set OE GPIO value: %d\n"", ret);
        gpio_free(dev->data->oe_gpio);
        return ret;
    }

    return 0;
}
docs/api/c/hv_shield.md
# HV Shield Driver

## Overview

The HV Shield driver provides a way to control the high-voltage shield of the HV-1000 power supply. The shield is used to protect the user from high voltages and is controlled by a GPIO pin.

## API

### `hv_shield_init()`

Initializes the HV shield by configuring its Output Enable (OE) GPIO, writing a zeroed state to its hardware registers, and then setting the OE pin to enable the device's outputs, logging errors at each step.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   0 on success
*   Negative error code on failure

### `hv_shield_enable()`

Enables the HV shield by setting the OE pin to high.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   0 on success
*   Negative error code on failure

### `hv_shield_disable()`

Disables the HV shield by setting the OE pin to low.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   0 on success
*   Negative error code on failure

### `hv_shield_get_status()`

Returns the current status of the HV shield.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   0 if the shield is enabled
*   1 if the shield is disabled
*   Negative error code on failure

### `hv_shield_set_status()`

Sets the current status of the HV shield.

**Parameters**

*   `dev` - The device struct.
*   `status` - The desired status of the shield (0 for enabled, 1 for disabled).

**Returns**

*   0 on success
*   Negative error code on failure

### `hv_shield_get_hw_reg()`

Returns the current state of the hardware registers.

**Parameters**

*   `dev` - The device struct.

**Returns**

*   Pointer to the hardware registers.

### `hv_shield_set_hw_reg()`

Sets the current state of the hardware registers.

**Parameters**

*   `dev` - The device struct.
*   `hw_reg` - The desired state of the hardware registers.

**Returns**

*   0 on success",23.86641289988416,2.2026066145001595,12.524382058435263,42.028985507246375,38.70967741935484
90,c,"static int hvs_set_dac_gain(const struct device* dev,
                            uint8_t dac,
                            enum hv_shield_dac_gains_t gain) {
  if (dac > 1) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;
  switch (dac) {
    case 0:
      data->registers.dac0 = gain;
      break;
    case 1:
      data->registers.dac1 = gain;
      break;
    default:
      return -EINVAL;
  }

  return _hv_shield_update(dev);
}","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
    if (dac > 1) {
        return -EINVAL;
    }

    struct hv_shield_dac_gains_data* data = dev->data;
    data->gains[dac] = gain;

    return hv_shield_update_dac_gains(dev, data);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
    if (dac > 1) {
        return -EINVAL;
    }

    struct hv_shield_dac_gains_data* data = dev->data;
    data->gains[dac] = gain;

    return hv_shield_update_dac_gains(dev, data);
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);
    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}
#include <stdio.h>
#include <stdlib.h",40.36800926261962,8.11909673576495,43.903179549163305,56.81818181818182,52.63157894736842
91,c,"static int hvs_set_gpio_output_enable(const struct device* dev,
                                      uint8_t index,
                                      bool enable) {
  if (index > 31) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;

  if (index % 8 < 4) {
    index += 4;
  } else {
    index -= 4;
  }

  if (enable) {
    data->registers.gpio_output |= 1 << index;
  } else {
    data->registers.gpio_output &= ~(1 << index);
  }

  return _hv_shield_update(dev);
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
    uint8_t nibble_swapped_index = (index >> 4) | ((index & 0x0f) << 4);
    uint32_t cached_register = dev->data->gpio_output_enable_register;
    uint32_t mask = (1 << nibble_swapped_index);

    if (enable) {
        cached_register |= mask;
    } else {
        cached_register &= ~mask;
    }

    dev->data->gpio_output_enable_register = cached_register;
    hvs_write_gpio_output_enable(dev, cached_register);

    return 0;
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
    uint8_t nibble_swapped_index = (index >> 4) | ((index & 0x0f) << 4);
    uint32_t cached_register = dev->data->gpio_output_enable_register;
    uint32_t mask = (1 << nibble_swapped_index);

    if (enable) {
        cached_register |= mask;
    } else {
        cached_register &= ~mask;
    }

    dev->data->gpio_output_enable_register = cached_register;
    hvs_write_gpio_output_enable(dev, cached_register);

    return 0;
}",34.63230899417147,23.454186742090368,23.958697033337636,45.28301886792453,45.83333333333333
92,c,"static void can_router_frame_cb(const struct device *dev,
                                struct can_frame *frame,
                                void *user_data) {
  const struct device *to = user_data;

  const int err = can_send(to, frame, K_NO_WAIT, can_router_tx_cb, NULL);
  if (err) {
    LOG_WRN(""Can send failed (%d)"", err);
    return;
  }

  LOG_DBG(""Routed frame from %s to %s"", dev->name, to->name);
}","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
    struct can_device *can_dev = user_data;
    int ret;

    if (!can_dev) {
        return;
    }

    ret = can_bus_send(can_dev->bus, frame, 0);

    if (ret == 0) {
        dev_info(dev, ""CAN frame forwarded to destination\n"");
    } else {
        dev_warn(dev, ""Failed to forward CAN frame to destination\n"");
    }
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the Linux kernel's CAN bus driver.

## Overview

The CAN bus driver provides a generic interface for accessing CAN controllers and managing CAN messages. It supports both raw CAN access and a higher-level API for sending and receiving CAN messages.

## API Reference

### `struct can_device`

The `can_device` structure represents a CAN device.

```c
struct can_device {
    struct device *dev;
    struct can_bus *bus;
    struct mutex mutex;
    struct list_head can_rx_list;
    struct list_head can_tx_list;
    struct can_frame can_rx_frame;
    struct can_frame can_tx_frame;
    struct tasklet_struct can_tasklet;
    struct can_frame can_tx_frame_pending;
    struct can_frame can_rx_frame_pending;
    struct can_frame can_rx_frame_last;
    struct can_frame can_tx_frame_last;
    struct can_frame can_rx_frame_error;
    struct can_frame can_tx_frame_error;
    struct can_frame can_rx_frame_fifo;
    struct can_frame can_tx_frame_fifo;
    struct can_frame can_rx_frame_fifo_error;
    struct can_frame can_tx_frame_fifo_error;
    struct can_frame can_rx_frame_error_fifo;
    struct can_frame can_tx_frame_error_fifo;
    struct can_frame can_rx_frame_error_fifo_error;
    struct can_frame can_tx_frame_error_fifo_error;
    struct can_frame can_rx_frame_error_fifo_error_fifo;
    struct can_frame can_tx_frame_error_fifo_error_fifo;
    struct can_frame can_rx_frame_error_fifo_error_fifo_error;
    struct can_frame can_tx_frame_error_fifo_error_fifo_error;
    struct can_frame can_rx_frame_error_fifo_error_fifo_error_fifo;
    struct can_frame can_tx_frame_error_fifo_error_fifo_error_fifo_error;
    struct can_frame can_rx_frame_error_fifo_error_fifo_error_fifo_error_fifo;
    struct can_frame can_tx_frame_error_fifo_error_fifo_error_fifo_error_fifo_error;
    struct can_frame can_rx_frame_error_fifo_error_fifo_error_fifo_error_fifo_error_fifo_error;
    struct can_frame can_tx_frame_error_fifo_error_fifo_error_fifo_error_fifo_error","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
    struct can_device *can_dev = user_data;
    int ret;

    if (!can_dev) {
        return;
    }

    ret = can_bus_send(can_dev->bus, frame, 0);

    if (ret == 0) {
        dev_info(dev, ""CAN frame forwarded to destination\n"");
    } else {
        dev_warn(dev, ""Failed to forward CAN frame to destination\n"");
    }
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the Linux kernel's CAN bus driver.

## Overview

The CAN bus driver provides a generic interface for accessing CAN controllers and managing CAN messages. It supports both raw CAN access and a higher-level API for sending and receiving CAN messages.

## API Reference

### `struct can_device`

The `can_device` structure represents a CAN device.

```c
struct can_device {
    struct device *dev;
    struct can_bus *bus;
    struct mutex mutex;
    struct list_head can_rx_list;
    struct list_head can_tx_list;
    struct can_frame can_rx_frame;
    struct can_frame can_tx_frame;
    struct tasklet_struct can_tasklet;
    struct can_frame can_tx_frame_pending;
    struct can_frame can_rx_frame_pending;
    struct can_frame can_rx_frame_last;
    struct can_frame can_tx_frame_last;
    struct can_frame can_rx_frame_error;
    struct can_frame can_tx_frame_error;
    struct can_frame can_rx_frame_fifo;
    struct can_frame can_tx_frame_fifo;
    struct can_frame can_rx_frame_fifo_error;
    struct can_frame can_tx_frame_fifo_error;
    struct can_frame can_rx_frame_error_fifo;
    struct can_frame can_tx_frame_error_fifo;
    struct can_frame can_rx_frame_error_fifo_error;
    struct can_frame can_tx_frame_error_fifo_error;
    struct can_frame can_rx_frame_error_fifo_error_fifo;
    struct can_frame can_tx_frame_error_fifo_error_fifo_error;
    struct can_frame can_rx_frame_error_fifo_error_fifo_error_fifo;
    struct can_frame can_tx_frame_error_fifo_error_fifo_error_fifo_error;
}
```
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the Linux kernel's CAN bus driver.

## Overview

The CAN bus driver provides a generic interface for accessing CAN controllers and managing CAN messages. It supports both raw CAN access and a higher-level API for sending and receiving CAN messages.

## API Reference

### `struct can_device`

The `can_device` structure represents a CAN device.

```c
struct can_device {
    struct device *dev;
    struct can_bus *bus;
    struct mutex mutex;
    struct list_head can_rx_list;
    struct list_head can_tx_list;
    struct can_frame can",42.78878009098622,6.214180497408612,31.607606533202937,50.0,83.33333333333334
93,c,"int can_router_register(const struct can_router_entry_t *entries,
                        int entry_count) {
  LOG_DBG(""Registering %d can router entries"", entry_count);
  for (int i = 0; i < entry_count; i++) {
    const int err =
        can_add_rx_filter(*entries[i].from, can_router_frame_cb,
                          (void *)*entries[i].to, &entries[i].filter);
    if (err) {
      return err;
    }
  }

  LOG_DBG(""Registered %d can router entries"", entry_count);

  return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
    int i;
    for (i = 0; i < entry_count; i++) {
        if (can_add_filter(entries[i].source_if, entries[i].dest_if, entries[i].filter, entries[i].callback) != 0) {
            return -1;
        }
    }
    return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
    int i;
    for (i = 0; i < entry_count; i++) {
        if (can_add_filter(entries[i].source_if, entries[i].dest_if, entries[i].filter, entries[i].callback) != 0) {
            return -1;
        }
    }
    return 0;
}",40.52657778536438,28.9885526563602,33.0033420091248,36.95652173913043,63.1578947368421
94,c,"static int can_router_sysinit() {
  LOG_DBG(""Initializing can router"");

  STRUCT_SECTION_FOREACH (can_router_table_t, table) {
    int err = can_router_register(table->entries, table->entry_count);
    if (err) {
      LOG_ERR(""could not register can router"");
      return err;
    }
  }

  return 0;
}","static int can_router_sysinit() {
    int i;
    uint32_t *ptr;
    uint32_t *end_ptr;

    ptr = (uint32_t *)__start_can_routing_table;
    end_ptr = (uint32_t *)__end_can_routing_table;

    for (i = 0; ptr < end_ptr; i++) {
        if (can_router_register_entry(*ptr) != 0) {
            return -1;
        }
        ptr++;
    }

    return 0;
}","static int can_router_sysinit() {
    int i;
    uint32_t *ptr;
    uint32_t *end_ptr;

    ptr = (uint32_t *)__start_can_routing_table;
    end_ptr = (uint32_t *)__end_can_routing_table;

    for (i = 0; ptr < end_ptr; i++) {
        if (can_router_register_entry(*ptr) != 0) {
            return -1;
        }
        ptr++;
    }

    return 0;
}",20.214855907636313,13.989182687734841,19.74380416120123,13.793103448275861,33.33333333333333
95,c,"static int hvs_set_masked_raw(const struct device* port,
                              gpio_port_pins_t mask,
                              gpio_port_value_t value) {
  const struct hv_shield_gpio_config_t* config = port->config;

  for (int i = 0; i < config->lv_gpios_count; i++) {
    if (!(mask & BIT(i))) continue;

    int ret = gpio_pin_set(config->lv_gpios[i].port, config->lv_gpios[i].pin,
                           !!(value & BIT(i)));
    if (ret < 0) {
      LOG_ERR(""Error settings gpio %d (error %d)"", i, ret);
      return ret;
    }
  }

  return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
    int i;
    int ret;

    for (i = 0; i < 32; i++) {
        if ((mask >> i) & 0x1) {
            ret = gpio_set_pin(port, i, ((value >> i) & 0x1));
            if (ret) {
                LOG_ERR(""Failed to set GPIO %d\n"", i);
                return ret;
            }
        }
    }

    return 0;
}
 225555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
    int i;
    int ret;

    for (i = 0; i < 32; i++) {
        if ((mask >> i) & 0x1) {
            ret = gpio_set_pin(port, i, ((value >> i) & 0x1));
            if (ret) {
                LOG_ERR(""Failed to set GPIO %d\n"", i);
                return ret;
            }
        }
    }

    return 0;
}
 225555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555",38.472496991116785,33.80211524469778,35.27692095966506,27.11864406779661,57.692307692307686
96,c,"static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
  struct abstract_lin_data *data = dev->data;

  if (free_slots == NULL) {
    return -EINVAL;
  }

  *free_slots = CONFIG_ABSTRACT_LIN_MAX_FRAME_COUNT - data->used_callbacks;

  return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
    if (free_slots == NULL) {
        return -EINVAL;
    }

    *free_slots = dev->cb_max - dev->cb_used;

    return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
    if (free_slots == NULL) {
        return -EINVAL;
    }

    *free_slots = dev->cb_max - dev->cb_used;

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define MAX_LINE_LENGTH 1024

int main(int argc, char *argv[]) {
    FILE *file;
    char line[MAX_LINE_LENGTH];
    int count = 0;

    if (argc != 2) {
        fprintf(stderr, ""Usage: %s <filename>\n"", argv[0]);
        return 1;
    }

    file = fopen(argv[1], ""r"");
    if (file == NULL) {
        perror(""Error opening file"");
        return 1;
    }

    while (fgets(line, MAX_LINE_LENGTH, file) != NULL) {
        if (line[0] == '#') {
            continue;
        }
        count++;
    }

    fclose(file);

    printf(""Number of lines in the file: %d\n"", count);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define MAX_LINE_LENGTH 1024

int main(int argc, char *argv[]) {
    FILE *file;
    char line[MAX_LINE_LENGTH];
    int count = 0;

    if (argc != 2) {
        fprintf(stderr, ""Usage: %s <filename>\n"", argv[0]);
        return 1;
    }

    file = fopen(argv[1], ""r"");
    if (file == NULL) {
        perror(""Error opening file"");
        return 1;
    }

    while (fgets(line, MAX_LINE_LENGTH, file) != NULL) {
        if (line[0] == '#') {
            continue;
        }
        count++;
    }

    fclose(file);

    printf(""Number of lines in the file: %d\n"", count);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define MAX_LINE_LENGTH 1024

int main(int argc, char *argv[]) {
    FILE *file;
    char line[MAX_LINE_LENGTH];
    int count = 0;

    if (argc != 2) {
        fprintf(stderr, ""Usage: %s <filename>\n"", argv[0]);
        return 1;
    }

    file = fopen(argv[1], ""r"");
    if (file == NULL) {
        perror(""Error opening file"");
        return 1;
    }

    while (fgets(line, MAX_LINE_LENGTH, file) != NULL) {
        if (line[0] == '#') {
            continue;
        }
        count++;
    }

    fclose(file);

    printf(""Number of lines in the file: %d\n"", count);

    return 0;
}

#",63.9293444834293,60.562229523054434,61.82181507732941,73.33333333333333,60.0
97,c,"static int al_register_incoming_cb(const struct device *dev,
                                   abstract_lin_incoming_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = INCOMING;
  data->callbacks[free_index].incoming_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
        return -EINVAL;
    }

    if (dev->incoming_cb_count >= MAX_CALLBACKS) {
        return -ENOMEM;
    }

    dev->incoming_cb[dev->incoming_cb_count].callback = callback;
    dev->incoming_cb[dev->incoming_cb_count].frame_id = frame_id;
    dev->incoming_cb[dev->incoming_cb_count].frame_size = frame_size;
    dev->incoming_cb[dev->incoming_cb_count].user_data = user_data;
    dev->incoming_cb_count++;

    return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
        return -EINVAL;
    }

    if (dev->incoming_cb_count >= MAX_CALLBACKS) {
        return -ENOMEM;
    }

    dev->incoming_cb[dev->incoming_cb_count].callback = callback;
    dev->incoming_cb[dev->incoming_cb_count].frame_id = frame_id;
    dev->incoming_cb[dev->incoming_cb_count].frame_size = frame_size;
    dev->incoming_cb[dev->incoming_cb_count].user_data = user_data;
    dev->incoming_cb_count++;

    return 0;
}",47.405659053333316,43.226395740984486,45.69596036030395,41.17647058823529,59.523809523809526
98,c,"static int al_register_outgoing_cb(const struct device *dev,
                                   abstract_lin_outgoing_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = OUTGOING;
  data->callbacks[free_index].outgoing_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
        return -EINVAL;
    }

    if (dev->outgoing_cb_count >= dev->outgoing_cb_max) {
        return -ENOMEM;
    }

    dev->outgoing_cb_list[dev->outgoing_cb_count].callback = callback;
    dev->outgoing_cb_list[dev->outgoing_cb_count].frame_id = frame_id;
    dev->outgoing_cb_list[dev->outgoing_cb_count].frame_size = frame_size;
    dev->outgoing_cb_list[dev->outgoing_cb_count].user_data = user_data;
    dev->outgoing_cb_count++;

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;

    result = (char *)malloc(strlen(str1) + strlen(str2) + 1);

    if (result == NULL) {
        printf(""Memory allocation failed\n"");
        return 1;
    }

    strcpy(result, str1);
    strcat(result, str2);

    printf(""Concatenated string: %s\n"", result);

    free(result);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str1[100] = ""Hello"";
    char str2[100] = "" World"";
    char *result;","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
    if (frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
        return -EINVAL;
    }

    if (dev->outgoing_cb_count >= dev->outgoing_cb_max) {
        return -ENOMEM;
    }

    dev->outgoing_cb_list[dev->outgoing_cb_count].callback = callback;
    dev->outgoing_cb_list[dev->outgoing_cb_count].frame_id = frame_id;
    dev->outgoing_cb_list[dev->outgoing_cb_count].frame_size = frame_size;
    dev->outgoing_cb_list[dev->outgoing_cb_count].user_data = user_data;
    dev->outgoing_cb_count++;

    return 0;
}",42.47460497430802,14.019244530254502,46.91558993280391,47.05882352941176,61.904761904761905
99,c,"int abstract_lin_scheduler_set_active_table(
    abstract_lin_scheduler_handle_t sched, size_t table_index) {
  if (table_index >= sched->table_count) {
    return -ENOENT;
  }

  bool active_before = sched->current_table != -1;

  if (active_before) {
    k_sem_take(&sched->active, K_FOREVER);
  }

  sched->current_table = table_index;
  sched->current_table_entry = 0;  // start from the beginning again.

  k_sem_give(&sched->active);

  return 0;
}","int abstract_lin_scheduler_set_active_table(struct abstract_lin_scheduler *scheduler, int index) {
    if (index < 0 || index >= scheduler->num_tables) {
        return -1;
    }

    sem_wait(&scheduler->table_lock);
    scheduler->active_table = index;
    scheduler->entry_ptr = scheduler->tables[index];
    sem_post(&scheduler->table_lock);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <poll.h>
#include <sys/un.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/","int abstract_lin_scheduler_set_active_table(struct abstract_lin_scheduler *scheduler, int index) {
    if (index < 0 || index >= scheduler->num_tables) {
        return -1;
    }

    sem_wait(&scheduler->table_lock);
    scheduler->active_table = index;
    scheduler->entry_ptr = scheduler->tables[index];
    sem_post(&scheduler->table_lock);

    return 0;
}
docs/api/c/abstract_lin_scheduler.md
# Abstract LIN Scheduler

## Overview

The abstract LIN scheduler is a generic scheduler that can be used to schedule LIN messages. It is designed to be used by multiple applications and can be configured to use different scheduling algorithms.

## API

### `abstract_lin_scheduler_init()`

Initializes the abstract LIN scheduler.

```c
int abstract_lin_scheduler_init(struct abstract_lin_scheduler *scheduler,
                                int num_tables,
                                int max_messages_per_table,
                                int max_messages_per_app,
                                int max_messages_per_msg,
                                int max_msg_size,
                                int max_msg_length,
                                int max_msg_id,
                                int max_msg_type,
                                int max_msg_length_field,
                                int max_msg_length_field_value,
                                int max_msg_length_field_value_length,
                                int max_msg_length_field_value_length_length,
                                int max_msg_length_field_value_length_length_length,
                                int max_msg_length_field_value_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length_length_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length,
                                int max_msg_length_field_value_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length_length,",26.76393190610904,0.9069772415990471,4.04348722494239,42.10526315789473,60.0
100,c,"void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
  if (sched->current_table == -1) {
    return;  // already stopped.
  }

  k_sem_take(&sched->active, K_FOREVER);

  sched->current_table = -1;
}","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
    if (sched->is_stopped) {
        return;
    }

    sem_wait(&sched->sem);
    sched->active_schedule_table_index = -1;
    sem_post(&sched->sem);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <poll.h>
#include <sys/un.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
    if (sched->is_stopped) {
        return;
    }

    sem_wait(&sched->sem);
    sched->active_schedule_table_index = -1;
    sem_post(&sched->sem);
}
docs/api/c/abstract_lin_scheduler_disable.md
# abstract_lin_scheduler_disable

## Description

Disables a LIN scheduler by first checking if it's already stopped, then taking a semaphore to safely wait for the current operation to complete before setting the active schedule table index to -1.

## Parameters

*   `sched` - The handle of the LIN scheduler to disable.

## Return Value

None.
docs/api/c/abstract_lin_scheduler_init.md
# abstract_lin_scheduler_init

## Description

Initializes a LIN scheduler.

## Parameters

*   `sched` - The handle of the LIN scheduler to initialize.

## Return Value

None.
docs/api/c/abstract_lin_scheduler_start.md
# abstract_lin_scheduler_start

## Description

Starts a LIN scheduler.

## Parameters

*   `sched` - The handle of the LIN scheduler to start.

## Return Value

None.
docs/api/c/abstract_lin_scheduler_stop.md
# abstract_lin_scheduler_stop

## Description

Stops a LIN scheduler.

## Parameters

*   `sched` - The handle of the LIN scheduler to stop.

## Return Value

None.
docs/api/c/abstract_lin_scheduler_wait_for_completion.md
# abstract_lin_scheduler_wait_for_completion

## Description

Waits for a LIN scheduler to complete its current operation.

## Parameters

*   `sched` - The handle of the LIN scheduler to wait for.

## Return Value

None.
docs/api/c/abstract_lin_scheduler_wait_for_message.md
# abstract_lin_scheduler_wait_for_message

## Description

Waits for a LIN scheduler to receive a message.

## Parameters

*   `sched` - The handle of the LIN scheduler to wait for.

## Return Value

None.
docs/api/c/abstract_lin_scheduler_wait_for_message_timeout.md
# abstract_lin_scheduler_wait_for_message_timeout

## Description

Waits for a LIN scheduler to receive a message with a timeout.

## Parameters

*   `sched` - The handle of the LIN scheduler to wait for.
*   `timeout` - The timeout in milliseconds.

## Return Value

None.
docs/api/c/abstract_lin_scheduler_wait_for_message_timeout_ms.md
# abstract_lin_scheduler_wait_for_message_timeout_ms

## Description

Waits for a LIN scheduler to receive a message with a timeout.

## Parameters

*   `sched` - The handle of the LIN scheduler to wait for.
*   `timeout` - The timeout in milliseconds.

## Return Value

None.
docs/api/c/abstract_lin_scheduler_wait_for_message_timeout_ns.md
# abstract_lin_scheduler_wait_for_message_timeout_ns

## Description

Waits for a LIN scheduler to receive a message with a timeout.

## Parameters

*   `sched` - The handle of the LIN scheduler to wait for.
*   `timeout` - The timeout in nanoseconds.

## Return Value",45.82306066926714,2.8323973603317993,25.45984531673679,55.00000000000001,100.0
