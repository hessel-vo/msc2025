id,language,reference,generated,generated_rci,codebleu,ngram_match_score,weighted_ngram_match_score,syntax_match_score,dataflow_match_score
2,python,"def is_datatype(cls, value: Any, datatype: str) -> bool:
    t = cls.get_type(datatype)
    if t is None:
        raise DatatypesException(f""Unsupported datatype: {datatype}"")
    return t[1](value)","def is_datatype(cls, value: Any, datatype: str) -> bool:
    value_type = cls.get_type(value)
    if not value_type:
        raise DatatypesException(f""Not a valid type: '{value}'"")
    datatype_type = cls.get_type(datatype)
    if not datatype_type:
        raise DatatypesException(f""Not a valid type: '{datatype}'"")
    return value_type in datatype_type[2] or value_type == datatype","def is_datatype(cls, value: Any, datatype: str) -> bool:
    value_type = cls.get_type(value)
    if not value_type:
        raise DatatypesException(f""Not a valid type: '{value}'"")
    datatype_type = cls.get_type(datatype)
    if not datatype_type:
        raise DatatypesException(f""Not a valid type: '{datatype}'"")
    return value_type in datatype_type[2] or value_type == datatype",51.77901702519814,20.786721468392393,42.48319278624633,53.84615384615385,90.0
3,python,"def is_xintx(value: Any, signed: bool, bits: int):
    values = [value]
    if isinstance(value, list):
        values = value

    for v in values:
        if not isinstance(v, int):
            return False
        if not signed and v < 0:
            return False
        max = 2**bits - 1
        min = 0
        if signed:
            max = 2 ** (bits - 1) - 1
            min = -(2 ** (bits - 1))
        if not (v <= max and v >= min):
            return False
    return True","from typing import Any, List

def is_xintx(value: Any, signed: bool, bits: int):
    if isinstance(value, list):
        return all(is_xintx(v, signed, bits) for v in value)
    if isinstance(value, int):
        if signed:
            return -2 ** (bits - 1) <= value < 2 ** bits
        else:
            return 0 <= value < 2 ** bits
    return False","from typing import Any, List

def is_xintx(value: Any, signed: bool, bits: int):
    if isinstance(value, list):
        return all(is_xintx(v, signed, bits) for v in value)
    if isinstance(value, int):
        if signed:
            return -2 ** (bits - 1) <= value < 2 ** bits
        else:
            return 0 <= value < 2 ** bits
    return False",26.120959594158442,15.858713323008045,17.45395388245454,33.33333333333333,37.83783783783784
4,python,"def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
        for t in cls.types:
            if datatype == t[0]:
                return t
        return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_def in cls.types:
        if type_def[0] == datatype:
            return type_def
    return None","def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
    for type_def in cls.types:
        if type_def[0] == datatype:
            return type_def
    return None",72.51558048642302,57.14392512385289,58.84432274776513,74.07407407407408,100.0
5,python,"def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if not fqn:
        return {}
    fqn_namespaced_datatypes = {}
    for t in dynamic_datatypes:
        if fqn.startswith(t):
            continue

        if fqn.startswith(""."".join(t.split(""."")[:-1])):
            fqn_namespaced_datatypes[(t.split(""."")[-1])] = t

    if fqn_namespaced_datatypes:
        log.debug(f""Namespaced datatypes, {fqn=}, {fqn_namespaced_datatypes=}"")
    return fqn_namespaced_datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn is None:
        fqn = get_fqn()
    fqn_parts = fqn.split(""."")
    fqn_namespaced_datatypes = {}
    for i in range(len(fqn_parts)):
        fqn_namespaced_datatypes.update(get_namespaced_datatypes(""."".join(fqn_parts[: i + 1])))
    return fqn_namespaced_datatypes","def get_fqn_namespaced_datatypes(fqn: str | None = None) -> dict[str, str]:
    if fqn is None:
        fqn = get_fqn()
    fqn_parts = fqn.split(""."")
    fqn_namespaced_datatypes = {}
    for i in range(len(fqn_parts)):
        fqn_namespaced_datatypes.update(get_namespaced_datatypes(""."".join(fqn_parts[: i + 1])))
    return fqn_namespaced_datatypes",40.39806733363196,34.776854384207894,34.91726680217182,43.75,48.148148148148145
7,python,"def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    is_array = False
    apigear_type = None
    if t.endswith(""[]""):
        is_array = True
        t = t[0:-2]

    if t in [""int8"", ""int16"", ""int32"", ""uint8"", ""uint16"", ""uint32""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT32.value)
    elif t in [""int64"", ""uint64""]:
        apigear_type = ApiGearType(ApiGearBasicType.INT64.value)
    elif t == ""float"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT32.value)
    elif t == ""double"":
        apigear_type = ApiGearType(ApiGearBasicType.FLOAT64.value)
    elif t == ""boolean"":
        apigear_type = ApiGearType(ApiGearBasicType.BOOL.value)
    elif t == ""string"":
        apigear_type = ApiGearType(ApiGearBasicType.STRING.value)
    else:
        apigear_type = ApiGearType(t.replace(""."", ""_""))

    if is_array and apigear_type is not None:
        apigear_type.is_array = True

    return apigear_type","```python
def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    if t == ""string"":
        return ApiGearType(t, ""string"", [
            ""string"",
            ""str"",
            ""text""
        ])
    elif t == ""integer"":
        return ApiGearType(t, ""integer"", [
            ""integer"",
            ""int"",
            ""number""
        ])
    elif t == ""float"":
        return ApiGearType(t, ""float"", [
            ""float"",
            ""number"",
            ""decimal""
        ])
    elif t == ""boolean"":
        return ApiGearType(t, ""boolean"", [
            ""boolean"",
            ""bool"",
            ""true"",
            ""false""
        ])
    elif t == ""array"":
        return ApiGearType(t, ""array"", [
            ""array"",
            ""list"",
            ""[]""
        ])
    elif t == ""object"":
        return ApiGearType(t, ""object"", [
            ""object"",
            ""dict"",
            ""{""
        ])
    elif t == ""null"":
        return ApiGearType(t, ""null"", [
            ""null"",
            ""None""
        ])
    elif t == ""date"":
        return ApiGearType(t, ""date"", [
            ""date"",
            ""datetime""
        ])
    elif t == ""datetime"":
        return ApiGearType(t, ""datetime"", [
            ""date"",
            ""datetime""
        ])
    elif t == ""time"":
        return ApiGearType(t, ""time"", [
            ""time""
        ])
    elif t == ""timestamp"":
        return ApiGearType(t, ""timestamp"", [
            ""timestamp""
        ])
    elif t == ""enum"":
        return ApiGearType(t, ""enum"", [
            ""enum""
        ])
    elif t == ""binary"":
        return ApiGearType(t, ""binary"", [
            ""binary"",
            ""bytes""
        ])
    elif t == ""json"":
        return ApiGearType(t, ""json"", [
            ""json""
        ])
    elif t == ""uri"":
        return ApiGearType(t, ""uri"", [
            ""uri"",
            ""url""
        ])
    elif t == ""email"":
        return ApiGearType(t, ""email"", [
            ""email""
        ])
    elif t == ""ipv4"":
        return ApiGearType(t, ""ipv4"", [
            ""ipv4""
        ])
    elif t == ""ipv6"":
        return ApiGearType(t, ""ipv6"", [
            ""ipv6""
        ])
    elif t == ""mac"":
        return ApiGearType(t, ""mac"", [
            ""mac""
        ])
    elif t == ""uuid"":
        return ApiGearType(t, ""uuid"", [
            ""uuid""
        ])
    elif t == ""regex"":
        return ApiGearType(t, ""regex"", [
            ""regex""
        ])
    elif t == ""cidr"":
        return ApiGearType(t, ""cidr"", [
            ""cidr""
        ])
    elif t == ""rgb"":
        return ApiGearType(t, ""rgb"", [
            ""rgb""
        ])
    elif t == ""rgba"":
        return ApiGear","```python
def get_apigear_datatype(t: str) -> typing.Optional[ApiGearType]:
    if t == ""string"":
        return ApiGearType(t, ""string"", [
            ""string"",
            ""str"",
            ""text""
        ])
    elif t == ""integer"":
        return ApiGearType(t, ""integer"", [
            ""integer"",
            ""int"",
            ""number""
        ])
    elif t == ""float"":
        return ApiGearType(t, ""float"", [
            ""float"",
            ""number"",
            ""decimal""
        ])
    elif t == ""boolean"":
        return ApiGearType(t, ""boolean"", [
            ""boolean"",
            ""bool"",
            ""true"",
            ""false""
        ])
    elif t == ""array"":
        return ApiGearType(t, ""array"", [
            ""array"",
            ""list"",
            ""[]""
        ])
    elif t == ""object"":
        return ApiGearType(t, ""object"", [
            ""object"",
            ""dict"",
            ""{""
        ])
    elif t == ""null"":
        return ApiGearType(t, ""null"", [
            ""null"",
            ""None""
        ])
    elif t == ""date"":
        return ApiGearType(t, ""date"", [
            ""date"",
            ""datetime""
        ])
    elif t == ""datetime"":
        return ApiGearType(t, ""datetime"", [
            ""date"",
            ""datetime""
        ])
    elif t == ""time"":
        return ApiGearType(t, ""time"", [
            ""time""
        ])
    elif t == ""timestamp"":
        return ApiGearType(t, ""timestamp"", [
            ""timestamp""
        ])
    elif t == ""enum"":
        return ApiGearType(t, ""enum"", [
            ""enum""
        ])
    elif t == ""binary"":
        return ApiGearType(t, ""binary"", [
            ""binary"",
            ""bytes""
        ])
    elif t == ""json"":
        return ApiGearType(t, ""json"", [
            ""json""
        ])
    elif t == ""uri"":
        return ApiGearType(t, ""uri"", [
            ""uri"",
            ""url""
        ])
    elif t == ""email"":
        return ApiGearType(t, ""email"", [
            ""email""
        ])
    elif t == ""ipv4"":
        return ApiGearType(t, ""ipv4"", [
            ""ipv4""
        ])
    elif t == ""ipv6"":
        return ApiGearType(t, ""ipv6"", [
            ""ipv6""
        ])
    elif t == ""mac"":
        return ApiGearType(t, ""mac"", [
            ""mac""
        ])
    elif t == ""uuid"":
        return ApiGearType(t, ""uuid"", [
            ""uuid""
        ])
    elif t == ""regex"":
        return ApiGearType(t, ""regex"", [
            ""regex""
        ])
    elif t == ""cidr"":
        return ApiGearType(t, ""cidr"", [
            ""cidr""
        ])
    elif t == ""rgb"":
        return ApiGearType(t, ""rgb"", [
            ""rgb""
        ])
    elif t == ""rgba"":
        return ApiGear",20.09223590866914,4.460813637841844,14.541526195877214,31.858407079646017,29.508196721311474
8,python,"def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    apigear_type = get_apigear_datatype(datatype)
    data = node.get_vss_data()

    if apigear_type is None:
        log.warning(f""Datatype {datatype} of node {node.name} currently not supported"")
        return None

    property = ApiGearProperty(apigear_type)
    if data.description != """":
        property.description = data.description
    return property","```python
def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if not isinstance(node, VSSNode):
        raise TypeError(""node must be a VSSNode"")
    if not isinstance(datatype, str):
        raise TypeError(""datatype must be a string"")

    if node.type == ""STRUCT"":
        return None

    if node.type == ""FIELD"":
        return ApiGearProperty(
            name=node.name,
            datatype=datatype,
            bit_position=node.bit_position,
            bit_length=node.bit_length,
            is_array=node.is_array,
            is_optional=node.is_optional,
            is_volatile=node.is_volatile,
            is_constant=node.is_constant,
            is_static=node.is_static,
            is_external=node.is_external,
            is_union=node.is_union,
            is_enum=node.is_enum,
            is_bitfield=node.is_bitfield,
            is_packed=node.is_packed,
            is_signed=node.is_signed,
            is_little_endian=node.is_little_endian,
            is_big_endian=node.is_big_endian,
            is_unsigned=node.is_unsigned,
            is_byte_order_msb=node.is_byte_order_msb,
            is_byte_order_lsb=node.is_byte_order_lsb,
            is_byte_order_native=node.is_byte_order_native,
            is_byte_order_unknown=node.is_byte_order_unknown,
            is_byte_order_little_endian=node.is_byte_order_little_endian,
            is_byte_order_big_endian=node.is_byte_order_big_endian,
            is_byte_order_network=node.is_byte_order_network,
            is_byte_order_cpu=node.is_byte_order_cpu,
            is_byte_order_be=node.is_byte_order_be,
            is_byte_order_le=node.is_byte_order_le,
            is_byte_order_unknown_endian=node.is_byte_order_unknown_endian,
            is_byte_order_unknown_cpu=node.is_byte_order_unknown_cpu,
            is_byte_order_unknown_network=node.is_byte_order_unknown_network,
            is_byte_order_unknown_be=node.is_byte_order_unknown_be,
            is_byte_order_unknown_le=node.is_byte_order_unknown_le,
            is_byte_order_unknown_network=node.is_byte_order_unknown_network,
            is_byte_order_unknown_cpu=node.is_byte_order_unknown_cpu,
            is_byte_order_unknown_be=node.is_byte_order_unknown_be,
            is_byte_order_unknown_le=node.is_byte_order_unknown_le,
            is_byte_order_unknown_network=node.is_byte_order_unknown_network,
            is_byte_order_unknown_cpu=node.is_byte_order_unknown_cpu,
            is_byte_","```python
def generate_property(node: VSSNode, datatype: str) -> ApiGearProperty | None:
    if not isinstance(node, VSSNode):
        raise TypeError(""node must be a VSSNode"")
    if not isinstance(datatype, str):
        raise TypeError(""datatype must be a string"")

    if node.type == ""STRUCT"":
        return None

    if node.type == ""FIELD"":
        return ApiGearProperty(
            name=node.name,
            datatype=datatype,
            bit_position=node.bit_position,
            bit_length=node.bit_length,
            is_array=node.is_array,
            is_optional=node.is_optional,
            is_volatile=node.is_volatile,
            is_constant=node.is_constant,
            is_static=node.is_static,
            is_external=node.is_external,
            is_union=node.is_union,
            is_enum=node.is_enum,
            is_bitfield=node.is_bitfield,
            is_packed=node.is_packed,
            is_signed=node.is_signed,
            is_little_endian=node.is_little_endian,
            is_big_endian=node.is_big_endian,
            is_unsigned=node.is_unsigned,
            is_byte_order_msb=node.is_byte_order_msb,
            is_byte_order_lsb=node.is_byte_order_lsb,
            is_byte_order_native=node.is_byte_order_native,
            is_byte_order_unknown=node.is_byte_order_unknown,
            is_byte_order_little_endian=node.is_byte_order_little_endian,
            is_byte_order_big_endian=node.is_byte_order_big_endian,
            is_byte_order_network=node.is_byte_order_network,
            is_byte_order_cpu=node.is_byte_order_cpu,
            is_byte_order_be=node.is_byte_order_be,
            is_byte_order_le=node.is_byte_order_le,
            is_byte_order_unknown_endian=node.is_byte_order_unknown_endian,
            is_byte_order_unknown_cpu=node.is_byte_order_unknown_cpu,
            is_byte_order_unknown_network=node.is_byte_order_unknown_network,
            is_byte_order_unknown_be=node.is_byte_order_unknown_be,
            is_byte_order_unknown_le=node.is_byte_order_unknown_le,
            is_byte_order_unknown_network=node.is_byte_order_unknown_network,
            is_byte_order_unknown_cpu=node.is_byte_order_unknown_cpu,
            is_byte_order_unknown_be=node.is_byte_order_unknown_be,
            is_byte_order_unknown_le=node.is_byte_order_unknown_le,
            is_byte_order_unknown_network=node.is_byte_order_unknown_network,
            is_byte_order_unknown_cpu=node.is_byte_order_unknown_cpu,
        )
    return",33.46750218785388,10.780571327308477,24.75610409077372,33.33333333333333,65.0
10,python,"def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    spec = None
    vspecs: list[VSpec] = []
    for s in specs:
        includes = [s.parent] + include_dirs
        vspecs.extend(get_vspecs(includes, s))
    pre = ""VSpecs""
    if identifier:
        pre += f"" ({identifier})""
    log.info(f""{pre} loaded, amount={len(vspecs)}"")
    for vspec in vspecs:
        log.debug(vspec)
        if spec is None:
            spec = vspec
        else:
            spec.update(vspec)
    if not spec:
        msg = f""Weird behavior. Could not load any spec: {specs}""
        log.error(msg)
        raise SpecException(msg)
    return spec","from pathlib import Path

from vspec.vspec import VSpec
from vspec.exceptions import VSpecException
from vspec.utils import load_vspec_from_file


def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    """"""Loads and merges multiple VSpec files from specified paths into a single VSpec object""""""
    vspec = VSpec(identifier)
    for path in include_dirs:
        vspec.include_dir(path)
    for path in specs:
        try:
            vspec.load_from_file(path)
        except VSpecException as e:
            raise VSpecException(f""Failed to load VSpec from '{path}': {e}"")
    return vspec","from pathlib import Path

from vspec.vspec import VSpec
from vspec.exceptions import VSpecException
from vspec.utils import load_vspec_from_file


def load_vspec(include_dirs: list[Path], specs: list[Path], identifier: str | None = None) -> VSpec:
    """"""Loads and merges multiple VSpec files from specified paths into a single VSpec object""""""
    vspec = VSpec(identifier)
    for path in include_dirs:
        vspec.include_dir(path)
    for path in specs:
        try:
            load_vspec_from_file(vspec, path)
        except VSpecException as e:
            raise VSpecException(f""Failed to load VSpec from '{path}': {e}"")
    return vspec",30.815612663229064,18.51360216356618,19.7617683859909,47.77777777777778,37.2093023255814
11,python,"def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for key, value in update.items():
        if isinstance(value, dict):
            if key in base and isinstance(base[key], dict):
                deep_update(base[key], value)
            else:
                base[key] = value
        else:
            base[key] = value","def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for k, v in update.items():
        if isinstance(v, dict) and k in base and isinstance(base[k], dict):
            deep_update(base[k], v)
        else:
            base[k] = v","def deep_update(base: dict[str, Any], update: dict[str, Any]) -> None:
    for k, v in update.items():
        if isinstance(v, dict) and k in base and isinstance(base[k], dict):
            deep_update(base[k], v)
        else:
            base[k] = v",61.09433177212898,35.2397286283442,37.262598460171745,81.25,90.625
12,python,"def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return v
    pattern = r""^0x[0-9A-Fa-f]{8}$""
    assert bool(re.match(pattern, v)), f""'{v}' is not a valid 'constUID'""
    return v","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if not isinstance(v, str):
        raise ValueError(f""Expected a string, got {type(v)}"")
    if len(v) != 8:
        raise ValueError(f""Expected a 32-bit hexadecimal string, got '{v}'"")
    try:
        int(v, 16)
    except ValueError:
        raise ValueError(f""Expected a 32-bit hexadecimal string, got '{v}'"")
    return v","def check_const_uid_format(cls, v: str | None) -> str | None:
    if v is None:
        return None
    if not isinstance(v, str):
        raise ValueError(f""Expected a string, got {type(v)}"")
    if len(v) != 8:
        raise ValueError(f""Expected a 32-bit hexadecimal string, got '{v}'"")
    if not all(c in '0123456789abcdefABCDEF' for c in v):
        raise ValueError(f""Expected a 32-bit hexadecimal string, got '{v}'"")
    return v",52.090792400576504,28.20249404360991,52.16067555869613,48.0,80.0
13,python,"def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    model = VSSRaw(fqn=fqn, **data)
    try:
        model = resolve_vss_raw(model)
    except (ValidationError, ModelException):
        log.debug(f""'{fqn}', incomplete, initialized as '{model.__class__.__name__}'"")
        return model
    return model","def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    vss_raw = VSSRaw(data)
    if not vss_raw.resolve(fqn):
        return vss_raw
    return None","def get_vss_raw(data: dict[str, Any], fqn: str | None) -> VSSRaw:
    vss_raw = VSSRaw(data)
    if not vss_raw.resolve(fqn):
        return vss_raw
    return None",44.11516152867524,29.55084986581822,32.7431295822161,47.5,66.66666666666666
14,python,"def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    datatypes = get_all_datatypes()
    for value in values:
        assert value in datatypes, f""Invalid datatype: '{value}'""
    return values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_values = []
    for value in values:
        if value in cls.datatypes:
            valid_values.append(value)
        else:
            raise DatatypesException(f""Not a valid datatype: '{value}'"")
    return valid_values","def check_valid_datatypes(cls, values: list[str]) -> list[str]:
    valid_values = []
    for value in values:
        if value not in cls.datatypes:
            raise DatatypesException(f""Not a valid datatype: '{value}'"")
        valid_values.append(value)
    return valid_values",49.16611868753269,29.615165360116247,37.88264272334785,54.166666666666664,75.0
15,python,"def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    tree_content_lines = []
    for pre, fill, node in RenderTree(tree):
        tree_content_lines.append(""%s%s"" % (pre, node.name))
        for attribute in attributes:
            content = getattr(node.data, attribute, None)
            if content is None:
                continue
            if isinstance(content, str):
                tree_content_lines.append(""%s%s='%s'"" % (fill, attribute, content))
            else:
                tree_content_lines.append(""%s%s=%s"" % (fill, attribute, content))
    return ""\n"".join(tree_content_lines)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    def render_node(node: VSSNode, indent: int) -> str:
        rendered = """"
        for attribute in attributes:
            value = getattr(node, attribute)
            if isinstance(value, list):
                value = "", "".join(str(item) for item in value)
            rendered += f""{' ' * indent}{attribute}: {value}\n""
        rendered += f""{' ' * indent}children:\n""
        for child in node.children:
            rendered += render_node(child, indent + 4)
        return rendered

    return render_node(tree, 0)","def get_rendered_tree(tree: VSSNode, attributes: tuple[str]) -> str:
    def render_node(node: VSSNode, indent: int) -> str:
        rendered = """"
        for attribute in attributes:
            value = getattr(node, attribute)
            if isinstance(value, list):
                value = "", "".join(str(item) for item in value)
            rendered += f""{' ' * indent}{attribute}: {value}\n""
        if node.children:
            rendered += f""{' ' * indent}children:\n""
            for child in node.children:
                rendered += render_node(child, indent + 4)
        return rendered

    return render_node(tree, 0)",28.967661536564936,13.68924060480763,19.42836910420517,35.38461538461539,47.368421052631575
16,python,"def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if not isinstance(self.data, VSSDataBranch):
        raise NoInstanceRootException()

    if not self.data.is_instance:
        return self, depth

    if self.parent is None:
        raise NoInstanceRootException()

    return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if depth > 100:
        raise ValueError(""Maximum recursion depth reached"")
    if self.parent is None:
        return self, depth
    return self.parent.get_instance_root(depth + 1)","def get_instance_root(self, depth: int = 0) -> tuple[VSSNode, int]:
    if depth > 100:
        raise ValueError(""Maximum recursion depth reached"")
    if self.parent is None:
        return self, depth
    return self.parent.get_instance_root(depth + 1)",55.213104641521625,49.129205062021036,48.302160872486525,55.00000000000001,68.42105263157895
17,python,"def count_instance_children_depth(self) -> int:
    for child in self.children:
        if isinstance(child.data, VSSDataBranch):
            if child.data.is_instance:
                return 1 + child.count_instance_children_depth()
    return 0","def count_instance_children_depth(self) -> int:
    depth = 0
    while self.parent is not None:
        depth += 1
        self = self.parent
    return depth","def count_instance_children_depth(self) -> int:
    depth = 0
    if self.parent is not None:
        while self.parent is not None:
            depth += 1
            self = self.parent
    return depth",24.198239791888565,13.78592993183041,14.062929856841858,26.08695652173913,42.857142857142854
18,python,"def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    ids = []
    for i in node_ids:
        if get_expected_parent(i) == name:
            ids.append(i)
    return ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        if node_id.split('_')[1] == name:
            children_ids.append(node_id)
    return children_ids","def find_children_ids(node_ids: list[str], name: str) -> list[str]:
    children_ids = []
    for node_id in node_ids:
        if node_id.split('_')[1] == name:
            children_ids.append(node_id)
    return children_ids",65.24065932875062,43.03767738122004,44.591626600449125,73.33333333333333,100.0
19,python,"def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    result = getattr(o, name, default)
    if result is None and default is not None:
        result = default
    return result","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        value = getattr(o, name)
        if value is None:
            return default
        return value
    except AttributeError:
        return default","def getattr_nn(o: object, name: str, default: Any | None = None) -> Any:
    try:
        value = getattr(o, name)
        if value is None:
            return default
        return value
    except AttributeError:
        return default",54.28198999477352,44.05262339943716,43.07533657965687,50.0,80.0
20,python,"def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    fd.write('syntax = ""proto3"";\n\n')

    imports = []
    for node in findall(tree, filter_=lambda n: isinstance(n.data, VSSDataDatatype)):
        datatype = node.data.datatype
        if ""."" not in datatype:
            continue
        struct_path = Path(node.data.datatype.replace(""."", ""/""))  # type: ignore
        imports.append(f""{struct_path.parent}/{struct_path.parent.name}.proto"")
    write_imports(fd, imports)

    # write proto messages to file
    for node in findall(tree, filter_=lambda node: isinstance(node.data, VSSDataBranch)):
        fd.write(f""message {node.get_fqn('')} {{"" + ""\n"")
        print_messages(node.children, fd, static_uid, add_optional)
        fd.write(""}\n\n"")","```python
def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""signal"":
        fd.write(f""message {tree.name} {{\n"")
        for child in tree.children:
            if child.type == ""signal_type"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_unit"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_length"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_bit_length"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_endianness"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_offset"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_multiplier"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_divisor"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_min"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_max"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_type"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_unit"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_min"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_max"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_step"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_default"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_enum"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_enum_min"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_","```python
def traverse_signal_tree(tree: VSSNode, fd: TextIOWrapper, static_uid: bool, add_optional: bool):
    if tree.type == ""signal"":
        fd.write(f""message {tree.name} {{\n"")
        for child in tree.children:
            if child.type == ""signal_type"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_unit"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_length"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_bit_length"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_endianness"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_offset"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_multiplier"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_divisor"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_min"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_max"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_type"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_unit"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_min"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_max"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_step"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_default"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_enum"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_enum_min"":
                fd.write(f""  {child.name} = {child.value};\n"")
            elif child.type == ""signal_value_range_",20.764973357524585,4.7377162051660076,14.271012658303848,28.865979381443296,35.18518518518518
21,python,"def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    meta: dict[str, list[str]] = {}
    for node in PreOrderIter(root, filter_=lambda n: isinstance(n.data, VSSDataBranch) and n.data.is_instance):
        if any(c.data.is_instance for c in node.children if isinstance(c.data, VSSDataBranch)):
            continue
        instance_root, _ = node.get_instance_root()
        instance_root_fqn = instance_root.get_fqn()

        instance_name = node.get_fqn().removeprefix(instance_root_fqn + ""."")

        if instance_root_fqn in meta:
            meta[instance_root_fqn].append(instance_name)
        else:
            meta[instance_root_fqn] = [instance_name]
    return meta","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    for node in root.children:
        if isinstance(node, VSSBranch):
            instances[node.fqn] = [node.name]
        else:
            for child in node.children:
                if isinstance(child, VSSBranch):
                    instances[child.fqn] = [child.name]
    return instances","def get_instances_meta(root: VSSNode) -> dict[str, list[str]]:
    instances = {}
    for node in root.children:
        if isinstance(node, VSSBranch):
            instances[node.fqn] = [node.name]
        else:
            for child in node.children:
                if isinstance(child, VSSBranch):
                    instances[child.fqn] = [child.name]
    return instances",24.698228168896986,14.510449002306707,18.296069115458103,33.33333333333333,32.6530612244898
22,python,"def is_VSS_leaf(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataDatatype):
        return True
    return False","def is_VSS_leaf(node: VSSNode) -> bool:
    return node.data_type in [""int"", ""float"", ""bool"", ""string""]","def is_VSS_leaf(node: VSSNode) -> bool:
    return node.data_type in [""int"", ""float"", ""bool"", ""string""]",50.01381778774001,33.18077402843942,31.160211408234893,35.714285714285715,100.0
23,python,"def is_VSS_branch(node: VSSNode) -> bool:
   if isinstance(node.data, VSSDataBranch):
        if not node.data.is_instance:
            return True
    return False","def is_VSS_branch(node: VSSNode) -> bool:
    return node.type == ""branch"" and not node.is_instance","def is_VSS_branch(node: VSSNode) -> bool:
    return node.type == ""branch"" and not node.is_instance",36.06308206012407,26.856510884721402,25.816869987353826,31.57894736842105,60.0
24,python,"def is_VSS_branch_instance(node: VSSNode) -> bool:
    if isinstance(node.data, VSSDataBranch):
        if node.data.is_instance:
            return True
    return False","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return node.type == ""branch","def is_VSS_branch_instance(node: VSSNode) -> bool:
    return node.type == ""branch",31.56644029947565,26.802201267792146,26.130226596777128,33.33333333333333,40.0
25,python,"def fnv1_32_hash(identifier: bytes) -> int:
    id_hash = 2166136261
    for byte in identifier:
        id_hash = (id_hash * 16777619) & 0xFFFFFFFF
        id_hash ^= byte

    return id_hash","def fnv1_32_hash(identifier: bytes) -> int:
    FNV_PRIME = 0x01000193
    offset_basis = 0x811C9DC5
    hash = offset_basis
    for byte in identifier:
        hash ^= byte
        hash *= FNV_PRIME
        hash &= 0xFFFFFFFF
    return hash","def fnv1_32_hash(identifier: bytes) -> int:
    FNV_PRIME = 0x01000193
    offset_basis = 0x811C9DC5
    hash = offset_basis
    for byte in identifier:
        hash ^= byte
        hash *= FNV_PRIME
        hash &= 0xFFFFFFFF
    return hash",32.91502047114142,23.705266435224473,30.586394396709615,47.368421052631575,30.0
28,java,"public View onCreateView(LayoutInflater inflater, ViewGroup container,
        Bundle savedInstanceState) {
    mRootView = inflater.inflate(R.layout.card_fragment, container, false);
    mCardTitle = mRootView.findViewById(R.id.card_name);
    mCardIcon = mRootView.findViewById(R.id.card_icon);
    return mRootView;
}","public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_card, container, false);
    mBinding = DataBindingUtil.bind(view);
    return view;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end",38.8390814563928,2.6741369278441516,41.73942795496608,51.85185185185185,59.09090909090909
29,java,"private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent,
        ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setImageDrawable(buttonContent.getIcon());
        buttonView.setOnClickListener(buttonContent.getOnClickListener());
        buttonView.setVisibility(View.VISIBLE);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}","private void updateControlBarButton(DescriptiveTextWithControlsView.Control buttonContent, ImageButton buttonView) {
    if (buttonContent != null) {
        buttonView.setVisibility(View.VISIBLE);
        buttonView.setImageResource(buttonContent.iconResId);
        buttonView.setOnClickListener(buttonContent.listener);
    } else {
        buttonView.setVisibility(View.GONE);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w :","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while",61.84493394202904,4.779999055815579,78.08360768004249,64.51612903225806,100.0
30,java,"protected final View getDescriptiveTextOnlyLayoutView() {
    if (mDescriptiveTextOnlyLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.descriptive_text_layout);
        mDescriptiveTextOnlyLayoutView = stub.inflate();
        mDescriptiveTextOnlyTitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.primary_text);
        mDescriptiveTextOnlySubtitle = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.secondary_text);
        mDescriptiveTextOnlyOptionalImage = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.optional_image);
        mDescriptiveTextOnlyTapForMore = mDescriptiveTextOnlyLayoutView.findViewById(
                R.id.tap_for_more_text);
    }
    return mDescriptiveTextOnlyLayoutView;
}","protected final View getDescriptiveTextOnlyLayoutView() {
    if (mDescriptiveTextOnlyLayoutView == null) {
        mDescriptiveTextOnlyLayoutView = LayoutInflater.from(mContext).inflate(R.layout.descriptive_text_only_layout, null);
    }
    return mDescriptiveTextOnlyLayoutView;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while",25.861378231576502,3.543748881148666,34.79481217349959,38.63636363636363,26.47058823529412
31,java,"public void updateHeaderView(CardHeader header) {
    requireActivity().runOnUiThread(() -> {
        mRootView.setVisibility(View.VISIBLE);
        mCardTitle.setText(header.getCardTitle());
        mCardIcon.setImageDrawable(header.getCardIcon());
    });
}","public void updateHeaderView(CardHeader header) {
    header.setTitle(mTitle);
    header.setIcon(mIcon);
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}",41.73649062922738,1.0450579690797461,33.75804740497263,32.142857142857146,100.0
32,java,"private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        ViewStub stub = mRootView.findViewById(R.id.text_block_layout);
        mTextBlockLayoutView = stub.inflate();
        mTextBlock = mTextBlockLayoutView.findViewById(R.id.text_block);
        mTextBlockTapForMore = mTextBlockLayoutView.findViewById(R.id.tap_for_more_text);
    }
    return mTextBlockLayoutView;
}","private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = mTextBlockLayoutStub.inflate();
    }
    return mTextBlockLayoutView;
}","private View getTextBlockLayoutView() {
    if (mTextBlockLayoutView == null) {
        mTextBlockLayoutView = mTextBlockLayoutStub.inflate();
    }
    return mTextBlockLayoutView;
}",29.96026692278656,38.20749412689547,44.41766447334169,28.125,9.090909090909092
33,java,"static ComponentName getMediaSource(@NonNull PackageManager packageManager,
        @NonNull String packageName) {
    Intent mediaIntent = new Intent();
    mediaIntent.setPackage(packageName);
    mediaIntent.setAction(MediaBrowserService.SERVICE_INTERFACE);

    List<ResolveInfo> mediaServices = packageManager.queryIntentServices(mediaIntent,
            PackageManager.GET_RESOLVED_FILTER);

    if (mediaServices == null || mediaServices.isEmpty()) {
        return null;
    }
    String defaultService = mediaServices.get(0).serviceInfo.name;
    if (!TextUtils.isEmpty(defaultService)) {
        return new ComponentName(packageName, defaultService);
    }
    return null;
}","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {
        return packageManager.getServiceInfo(
                new Intent(packageName + "".MediaBrowserService""),
                0).getComponentName();
    }","static ComponentName getMediaSource(@NonNull PackageManager packageManager, @NonNull String packageName) {
        return packageManager.getServiceInfo(
                new Intent(packageName + "".MediaBrowserService""),
                0).getComponentName();
    }",17.29061578652327,9.64086317072371,19.225104018496058,18.867924528301888,21.428571428571427
34,java,"private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    switch (componentAppType) {
        case APP_TYPE_MEDIA_SERVICES:
            if (customMediaComponents.contains(componentName.flattenToString())
                    && (appTypesToShow & APP_TYPE_LAUNCHABLES) != 0) {
                return false;
            }
            return true;
        case APP_TYPE_LAUNCHABLES:
            return true;
        default:
            Log.e(TAG, ""Invalid componentAppType : "" + componentAppType);
            return false;
    }
}","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (componentName == null) {
        return false;
    }
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    if (customMediaComponents.contains(componentName.getClassName())) {
        return false;
    }
    if ((appTypesToShow & componentAppType) == 0) {
        return false;
    }
    return true;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""hello"", ""again"", ""world""};

    // Remove duplicate words
    vector<string> uniqueWords;
    for (const string& word : words) {
        bool found = false;
        for (const string& uniqueWord : uniqueWords) {
            if (word == uniqueWord) {
                found = true;
                break;
            }
        }
        if (!found) {
            uniqueWords.push_back(word);
        }
    }

    cout << ""Original words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    cout << ""Unique words: "";
    for (const string& word : uniqueWords) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""hello"", ""again"", ""world""};

    // Remove duplicate words using std::unique
    vector<string> uniqueWords = words;
    uniqueWords.erase(unique(uniqueWords.begin(), uniqueWords.end()), uniqueWords.end());

    cout << ""Original words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    cout << ""Unique words: "";
    for (const string& word : uniqueWords) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""hello"", ""again"", ""world""};

    // Remove duplicate words using std::unique
    vector<string> uniqueWords = words;
    uniqueWords.erase(unique(uniqueWords.begin(), uniqueWords.end()), uniqueWords.end());

    cout << ""Original words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    cout << ""Unique words: "";
    for (const string& word : uniqueWords) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include","private static boolean shouldAddToLaunchables(@NonNull ComponentName componentName,
        @NonNull Set<String> appsToHide,
        @NonNull Set<String> customMediaComponents,
        @AppTypes int appTypesToShow,
        @AppTypes int componentAppType) {
    if (componentName == null) {
        return false;
    }
    if (appsToHide.contains(componentName.getPackageName())) {
        return false;
    }
    if (customMediaComponents.contains(componentName.getClassName())) {
        return false;
    }
    if ((appTypesToShow & componentAppType) == 0) {
        return false;
    }
    return true;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""hello"", ""again"", ""world""};

    // Remove duplicate words using std::unique
    vector<string> uniqueWords = words;
    uniqueWords.erase(unique(uniqueWords.begin(), uniqueWords.end()), uniqueWords.end());

    cout << ""Original words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    cout << ""Unique words: "";
    for (const string& word : uniqueWords) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""hello"", ""again"", ""world""};

    // Remove duplicate words using std::unique
    vector<string> uniqueWords = words;
    uniqueWords.erase(unique(uniqueWords.begin(), uniqueWords.end()), uniqueWords.end());

    cout << ""Original words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    cout << ""Unique words: "";
    for (const string& word : uniqueWords) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""hello"", ""again"", ""world""};

    // Remove duplicate words using std::unique
    vector<string> uniqueWords = words;
    uniqueWords.erase(unique(uniqueWords.begin(), uniqueWords.end()), uniqueWords.end());

    cout << ""Original words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    cout << ""Unique words: "";
    for (const string& word : uniqueWords) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""hello"", ""again"", ""world""};

    // Remove duplicate words using std::unique
    vector<string> unique",57.17331382287681,9.426638536262674,54.18725167587943,69.84126984126983,95.23809523809523
35,java,"private static void selectMediaSourceAndFinish(Context context, ComponentName componentName,
        CarMediaManager carMediaManager) {
    try {
        carMediaManager.setMediaSource(componentName, CarMediaManager.MEDIA_SOURCE_MODE_BROWSE);
        if (context instanceof Activity) {
            ((Activity) context).finish();
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected"", e);
    }
}","private static void selectMediaSourceAndFinish(Context context, ComponentName componentName, CarMediaManager carMediaManager) {
    carMediaManager.selectMediaSource(componentName);
    ((Activity) context).finish();
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    // Find the index of ""world""
    auto it = find(words.begin(), words.end(), ""world"");
    if (it != words.end()) {
        cout << ""Index of 'world': "" << distance(words.begin(), it) << endl;
    } else {
        cout << ""'world' not found in the vector."" << endl;
    }

    // Remove ""is"" from the vector
    auto it2 = find(words.begin(), words.end(), ""is"");
    if (it2 != words.end()) {
        words.erase(it2);
    }

    // Print the modified vector
    cout << ""Modified vector: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    // Find the index of ""world""
    auto it = find(words.begin(), words.end(), ""world"");
    if (it != words.end()) {
        cout << ""Index of 'world': "" << distance(words.begin(), it) << endl;
    } else {
        cout << ""'world' not found in the vector."" << endl;
    }

    // Remove ""is"" from the vector
    auto it2 = find(words.begin(), words.end(), ""is"");
    if (it2 != words.end()) {
        words.erase(it2);
    }

    // Print the modified vector
    cout << ""Modified vector: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word <<","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    // Find the index of ""world""
    auto it = find(words.begin(), words.end(), ""world"");
    if (it != words.end()) {
        cout << ""Index of 'world': "" << distance(words.begin(), it) << endl;
    } else {
        cout << ""'world' not found in the vector."" << endl;
    }

    // Remove ""is"" from the vector
    auto it2 = find(words.begin(), words.end(), ""is"");
    if (it2 != words.end()) {
        words.erase(it2);
    }

    // Print the modified vector
    cout << ""Modified vector: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}",40.51622582140316,3.055211906501932,33.52582041136878,35.483870967741936,90.0
36,java,"static boolean isActivityDistractionOptimized(
        CarPackageManager carPackageManager, String packageName, String activityName) {
    boolean isDistractionOptimized = false;
    try {
        if (carPackageManager != null) {
            isDistractionOptimized =
                    carPackageManager.isActivityDistractionOptimized(packageName, activityName);
        }
    } catch (CarNotConnectedException e) {
        Log.e(TAG, ""Car not connected when getting DO info"", e);
    }
    return isDistractionOptimized;
}","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
    try {
        return carPackageManager.isDistractionOptimizedActivity(packageName, activityName);
    } catch (Exception e) {
        Log.w(TAG, ""Error checking if activity is distraction optimized: "" + e.getMessage());
        return false;
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());","static boolean isActivityDistractionOptimized(CarPackageManager carPackageManager, String packageName, String activityName) {
    try {
        return carPackageManager.isDistractionOptimizedActivity(packageName, activityName);
    } catch (Exception e) {
        Log.w(TAG, ""Error checking if activity is distraction optimized: "" + e.getMessage());
        return false;
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());",35.354427144235366,2.245200100141768,18.975464141824347,34.48275862068966,85.71428571428571
38,java,"private Intent getMapsIntent() {
    Intent defaultIntent =
            Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MAPS);
    PackageManager pm = getPackageManager();
    ComponentName defaultActivity = defaultIntent.resolveActivity(pm);

    for (String intentUri : getResources().getStringArray(
            R.array.config_homeCardPreferredMapActivities)) {
        Intent preferredIntent;
        try {
            preferredIntent = Intent.parseUri(intentUri, Intent.URI_ANDROID_APP_SCHEME);
        } catch (URISyntaxException se) {
            Log.w(TAG, ""Invalid intent URI in config_homeCardPreferredMapActivities"", se);
            continue;
        }

        if (defaultActivity != null && !defaultActivity.getPackageName().equals(
                preferredIntent.getPackage())) {
            continue;
        }

        if (preferredIntent.resolveActivityInfo(pm, /* flags= */ 0) != null) {
            return preferredIntent;
        }
    }
    return defaultIntent;
}","private Intent getMapsIntent() {
    Intent intent = mMapsIntent;
    if (intent == null) {
        intent = new Intent(Intent.ACTION_VIEW, Uri.parse(""geo:0,0?q=maps""));
    }
    return intent;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main()",20.828935988880186,1.6398411907995858,8.299279388097794,25.757575757575758,47.61904761904761
39,java,"private void initializeCards() {
    if (mHomeCardModules == null) {
        mHomeCardModules = new ArraySet<>();
        for (String providerClassName : getResources().getStringArray(
                R.array.config_homeCardModuleClasses)) {
            try {
                long reflectionStartTime = System.currentTimeMillis();
                HomeCardModule cardModule = (HomeCardModule) Class.forName(
                        providerClassName).newInstance();
                cardModule.setViewModelProvider(new ViewModelProvider( /* owner= */this));
                mHomeCardModules.add(cardModule);
                if (DEBUG) {
                    long reflectionTime = System.currentTimeMillis() - reflectionStartTime;
                    Log.d(TAG, ""Initialization of HomeCardModule class "" + providerClassName
                            + "" took "" + reflectionTime + "" ms"");
                }
            } catch (IllegalAccessException | InstantiationException |
                    ClassNotFoundException e) {
                Log.w(TAG, ""Unable to create HomeCardProvider class "" + providerClassName, e);
            }
        }
    }
    FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
    for (HomeCardModule cardModule : mHomeCardModules) {
        transaction.replace(cardModule.getCardResId(), cardModule.getCardView());
    }
    transaction.commitNow();
}","private void initializeCards() {
    if (mCardModuleConfig == null) {
        Log.w(TAG, ""No card module config found. Cannot initialize cards."");
        return;
    }

    for (int i = 0; i < mCardModuleConfig.getCardModules().size(); i++) {
        CardModule cardModule = mCardModuleConfig.getCardModules().get(i);
        if (cardModule == null) {
            Log.w(TAG, ""Card module at index "" + i + "" is null. Skipping."");
            continue;
        }

        String cardType = cardModule.getCardType();
        if (cardType == null) {
            Log.w(TAG, ""Card type is null. Skipping card module."");
            continue;
        }

        if (cardType.equals(CardType.HOME_AUDIO)) {
            mHomeAudioCard = new HomeAudioCard(cardModule);
        } else if (cardType.equals(CardType.HOME_NETWORK)) {
            mHomeNetworkCard = new HomeNetworkCard(cardModule);
        } else if (cardType.equals(CardType.HOME_SETTINGS)) {
            mHomeSettingsCard = new HomeSettingsCard(cardModule);
        } else if (cardType.equals(CardType.HOME_DEVICE_CONTROL)) {
            mHomeDeviceControlCard = new HomeDeviceControlCard(cardModule);
        } else if (cardType.equals(CardType.HOME_CALL)) {
            mHomeCallCard = new HomeCallCard(cardModule);
        } else if (cardType.equals(CardType.HOME_MUSIC)) {
            mHomeMusicCard = new HomeMusicCard(cardModule);
        } else if (cardType.equals(CardType.HOME_WEATHER)) {
            mHomeWeatherCard = new HomeWeatherCard(cardModule);
        } else if (cardType.equals(CardType.HOME_ALARM)) {
            mHomeAlarmCard = new HomeAlarmCard(cardModule);
        } else if (cardType.equals(CardType.HOME_CALENDAR)) {
            mHomeCalendarCard = new HomeCalendarCard(cardModule);
        } else if (cardType.equals(CardType.HOME_REMINDERS)) {
            mHomeRemindersCard = new HomeRemindersCard(cardModule);
        } else if (cardType.equals(CardType.HOME_NEWS)) {
            mHomeNewsCard = new HomeNewsCard(cardModule);
        } else if (cardType.equals(CardType.HOME_VIDEO)) {
            mHomeVideoCard = new HomeVideoCard(cardModule);
        } else if (cardType.equals(CardType.HOME_PHOTOS)) {
            mHomePhotosCard = new HomePhotosCard(cardModule);
        } else if (cardType.equals(CardType.HOME_FILES)) {
            mHomeFilesCard = new HomeFilesCard(cardModule);
        } else if (cardType.equals(CardType.HOME_CONTACTS)) {
            mHomeContactsCard = new HomeContactsCard(cardModule);
        } else if (cardType.equals(CardType.HOME_MESSAGES)) {
            mHomeMessagesCard = new HomeMessagesCard(cardModule);
        } else if (cardType.equals(CardType.HOME_APPS)) {
            mHomeAppsCard = new HomeAppsCard(cardModule);
        } else if (cardType.equals(CardType.HOME_SETTINGS_WIFI)) {
            mHomeSettingsWifiCard = new HomeSettings","private void initializeCards() {
    if (mCardModuleConfig == null) {
        Log.w(TAG, ""No card module config found. Cannot initialize cards."");
        return;
    }

    for (int i = 0; i < mCardModuleConfig.getCardModules().size(); i++) {
        CardModule cardModule = mCardModuleConfig.getCardModules().get(i);
        if (cardModule == null) {
            Log.w(TAG, ""Card module at index "" + i + "" is null. Skipping."");
            continue;
        }

        String cardType = cardModule.getCardType();
        if (cardType == null) {
            Log.w(TAG, ""Card type is null. Skipping card module."");
            continue;
        }

        if (cardType.equals(CardType.HOME_AUDIO)) {
            mHomeAudioCard = new HomeAudioCard(cardModule);
        } else if (cardType.equals(CardType.HOME_NETWORK)) {
            mHomeNetworkCard = new HomeNetworkCard(cardModule);
        } else if (cardType.equals(CardType.HOME_SETTINGS)) {
            mHomeSettingsCard = new HomeSettingsCard(cardModule);
        } else if (cardType.equals(CardType.HOME_DEVICE_CONTROL)) {
            mHomeDeviceControlCard = new HomeDeviceControlCard(cardModule);
        } else if (cardType.equals(CardType.HOME_CALL)) {
            mHomeCallCard = new HomeCallCard(cardModule);
        } else if (cardType.equals(CardType.HOME_MUSIC)) {
            mHomeMusicCard = new HomeMusicCard(cardModule);
        } else if (cardType.equals(CardType.HOME_WEATHER)) {
            mHomeWeatherCard = new HomeWeatherCard(cardModule);
        } else if (cardType.equals(CardType.HOME_ALARM)) {
            mHomeAlarmCard = new HomeAlarmCard(cardModule);
        } else if (cardType.equals(CardType.HOME_CALENDAR)) {
            mHomeCalendarCard = new HomeCalendarCard(cardModule);
        } else if (cardType.equals(CardType.HOME_REMINDERS)) {
            mHomeRemindersCard = new HomeRemindersCard(cardModule);
        } else if (cardType.equals(CardType.HOME_NEWS)) {
            mHomeNewsCard = new HomeNewsCard(cardModule);
        } else if (cardType.equals(CardType.HOME_VIDEO)) {
            mHomeVideoCard = new HomeVideoCard(cardModule);
        } else if (cardType.equals(CardType.HOME_PHOTOS)) {
            mHomePhotosCard = new HomePhotosCard(cardModule);
        } else if (cardType.equals(CardType.HOME_FILES)) {
            mHomeFilesCard = new HomeFilesCard(cardModule);
        } else if (cardType.equals(CardType.HOME_CONTACTS)) {
            mHomeContactsCard = new HomeContactsCard(cardModule);
        } else if (cardType.equals(CardType.HOME_MESSAGES)) {
            mHomeMessagesCard = new HomeMessagesCard(cardModule);
        } else if (cardType.equals(CardType.HOME_APPS)) {
            mHomeAppsCard = new HomeAppsCard(cardModule);
        } else if (cardType.equals(CardType.HOME_SETTINGS_WIFI)) {
            mHomeSettingsWifiCard = new HomeSettings",18.486827351495887,3.194805819433614,7.587668421714762,35.16483516483517,28.000000000000004
40,java,"private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
    ActivityTaskManager atm = ActivityTaskManager.getInstance();
    for (TaskAppearedInfo taskAppearedInfo : taskAppearedInfos) {
        TaskInfo taskInfo = taskAppearedInfo.getTaskInfo();
        if (taskInfo.getWindowingMode() == WINDOWING_MODE_MULTI_WINDOW) {
            if (DBG) Slog.d(TAG, ""Found the dangling task, removing: "" + taskInfo.taskId);
            atm.removeTask(taskInfo.taskId);
        }
    }
}","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
        if (taskAppearedInfos == null) {
            return;
        }
        for (int i = taskAppearedInfos.size() - 1; i >= 0; i--) {
            TaskAppearedInfo taskAppearedInfo = taskAppearedInfos.get(i);
            if (taskAppearedInfo.isMultiWindow()) {
                taskAppearedInfos.remove(i);
            }
        }
    }

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names","private static void cleanUpExistingTaskViewTasks(List<TaskAppearedInfo> taskAppearedInfos) {
        if (taskAppearedInfos == null) {
            return;
        }
        for (int i = taskAppearedInfos.size() - 1; i >= 0; i--) {
            TaskAppearedInfo taskAppearedInfo = taskAppearedInfos.get(i);
            if (taskAppearedInfo.isMultiWindow()) {
                taskAppearedInfos.remove(i);
            }
        }
    }",31.96829370009937,2.11779457563926,19.694774164152168,33.33333333333333,72.72727272727273
41,java,"private void updateMode() {
    mMode = parseMode(getIntent());
    setTitle(mMode.mTitleStringId);
    CarUi.requireToolbar(this).setTitle(mMode.mTitleStringId);
}","private void updateMode() {
    String mode = getIntent().getStringExtra(Intent.EXTRA_MODE);
    if (mode != null) {
        mMode = mode;
        setTitle(getString(R.string.mode_title, mode));
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words)","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""fig""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string",30.788322426117354,0.929202534355803,39.68440463043109,38.095238095238095,44.44444444444444
42,java,"private Chronometer getChronometer() {
    if (mChronometer == null) {
        mChronometer = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer);
        mChronometerSeparator = getDescriptiveTextWithControlsLayoutView().findViewById(
                R.id.optional_timer_separator);
    }
    return mChronometer;
}","private Chronometer getChronometer() {
    if (mChronometer == null) {
        mChronometer = new Chronometer(this.context);
    }
    return mChronometer;
}","private Chronometer getChronometer() {
    if (mChronometer == null) {
        mChronometer = new Chronometer(this.context);
    }
    return mChronometer;
}",39.378683571984666,60.26060185337684,62.63874781917721,19.230769230769234,15.384615384615385
43,java,"private View getMediaLayoutView() {
    if (mMediaLayoutView == null) {
        ViewStub stub = getRootView().findViewById(R.id.media_layout);
        mMediaLayoutView = stub.inflate();
        mMediaTitle = mMediaLayoutView.findViewById(R.id.primary_text);
        mMediaSubtitle = mMediaLayoutView.findViewById(R.id.secondary_text);
        View mediaControlBarView = mMediaLayoutView.findViewById(
                R.id.media_playback_controls_bar);
        mPresenter.initializeControlsActionBar(mediaControlBarView);
    }
    return mMediaLayoutView;
}","private View getMediaLayoutView() {
    Bitmap blurredBitmap = Bitmap.createScaledBitmap(
            BitmapFactory.decodeResource(context.getResources(), R.drawable.media_background),
            mCardWidth,
            mCardHeight,
            true);
    return new ImageView(context, null) {
        @Override
        protected void onDraw(Canvas canvas) {
            canvas.drawBitmap(blurredBitmap, 0, 0, null);
        }
    };
}","private View getMediaLayoutView() {
    Bitmap blurredBitmap = Bitmap.createScaledBitmap(
            BitmapFactory.decodeResource(context.getResources(), R.drawable.media_background),
            mCardWidth,
            mCardHeight,
            true);
    return new ImageView(context, null) {
        @Override
        protected void onDraw(Canvas canvas) {
            canvas.drawBitmap(blurredBitmap, 0, 0, null);
        }
    };
}",21.258530373519672,9.823206028490086,10.495598705364062,30.23255813953488,34.48275862068966
44,java,"private void updateBackgroundImage(Drawable image) {
    if (image != null && getCardSize() != null) {
        int maxDimen = Math.max(getCardSize().getWidth(), getCardSize().getHeight());
        Size scaledSize = new Size(maxDimen, maxDimen);
        Bitmap imageBitmap = BitmapUtils.fromDrawable(image, scaledSize);
        Bitmap blurredBackground = ImageUtils.blur(getContext(), imageBitmap, scaledSize,
                mBlurRadius);

        getCardBackgroundImage().setImageBitmap(blurredBackground, /* showAnimation= */ true);
        getCardBackground().setVisibility(View.VISIBLE);
    }
}","private void updateBackgroundImage(Drawable image) {
    if (image == null) {
        mBackgroundImage.setAlpha(0);
        return;
    }
    mBackgroundImage.setImageDrawable(image);
    mBackgroundImage.setAlpha(255);
    mBackgroundImage.postInvalidate();
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while",30.337131371130177,1.972945992565391,16.597801714177525,25.0,77.77777777777779
45,java,"private void updateMediaView(CharSequence title, CharSequence subtitle) {
    getMediaLayoutView().setVisibility(View.VISIBLE);
    mMediaTitle.setText(title);
    mMediaSubtitle.setText(subtitle);
}","private void updateMediaView(CharSequence title, CharSequence subtitle) {
    mMediaView.setVisibility(View.VISIBLE);
    mMediaView.setTitle(title);
    mMediaView.setSubtitle(subtitle);
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while",57.835948313639385,1.7153616043768072,61.207379018601806,68.42105263157895,100.0
46,java,"private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        getChronometer().setVisibility(View.VISIBLE);
        getChronometer().setBase(content.getStartTime());
        getChronometer().start();
        mChronometerSeparator.setVisibility(View.VISIBLE);
    } else {
        getChronometer().setVisibility(View.GONE);
        mChronometerSeparator.setVisibility(View.GONE);
    }
}","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        content.startChronometer();
        content.showChronometer();
    } else {
        content.hideChronometer();
    }
}","private void updateAudioDuration(DescriptiveTextWithControlsView content) {
    if (content.getStartTime() > 0) {
        content.startChronometer();
        content.showChronometer();
    } else {
        content.hideChronometer();
    }
}",38.58442317655461,53.062496988528174,55.164084606579166,31.11111111111111,15.0
47,java,"public void onCallAdded(Call call) {
    if (call != null) {
        call.registerCallback(mCallback);
    }
}","public void onCallAdded(Call call) {
    mCallManager.addCall(call);
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}",38.60852415146962,1.0774063463123849,32.84386974674555,53.84615384615385,66.66666666666666
48,java,"public void onCallRemoved(Call call) {
    mCurrentCall = null;
    mCardContent = null;
    mPresenter.onModelUpdated(this);
    if (call != null) {
        call.unregisterCallback(mCallback);
    }
}","public void onCallRemoved(Call call) {
    mCall = null;
    mCallState = CallState.IDLE;
    mCallManager.unregisterCallback(this);
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""apple"", ""banana"", ""cherry"", ""date"", ""elderberry""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words:"" << endl;
    for (const string& word : words) {
        cout << word << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main()",22.26332479350715,1.2408064547386755,23.526778433575636,50.0,14.285714285714285
49,java,"void updateModelWithPhoneNumber(String number) {
    String formattedNumber = TelecomUtils.getFormattedNumber(mContext, number);
    mCardContent = new DescriptiveTextWithControlsView(null, formattedNumber,
            mOngoingCallSubtitle, mElapsedTimeClock.millis(), mMuteButton, mEndCallButton,
            mDialpadButton);
    mPresenter.onModelUpdated(this);
}","void updateModelWithPhoneNumber(String number) {
    mOngoingCallViewModel.setPhoneNumber(number);
    mOngoingCallViewModel.setCallButtonEnabled(true);
    mOngoingCallViewModel.setVideoButtonEnabled(true);
    mOngoingCallViewModel.setSpeakerphoneButtonEnabled(true);
    mOngoingCallViewModel.setMuteButtonEnabled(true);
    mOngoingCallViewModel.setHoldButtonEnabled(true);
    mOngoingCallViewModel.setAddCallButtonEnabled(true);
    mOngoingCallViewModel.setEndCallButtonEnabled(true);
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<","void updateModelWithPhoneNumber(String number) {
    mOngoingCallViewModel.setPhoneNumber(number);
    mOngoingCallViewModel.setCallButtonEnabled(true);
    mOngoingCallViewModel.setVideoButtonEnabled(true);
    mOngoingCallViewModel.setSpeakerphoneButtonEnabled(true);
    mOngoingCallViewModel.setMuteButtonEnabled(true);
    mOngoingCallViewModel.setHoldButtonEnabled(true);
    mOngoingCallViewModel.setAddCallButtonEnabled(true);
    mOngoingCallViewModel.setEndCallButtonEnabled(true);
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<",31.0146687908381,0.8305862421089305,13.505866699021254,22.22222222222222,87.5
50,java,"private void initializeAudioControls() {
    mMuteButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_mic_off),
            v -> {
                mInCallService.setMuted(mMuteCallToggle);
                mMuteCallToggle = !mMuteCallToggle;
            });
    mEndCallButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_call_end_button),
            v -> mCurrentCall.disconnect());
    mDialpadButton = new DescriptiveTextWithControlsView.Control(
            mContext.getDrawable(R.drawable.ic_dialpad), this::onClick);
}","private void initializeAudioControls() {
    mDialpadButton = (ImageButton) findViewById(R.id.dialpad_button);
    mDialpadButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onDialpadButtonClicked();
        }
    });
    mEndCallButton = (ImageButton) findViewById(R.id.end_call_button);
    mEndCallButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onEndCallButtonClicked();
        }
    });
    mHoldButton = (ImageButton) findViewById(R.id.hold_button);
    mHoldButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onHoldButtonClicked();
        }
    });
    mUnmuteButton = (ImageButton) findViewById(R.id.unmute_button);
    mUnmuteButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onUnmuteButtonClicked();
        }
    });
    mSpeakerphoneButton = (ImageButton) findViewById(R.id.speakerphone_button);
    mSpeakerphoneButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onSpeakerphoneButtonClicked();
        }
    });
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words;
    string word;

    cout << ""Enter words (separated by spaces):"" << endl;
    while (cin >> word) {
        words.push_back(word);
    }

    sort(words.begin(), words.end());

    cout << ""Sorted words:"" << endl;
    for (const string& w : words) {
        cout << w << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string","private void initializeAudioControls() {
    mDialpadButton = (ImageButton) findViewById(R.id.dialpad_button);
    mDialpadButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onDialpadButtonClicked();
        }
    });
    mEndCallButton = (ImageButton) findViewById(R.id.end_call_button);
    mEndCallButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onEndCallButtonClicked();
        }
    });
    mHoldButton = (ImageButton) findViewById(R.id.hold_button);
    mHoldButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onHoldButtonClicked();
        }
    });
    mUnmuteButton = (ImageButton) findViewById(R.id.unmute_button);
    mUnmuteButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onUnmuteButtonClicked();
        }
    });
    mSpeakerphoneButton = (ImageButton) findViewById(R.id.speakerphone_button);
    mSpeakerphoneButton.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            mPresenter.onSpeakerphoneButtonClicked();
        }
    });
}",29.797400479925184,1.4300468392327617,12.81303101629685,43.18181818181818,61.76470588235294
53,cpp,"void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    (void)_subscription;
    if (dbusConnection_->isConnected())
        _listener(AvailabilityStatus::AVAILABLE);
}","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (!_listener) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""listener == NULL"");
        return;
    }
    if (!_subscription) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""subscription == NULL"");
        return;
    }

    if (isAvailable()) {
        _listener->onAvailable();
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"",","void DBusConnectionStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    if (!_listener) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""listener == NULL"");
        return;
    }
    if (!_subscription) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""subscription == NULL"");
        return;
    }

    if (isAvailable()) {
        _listener->onAvailable();
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"",",53.84627156971031,2.042084744737747,61.16908849062524,52.17391304347826,100.0
54,cpp,"void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> lock(mutex_);
    if (connections_.end() != connections_.find(conn)) {
        bool found(false);
        std::vector<std::thread*>::const_iterator it = threads_.begin();
        while (!found && it != threads_.end()) {
            found = (&t == *it++);
        }
        if (!found) {
            threads_.push_back(&t);
        }
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}","void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <map>

std::mutex exitThreadsMutex_;
std::map<std::uintptr_t, std::vector<std::uintptr_t>> exitThreads_;

void joinOnExit(std::uintptr_t conn, std::thread & t) {
    std::lock_guard<std::mutex> itsLock(exitThreadsMutex_);
    if (exitThreads_.find(conn) == exitThreads_.end()) {
        exitThreads_[conn].push_back(t.get());
    }
}

#include <iostream>
#include",41.15717638481623,4.757631046362338,22.275166564513846,43.47826086956522,94.11764705882352
56,cpp,"void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (NULL == static_cast<WatchContext*>(data)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data (WatchContext) == NULL"");
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));
    if (dbusWatch != NULL) {
        if(dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
        }
        dbus_watch_set_data(libdbusWatch, NULL, NULL);
    }
}","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (nullptr == libdbusWatch) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""libdbusWatch == NULL"");
        return;
    }
    if (nullptr == data) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data == NULL"");
        return;
    }

    auto* watchData = static_cast<DBusWatchData*>(data);
    if (nullptr == watchData) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data == NULL"");
        return;
    }

    if (watchData->is_valid_) {
        dbus_connection_remove_watch(connection_, libdbusWatch);
        watchData->is_valid_ = false;
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std","void DBusConnection::onRemoveWatch(::DBusWatch* libdbusWatch, void* data) {
    if (nullptr == libdbusWatch) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""libdbusWatch == NULL"");
        return;
    }
    if (nullptr == data) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data == NULL"");
        return;
    }

    auto* watchData = static_cast<DBusWatchData*>(data);
    if (nullptr == watchData) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data == NULL"");
        return;
    }

    if (watchData->is_valid_) {
        dbus_connection_remove_watch(connection_, libdbusWatch);
        watchData->is_valid_ = false;
    }
}",47.697992644580964,2.9512421956791535,26.174061715978052,61.66666666666667,100.0
57,cpp,"void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    WatchContext* watchContext = static_cast<WatchContext*>(data);

    if (NULL == watchContext) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""watchContext == NULL"");
        return;
    }

    DBusWatch* dbusWatch = static_cast<DBusWatch*>(dbus_watch_get_data(libdbusWatch));

    if (dbusWatch == NULL) {
        DBusWatch* dbusWatch = new DBusWatch(libdbusWatch, watchContext->mainLoopContext_, watchContext->dbusConnection_);
        dbusWatch->addDependentDispatchSource(watchContext->dispatchSource_);
        dbus_watch_set_data(libdbusWatch, dbusWatch, NULL);

        if (dbusWatch->isReadyToBeWatched()) {
            dbusWatch->startWatching();
        }
    } else {
        if (!dbusWatch->isReadyToBeWatched()) {
            dbusWatch->stopWatching();
            dbus_watch_set_data(libdbusWatch, NULL, NULL);
        } else {
            dbusWatch->startWatching();
        }
    }
}","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch == nullptr) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""libdbusWatch == NULL"");
        return;
    }
    if (data == nullptr) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data == NULL"");
        return;
    }

    DBusConnection* connection = static_cast<DBusConnection*>(data);
    if (connection == nullptr) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data is not a DBusConnection pointer"");
        return;
    }

    if (libdbusWatch->ready) {
        connection->startWatch(libdbusWatch);
    } else {
        connection->stopWatch(libdbusWatch);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    // Find the index of ""world""
    auto it = find(words.begin(), words.end(), ""world"");
    if (it != words.end()) {
        cout << ""Index of 'world': "" << distance(words.begin(), it) << endl;
    } else {
        cout << ""'world' not found in the vector."" << endl;
    }

    // Remove ""is"" from the vector
    auto it2 = find(words.begin(), words.end(), ""is"");
    if (it2 != words.end()) {
        words.erase(it2);
    }

    // Print the modified vector
    cout << ""Modified vector: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    // Find the index of ""world""
    auto it = find(words.begin(), words.end(), ""world"");
    if (it != words.end()) {
        cout << ""Index of 'world': "" << distance(words.begin(), it) << endl;
    } else {
        cout << ""'world' not found in the vector."" << endl;
    }

    // Remove ""is"" from the vector
    auto it2 = find(words.begin(), words.end(), ""is"");
    if (it2 != words.end()) {
        words.erase(it2);
    }

    // Print the modified vector
    cout << ""Modified","void DBusConnection::onToggleWatch(::DBusWatch* libdbusWatch, void* data) {
    if (libdbusWatch == nullptr) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""libdbusWatch == NULL"");
        return;
    }
    if (data == nullptr) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data == NULL"");
        return;
    }

    DBusConnection* connection = static_cast<DBusConnection*>(data);
    if (connection == nullptr) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""data is not a DBusConnection pointer"");
        return;
    }

    if (libdbusWatch->ready) {
        connection->startWatch(libdbusWatch);
    } else {
        connection->stopWatch(libdbusWatch);
    }
}",36.92423314517641,3.440702951895959,19.27565464823472,59.59595959595959,65.38461538461539
58,cpp,"const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    if (!dbusObjectManager_) {
        std::lock_guard<std::mutex> itsLock(objectManagerGuard_);
        if (!dbusObjectManager_) {
            dbusObjectManager_ = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return dbusObjectManager_;
}","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    static std::shared_ptr<DBusObjectManager> instance;
    if (!instance) {
        std::mutex mutex;
        std::lock_guard<std::mutex> lock(mutex);
        if (!instance) {
            instance = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return instance;
}
docs/cpp/dbus-cpp/dbus-cpp-api/dbus-cpp-api-dbusconnection.md
# DBusConnection

## Overview

The `DBusConnection` class provides a connection to a D-Bus session or system bus. It is the base class for all other DBus classes.

## Methods

### `DBusConnection()`

Constructor.

### `DBusConnection(const DBusConnection& other)`

Copy constructor.

### `DBusConnection(DBusConnection&& other)`

Move constructor.

### `DBusConnection& operator=(const DBusConnection& other)`

Copy assignment operator.

### `DBusConnection& operator=(DBusConnection&& other)`

Move assignment operator.

### `~DBusConnection()`

Destructor.

### `bool connectToBus(const std::string& busName, const std::string& busPath, const std::string& busAddress, const std::string& busPort, const std::string& busUser, const std::string& busPassword, const std::string& busMachineId, const std::string& busDomain, const std::string& busService, const std::string& busServiceVersion, const std::string& busServiceType, const std::string& busServiceInstance, const std::string& busServicePath, const std::string& busServiceObjectPath, const std::string& busServiceInterface, const std::string& busServiceMethod, const std::string& busServiceSignature, const std::string& busServiceReplySignature, const std::string& busServiceReplyAddress, const std::string& busServiceReplyPort, const std::string& busServiceReplyUser, const std::string& busServiceReplyPassword, const std::string& busServiceReplyMachineId, const std::string& busServiceReplyDomain, const std::string& busServiceReplyService, const std::string& busServiceReplyServiceVersion, const std::string& busServiceReplyServiceType, const std::string& busServiceReplyServiceInstance, const std::string& busServiceReplyServicePath, const std::string& busServiceReplyServiceObjectPath, const std::string& busServiceReplyServiceInterface, const std::string& busServiceReplyServiceMethod, const std::string& busServiceReplyServiceSignature, const std::string& busServiceReplyServiceReplySignature, const std::string& busServiceReplyServiceReplyAddress, const std::string& busServiceReplyServiceReplyPort, const std::string& busServiceReplyServiceReplyUser, const std::string& busServiceReplyServiceReplyPassword, const std::string& busServiceReplyServiceReplyMachineId, const std::string& busServiceReplyServiceReplyDomain, const std::string& busServiceReplyServiceReplyService, const std::string& busServiceReplyServiceReplyServiceVersion, const std::string& busServiceReplyServiceReplyServiceType, const std::string& busServiceReplyServiceReplyServiceInstance, const std::string& busServiceReplyServiceReplyServicePath, const std::string& busServiceReplyServiceReplyServiceObjectPath, const std::string& busServiceReplyServiceReplyServiceInterface, const std::string& busServiceReplyServiceReplyServiceMethod, const std::string&","const std::shared_ptr<DBusObjectManager> DBusConnection::getDBusObjectManager() {
    static std::shared_ptr<DBusObjectManager> instance;
    if (!instance) {
        std::mutex mutex;
        std::lock_guard<std::mutex> lock(mutex);
        if (!instance) {
            instance = std::make_shared<DBusObjectManager>(shared_from_this());
        }
    }
    return instance;
}
docs/cpp/dbus-cpp/dbus-cpp-api/dbus-cpp-api-dbusmessage.md
# DBusMessage

## Overview

The `DBusMessage` class represents a D-Bus message.

## Methods

### `DBusMessage()`

Constructor.

### `DBusMessage(const DBusMessage& other)`

Copy constructor.

### `DBusMessage(DBusMessage&& other)`

Move constructor.

### `DBusMessage& operator=(const DBusMessage& other)`

Copy assignment operator.

### `DBusMessage& operator=(DBusMessage&& other)`

Move assignment operator.

### `~DBusMessage()`

Destructor.

### `bool append(const std::string& value, const std::string& type)`

Appends a value to the message.

### `bool append(const std::string& value, const std::string& type, const std::string& variant)`

Appends a value to the message.

### `bool append(const std::string& value, const std::string& type, const std::string& variant, const std::string& signature)`

Appends a value to the message.

### `bool append(const std::string& value, const std::string& type, const std::string& variant, const std::string& signature, const std::string& language)`

Appends a value to the message.

### `bool append(const std::string& value, const std::string& type, const std::string& variant, const std::string& signature, const std::string& language, const std::string& encoding)`

Appends a value to the message.

### `bool append(const std::string& value, const std::string& type, const std::string& variant, const std::string& signature, const std::string& language, const std::string& encoding, const std::string& direction)`

Appends a value to the message.

### `bool append(const std::string& value, const std::string& type, const std::string& variant, const std::string& signature, const std::string& language, const std::string& encoding, const std::string& direction, const std::string& owner)`

Appends a value to the message.

### `bool append(const std::string& value, const std::string& type, const std::string& variant, const std::string& signature, const std::string& language, const std::string& encoding, const std::string& direction, const std::string& owner, const std::string& replyTo)`

Appends a value to the message.

### `bool append(const std::string& value, const std::string& type, const std::string& variant, const std::string& signature, const std::string& language, const std::string& encoding, const std::string& direction, const std::string& owner, const std::string& replyTo, const std::string& sender)`

Appends a value to the message.

### `bool append(const std::string& value, const std::string& type, const",53.172793935150395,2.6979769384956733,35.31371162261871,87.17948717948718,87.5
59,cpp,"bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    DBusError dbusError;
    bool isServiceNameReleased = false;
    std::lock_guard<std::recursive_mutex> dbusConnectionLock(connectionGuard_);
    auto conIter = connectionNameCount_.find(serviceName);
    if (conIter != connectionNameCount_.end()) {
        if (conIter->second == 1) {
            const int libdbusStatus = dbus_bus_release_name(connection_,
                            serviceName.c_str(),
                            &dbusError.libdbusError_);
            isServiceNameReleased = (libdbusStatus == DBUS_RELEASE_NAME_REPLY_RELEASED);
            if (isServiceNameReleased) {
                connectionNameCount_.erase(conIter);
            }
        } else {
            conIter->second--;
            isServiceNameReleased = true;
        }
    }
    return isServiceNameReleased;
}","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    if (serviceName.empty()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""serviceName is empty"");
        return false;
    }
    if (!isConnected()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""not connected"");
        return false;
    }

    const bool result = (0 != dbus_connection_release_name(connection_, serviceName.c_str()));
    return result;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""is""
    auto it = std::find(words.begin(), words.end(), ""is"");
    if (it != words.end()) {
        std::cout << ""Index of 'is': "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""'is' not found in the vector."" << std::endl;
    }

    // Remove ""a"" from the vector
    auto it2 = std::find(words.begin(), words.end(), ""a"");
    if (it2 != words.end()) {
        words.erase(it2);
    }

    // Print the vector after removing ""a""
    std::cout << ""Vector after removing 'a': "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""is""
    auto it = std::find(words.begin(), words.end(), ""is"");
    if (it != words.end()) {
        std::cout << ""Index of 'is': "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""'is' not found in the vector."" << std::endl;
    }

    // Remove ""a"" from the vector
    auto it2 = std::find(words.begin(), words.end(), ""a"");
    if (it2 != words.end()) {
        words.erase(it2);
    }

    // Print the vector after removing ""a""
    std::cout << ""Vector after removing 'a': "";
    for (const auto& word","bool DBusConnection::releaseServiceName(const std::string& serviceName) const {
    if (serviceName.empty()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""serviceName is empty"");
        return false;
    }
    if (!isConnected()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""not connected"");
        return false;
    }

    const bool result = (0 != dbus_connection_release_name(connection_, serviceName.c_str()));
    return result;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""is""
    auto it = std::find(words.begin(), words.end(), ""is"");
    if (it != words.end()) {
        std::cout << ""Index of 'is': "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""'is' not found in the vector."" << std::endl;
    }

    // Remove ""a"" from the vector
    auto it2 = std::find(words.begin(), words.end(), ""a"");
    if (it2 != words.end()) {
        words.erase(it2);
    }

    // Print the vector after removing ""a""
    std::cout << ""Vector after removing 'a': "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""is""
    auto it = std::find(words.begin(), words.end(), ""is"");
    if (it != words.end()) {
        std::cout << ""Index of 'is': "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""'is' not found in the vector."" << std::endl;
    }

    // Remove ""a"" from the vector
    auto it2 = std::find(words.begin(), words.end(), ""a"");
    if (it2 != words.end()) {
        words.erase(it2);
    }

    // Print the vector after removing ""a""
    std::cout << ""Vector after removing 'a': "";
    for (const auto& word",35.67039234506266,2.4675430044875815,15.214026375763048,50.0,75.0
60,cpp,"DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (NULL == _libdbusPendingCall) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""_libdbusPendingCall == NULL"");
        return DBusMessage();
    }

    ::DBusMessage* libdbusMessage = dbus_pending_call_steal_reply(_libdbusPendingCall);
    const bool increaseLibdbusMessageReferenceCount = false;
    DBusMessage dbusMessage(libdbusMessage, increaseLibdbusMessageReferenceCount);

    return dbusMessage;
}","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (!_libdbusPendingCall) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""pendingCall == NULL"");
        return DBusMessage();
    }

    DBusMessage message;
    if (DBUS_ERROR_NO_REPLY == dbus_pending_call_get_reply(_libdbusPendingCall, &message.message_, nullptr)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""no reply received"");
        return DBusMessage();
    }

    return message;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    // Find the index of ""world""
    auto it = find(words.begin(), words.end(), ""world"");
    if (it != words.end()) {
        cout << ""Index of 'world': "" << distance(words.begin(), it) << endl;
    } else {
        cout << ""'world' not found in the vector."" << endl;
    }

    // Remove the word ""is""
    words.erase(remove(words.begin(), words.end(), ""is""), words.end());

    // Print the updated vector
    cout << ""Updated vector: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    // Find the index of ""world""
    auto it = find(words.begin(), words.end(), ""world"");
    if (it != words.end()) {
        cout << ""Index of 'world': "" << distance(words.begin(), it) << endl;
    } else {
        cout << ""'world' not found in the vector."" << endl;
    }

    // Remove the word ""is""
    words.erase(remove(words.begin(), words.end(), ""is""), words.end());

    // Print the updated vector
    cout << ""Updated vector: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ","DBusMessage DBusConnection::convertToDBusMessage(::DBusPendingCall* _libdbusPendingCall) {
    if (!_libdbusPendingCall) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""pendingCall == NULL"");
        return DBusMessage();
    }

    DBusMessage message;
    if (DBUS_ERROR_NO_REPLY == dbus_pending_call_get_reply(_libdbusPendingCall, &message.message_, nullptr)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""no reply received"");
        return DBusMessage();
    }

    return message;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    // Find the index of ""world""
    auto it = find(words.begin(), words.end(), ""world"");
    if (it != words.end()) {
        cout << ""Index of 'world': "" << distance(words.begin(), it) << endl;
    } else {
        cout << ""'world' not found in the vector."" << endl;
    }

    // Remove the word ""is""
    words.erase(remove(words.begin(), words.end(), ""is""), words.end());

    // Print the updated vector
    cout << ""Updated vector: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    sort(words.begin(), words.end());

    // Print the sorted words
    cout << ""Sorted words: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    // Find the index of ""world""
    auto it = find(words.begin(), words.end(), ""world"");
    if (it != words.end()) {
        cout << ""Index of 'world': "" << distance(words.begin(), it) << endl;
    } else {
        cout << ""'world' not found in the vector."" << endl;
    }

    // Remove the word ""is""
    words.erase(remove(words.begin(), words.end(), ""is""), words.end());

    // Print the updated vector
    cout << ""Updated vector: "";
    for (const string& word : words) {
        cout << word << "" "";
    }
    cout << endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> words = {""hello"", ""world"", ""this"", ""is"", ",44.97970033271924,2.403802073806747,26.873973616044584,58.97435897435898,91.66666666666666
61,cpp,"void DBusConnection::deleteAsyncHandlers() {
    std::vector<DBusMessageReplyAsyncHandler*> asyncHandlers;
    {
        std::lock_guard<std::mutex> asyncHandlersLock(asyncHandlersToDeleteMutex_);
        asyncHandlers = asyncHandlersToDelete_;
        asyncHandlersToDelete_.clear();
    }

    auto it = asyncHandlers.begin();
    while(it != asyncHandlers.end()) {
        delete *it;
        it = asyncHandlers.erase(it);
    }
}","void DBusConnection::deleteAsyncHandlers() {
    std::lock_guard<std::mutex> itsLock(asyncHandlersMutex_);
    for (auto it = asyncHandlers_.begin(); it != asyncHandlers_.end(); ++it) {
        delete *it;
    }
    asyncHandlers_.clear();
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ","void DBusConnection::deleteAsyncHandlers() {
    std::lock_guard<std::mutex> itsLock(asyncHandlersMutex_);
    for (auto it = asyncHandlers_.begin(); it != asyncHandlers_.end(); ++it) {
        delete *it;
    }
    asyncHandlers_.clear();
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ",36.25484702391625,0.709600219523387,8.085298080223225,61.224489795918366,75.0
62,cpp,"void DBusConnection::handleSignalStates() {
    std::map<std::shared_ptr<DBusProxyConnection::DBusSignalHandler>, std::set<uint32_t>> tmpHandlers;
    {
        std::lock_guard<std::mutex> itsLock(signalStateHandlersMutex_);
        tmpHandlers = signalStateHandlers_;
    }
    for (auto itsHandler : tmpHandlers) {
        for (uint32_t tag : itsHandler.second) {
            itsHandler.first->onSpecificError(CommonAPI::CallStatus::SUCCESS, tag);
        }
    }
}","void DBusConnection::handleSignalStates() {
    std::lock_guard<std::mutex> itsLock(itsSignalStatesMutex);
    for (auto it = itsSignalStates.begin(); it != itsSignalStates.end(); ++it) {
        if (it->second.isSuccess()) {
            it->second.signalHandler();
        }
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    //","void DBusConnection::handleSignalStates() {
    std::lock_guard<std::mutex> itsLock(itsSignalStatesMutex);
    for (auto it = itsSignalStates.begin(); it != itsSignalStates.end(); ++it) {
        if (it->second.isSuccess()) {
            it->second.signalHandler();
        }
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    //",35.95244658331423,0.6430408501650436,7.840658526570103,47.82608695652174,87.5
63,cpp,"void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::recursive_mutex> itsConnectionGuard(connectionsMutex_);
    auto itsConnection = connections_.find(_connectionId);

    if (itsConnection != connections_.end()) {
        connections_.erase(_connectionId);
    }
}","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(itsConnectionsMutex);
    auto it = itsConnections.find(_connectionId);
    if (it != itsConnections.end()) {
        itsConnections.erase(it);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice","void Factory::releaseConnection(const ConnectionId_t& _connectionId) {
    std::lock_guard<std::mutex> itsLock(itsConnectionsMutex);
    auto it = itsConnections.find(_connectionId);
    if (it != itsConnections.end()) {
        itsConnections.erase(it);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice",53.087792007368925,1.4641707343965955,26.244140152221984,97.14285714285714,87.5
64,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (dbusMessage.hasMemberName(""InterfacesAdded"")) {
        instanceAvblStatusEvent_->onInterfacesAddedSignal(dbusMessage);
    } else if (dbusMessage.hasMemberName(""InterfacesRemoved"")) {
        instanceAvblStatusEvent_->onInterfacesRemovedSignal(dbusMessage);
   }
}","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (!dbusMessage) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message == NULL"");
        return;
    }
    if (!isConnected()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""not connected"");
        return;
    }

    const std::string interface = dbusMessage.getInterface();
    const std::string member = dbusMessage.getMember();
    const std::string path = dbusMessage.getPath();

    if (interface == ""org.freedesktop.DBus.Introspectable"") {
        if (member == ""IntrospectablePropertiesChanged"") {
            if (path == ""/org/freedesktop/DBus/Introspectable"") {
                if (dbusMessage.hasReply()) {
                    COMMONAPI_ERROR(std::string(__FUNCTION__), ""Unexpected reply to IntrospectablePropertiesChanged"");
                    return;
                }
                const DBusVariant<std::string> interfaceName = dbusMessage.getArgument(0);
                const DBusVariant<std::string> changedProperties = dbusMessage.getArgument(1);
                if (interfaceName.isNull() || changedProperties.isNull()) {
                    COMMONAPI_ERROR(std::string(__FUNCTION__), ""Unexpected arguments to IntrospectablePropertiesChanged"");
                    return;
                }
                const std::string interfaceNameStr = interfaceName.getValue();
                const std::string changedPropertiesStr = changedProperties.getValue();
                if (interfaceNameStr == interface) {
                    if (changedPropertiesStr == ""added"") {
                        onInterfaceAdded(interface);
                    } else if (changedPropertiesStr == ""removed"") {
                        onInterfaceRemoved(interface);
                    }
                }
            }
        }
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout <<","void DBusInstanceAvailabilityStatusChangedEvent::SignalHandler::onSignalDBusMessage(const DBusMessage& dbusMessage) {
    if (!dbusMessage) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message == NULL"");
        return;
    }
    if (!isConnected()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""not connected"");
        return;
    }

    const std::string interface = dbusMessage.getInterface();
    const std::string member = dbusMessage.getMember();
    const std::string path = dbusMessage.getPath();

    if (interface == ""org.freedesktop.DBus.Introspectable"") {
        if (member == ""IntrospectablePropertiesChanged"") {
            if (path == ""/org/freedesktop/DBus/Introspectable"") {
                if (dbusMessage.hasReply()) {
                    COMMONAPI_ERROR(std::string(__FUNCTION__), ""Unexpected reply to IntrospectablePropertiesChanged"");
                    return;
                }
                const DBusVariant<std::string> interfaceName = dbusMessage.getArgument(0);
                const DBusVariant<std::string> changedProperties = dbusMessage.getArgument(1);
                if (interfaceName.isNull() || changedProperties.isNull()) {
                    COMMONAPI_ERROR(std::string(__FUNCTION__), ""Unexpected arguments to IntrospectablePropertiesChanged"");
                    return;
                }
                const std::string interfaceNameStr = interfaceName.getValue();
                const std::string changedPropertiesStr = changedProperties.getValue();
                if (interfaceNameStr == interface) {
                    if (changedPropertiesStr == ""added"") {
                        onInterfaceAdded(interface);
                    } else if (changedPropertiesStr == ""removed"") {
                        onInterfaceRemoved(interface);
                    }
                }
            }
        }
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout <<",47.498743777365746,2.4501795220670366,42.09025013285051,45.45454545454545,100.0
65,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(
        CommonAPI::CallStatus &_status,
        std::vector<DBusAddress> &_availableServiceInstances) {

    _availableServiceInstances.clear();
    DBusObjectManagerStub::DBusObjectPathAndInterfacesDict itsAvailableServiceInstances;
    registry_->getAvailableServiceInstances(proxy_.getDBusAddress().getService(),
            proxy_.getDBusAddress().getObjectPath(),
            itsAvailableServiceInstances);

    _status = CommonAPI::CallStatus::SUCCESS;
    translate(itsAvailableServiceInstances, _availableServiceInstances);
}","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    _status = CommonAPI::CallStatus::SUCCESS;
    _availableServiceInstances = itsAvailableServiceInstances;
}

#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <chrono>
#include <mutex>
#include <condition_variable>

#include <CommonAPI/CommonAPI.hpp>
#include <CommonAPI/DBusAddress.hpp>
#include <CommonAPI/DBusMessage.hpp>
#include <CommonAPI/DBusConnection.hpp>
#include <CommonAPI/DBusProxy.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.","void DBusInstanceAvailabilityStatusChangedEvent::getAvailableServiceInstances(CommonAPI::CallStatus &_status, std::vector<DBusAddress> &_availableServiceInstances) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    _status = CommonAPI::CallStatus::SUCCESS;
    _availableServiceInstances = itsAvailableServiceInstances;
}

#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <chrono>
#include <mutex>
#include <condition_variable>

#include <CommonAPI/CommonAPI.hpp>
#include <CommonAPI/DBusAddress.hpp>
#include <CommonAPI/DBusMessage.hpp>
#include <CommonAPI/DBusConnection.hpp>
#include <CommonAPI/DBusProxy.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.hpp>
#include <CommonAPI/DBusObject.hpp>
#include <CommonAPI/DBusInterface.hpp>
#include <CommonAPI/DBusMethod.hpp>
#include <CommonAPI/DBusSignal.hpp>
#include <CommonAPI/DBusEvent.hpp>
#include <CommonAPI/DBusError.",22.662505034258963,2.661415977146572,20.780811952097086,38.63636363636363,28.57142857142857
66,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(
        const std::string &_instance,
        CallStatus &_callStatus,
        AvailabilityStatus &_availabilityStatus) {

    CommonAPI::Address itsAddress(""local"", observedCapiInterfaceName_, _instance);
    DBusAddress itsDBusAddress;
    DBusAddressTranslator::get()->translate(itsAddress, itsDBusAddress);

    _availabilityStatus = AvailabilityStatus::NOT_AVAILABLE;
    if (registry_->isServiceInstanceAlive(
            itsDBusAddress.getInterface(),
            itsDBusAddress.getService(),
            itsDBusAddress.getObjectPath())) {
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
    }
    _callStatus = CallStatus::SUCCESS;
}","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    if (!_instance.empty()) {
        _callStatus = CallStatus::SUCCESS;
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
    } else {
        _callStatus = CallStatus::ERROR;
        _availabilityStatus = AvailabilityStatus::UNKNOWN;
    }
}
docs/api/cpp/dbus-cpp/html/classDBusConnection.html

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <algorithm>
#include <cassert>
#include <map>
#include <set>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <atomic>
#include <functional>
#include <stdexcept>
#include <cstdint>
#include <cstring>
#include <cerrno>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <poll.h>
#include <sys/mman.h>
#include <sys/mmap.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/signal.h>
#include <sys/uio.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.","void DBusInstanceAvailabilityStatusChangedEvent::getServiceInstanceAvailabilityStatus(const std::string &_instance, CallStatus &_callStatus, AvailabilityStatus &_availabilityStatus) {
    if (!_instance.empty()) {
        _callStatus = CallStatus::SUCCESS;
        _availabilityStatus = AvailabilityStatus::AVAILABLE;
    } else {
        _callStatus = CallStatus::ERROR;
        _availabilityStatus = AvailabilityStatus::UNKNOWN;
    }
}
docs/api/cpp/dbus-cpp/html/classDBusConnection.html

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <algorithm>
#include <cassert>
#include <map>
#include <set>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <atomic>
#include <functional>
#include <stdexcept>
#include <cstdint>
#include <cstring>
#include <cerrno>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <poll.h>
#include <sys/mman.h>
#include <sys/mmap.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/signal.h>
#include <sys/uio.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.",34.753495310781034,5.545466768081894,29.873743233212167,64.70588235294117,38.88888888888889
67,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    DBusInputStream dbusInputStream(_message);
    std::string dbusObjectPath;
    std::vector<std::string> dbusInterfaceNames;

    dbusInputStream >> dbusObjectPath;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read object path"");
    }

    dbusInputStream >> dbusInterfaceNames;
    if (dbusInputStream.hasError()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__) + "" failed to read interface names"");
    }

    for (const auto& dbusInterfaceName : dbusInterfaceNames) {
        if(auto itsProxy = proxyWeakPtr_.lock() &&
                dbusInterfaceName == observedDbusInterfaceName_ &&
                removeInterface(dbusObjectPath, dbusInterfaceName)) {
            (void)itsProxy;
            notifyInterfaceStatusChanged(dbusObjectPath, dbusInterfaceName, AvailabilityStatus::NOT_AVAILABLE);
        }
    }
}","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    if (!_message) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message == NULL"");
        return;
    }
    if (!isConnected()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""not connected"");
        return;
    }

    const DBusMessage::DBusMessageType type = _message.getMessageType();
    if (type != DBusMessage::MessageType::SIGNAL) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message type is not SIGNAL"");
        return;
    }

    const DBusMessage::DBusError error;
    const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
    if (result != DBusMessage::MessageType::SIGNAL) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
        return;
    }

    const std::string_view interface = _message.getInterface();
    const std::string_view member = _message.getMember();
    const DBusMessage::DBusMessageType signalType = _message.getSignature();

    if (interface == ""org.freedesktop.DBus.Introspectable"" && member == ""Introspectable"") {
        if (signalType == DBusMessage::DBusMessageType::SIGNAL) {
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage","void DBusInstanceAvailabilityStatusChangedEvent::onInterfacesRemovedSignal(const DBusMessage &_message) {
    if (!_message) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message == NULL"");
        return;
    }
    if (!isConnected()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""not connected"");
        return;
    }

    const DBusMessage::DBusMessageType type = _message.getMessageType();
    if (type != DBusMessage::MessageType::SIGNAL) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message type is not SIGNAL"");
        return;
    }

    const DBusMessage::DBusError error;
    const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
    if (result != DBusMessage::MessageType::SIGNAL) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
        return;
    }

    const std::string_view interface = _message.getInterface();
    const std::string_view member = _message.getMember();
    const DBusMessage::DBusMessageType signalType = _message.getSignature();

    if (interface == ""org.freedesktop.DBus.Introspectable"" && member == ""Introspectable"") {
        if (signalType == DBusMessage::DBusMessageType::SIGNAL) {
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage::DBusMessageType result = dbus_connection_receive(connection_, _message.message_, 0, &error);
            if (result != DBusMessage::MessageType::SIGNAL) {
                COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbus_connection_receive failed"");
                return;
            }
            const DBusMessage::DBusError error;
            const DBusMessage",36.46868564027432,2.3580699680199366,7.6192366956414626,35.8974358974359,100.0
68,cpp,"void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(
        const std::string &_objectPath,
        const std::string &_interfaceName,
        const AvailabilityStatus &_availability) {
    CommonAPI::Address itsAddress;
    DBusAddress itsDBusAddress(proxy_.getDBusAddress().getService(),
                               _objectPath,
                               _interfaceName);

    DBusAddressTranslator::get()->translate(itsDBusAddress, itsAddress);

    notifyListeners(itsAddress.getAddress(), _availability);
}","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    std::shared_ptr<DBusMessage> message = std::make_shared<DBusMessage>();
    message->setInterface(_interface_);
    message->setMethod(_method_);
    message->setArguments(_arguments_);
    message->setObjectPath(_objectPath);
    message->setInterfaceName(_interfaceName);
    message->setAvailability(_availability);
    _eventQueue.push_back(message);
}

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

#include <CommonAPI/CommonAPI.hpp>
#include <CommonAPI/DBus/DBusMessage.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusEvent.hpp>
#include <CommonAPI/DBus/DBusEventQueue.hpp>

namespace CommonAPI {

class DBusConnection : public DBusConnectionInterface {
public:
    DBusConnection(const std::string &_address, const std::string &_path, const std::string &_interface, const std::string &_method);
    ~DBusConnection();
    bool sendDBusMessage(const DBusMessage &_message) const;
    bool isConnected() const;
    void setConnection(const std::shared_ptr<dbus_connection_t> &_connection);
    void setConnectionAddress(const std::string &_address);
    void setConnectionPath(const std::string &_path);
    void setConnectionInterface(const std::string &_interface);
    void setConnectionMethod(const std::string &_method);
    void setConnectionStatus(bool _status);
    bool getConnectionStatus() const;
    std::shared_ptr<dbus_connection_t> getConnection() const;
    void setConnectionTimeout(int32_t _timeout);
    int32_t getConnectionTimeout() const;
    void setConnectionAddress(const std::string &_address);
    std::string getConnectionAddress() const;
    void setConnectionPath(const std::string &_path);
    std::string getConnectionPath() const;
    void setConnectionInterface(const std::string &_interface);
    std::string getConnectionInterface() const;
    void setConnectionMethod(const std::string &_method);
    std::string getConnectionMethod() const;
    void setConnectionStatus(bool _status);
    bool getConnectionStatus() const;
    void setConnectionTimeout(int32_t _timeout);
    int32_t getConnectionTimeout() const;
    void setConnectionAddress(const std::string &_address);
    std::string getConnectionAddress() const;
    void setConnectionPath(const std::string &_path);
    std::string getConnectionPath() const;
    void setConnectionInterface(const std::string &_interface);
    std::string getConnectionInterface() const;
    void setConnectionMethod(const std::string &_method);
    std::string getConnectionMethod() const;
    void setConnectionStatus(bool _status);
    bool getConnectionStatus() const;
    void setConnectionTimeout(int32_t _timeout);
    int32_t getConnectionTimeout() const;
    void setConnectionAddress(const","void DBusInstanceAvailabilityStatusChangedEvent::notifyInterfaceStatusChanged(const std::string &_objectPath, const std::string &_interfaceName, const AvailabilityStatus &_availability) {
    std::shared_ptr<DBusMessage> message = std::make_shared<DBusMessage>();
    message->setInterface(_interface_);
    message->setMethod(_method_);
    message->setArguments(_arguments_);
    message->setObjectPath(_objectPath);
    message->setInterfaceName(_interfaceName);
    message->setAvailability(_availability);
    _eventQueue.push_back(message);
}

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

#include <CommonAPI/CommonAPI.hpp>
#include <CommonAPI/DBus/DBusMessage.hpp>
#include <CommonAPI/DBus/DBusConnection.hpp>
#include <CommonAPI/DBus/DBusInstanceAvailabilityStatusChangedEvent.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusEvent.hpp>
#include <CommonAPI/DBus/DBusEventQueue.hpp>

namespace CommonAPI {

class DBusConnection : public DBusConnectionInterface {
public:
    DBusConnection(const std::string &_address, const std::string &_path, const std::string &_interface, const std::string &_method);
    ~DBusConnection();
    bool sendDBusMessage(const DBusMessage &_message) const;
    bool isConnected() const;
    void setConnection(const std::shared_ptr<dbus_connection_t> &_connection);
    void setConnectionAddress(const std::string &_address);
    void setConnectionPath(const std::string &_path);
    void setConnectionInterface(const std::string &_interface);
    void setConnectionMethod(const std::string &_method);
    void setConnectionStatus(bool _status);
    bool getConnectionStatus() const;
    std::shared_ptr<dbus_connection_t> getConnection() const;
    void setConnectionTimeout(int32_t _timeout);
    int32_t getConnectionTimeout() const;
    void setConnectionAddress(const std::string &_address);
    std::string getConnectionAddress() const;
    void setConnectionPath(const std::string &_path);
    std::string getConnectionPath() const;
    void setConnectionInterface(const std::string &_interface);
    std::string getConnectionInterface() const;
    void setConnectionMethod(const std::string &_method);
    std::string getConnectionMethod() const;
    void setConnectionStatus(bool _status);
    bool getConnectionStatus() const;
    void setConnectionTimeout(int32_t _timeout);
    int32_t getConnectionTimeout() const;
    void setConnectionAddress(const std::string &_address);
    std::string getConnectionAddress() const;
    void setConnectionPath(const std::string &_path);
    std::string getConnectionPath() const;
    void setConnectionInterface(const std::string &_interface);
    std::string getConnectionInterface() const;
    void setConnectionMethod(const std::string &_method);
    std::string getConnectionMethod() const;
    void setConnectionStatus(bool _status);
    bool getConnectionStatus() const;
    void setConnectionTimeout(int32_t _timeout);
    int32_t getConnectionTimeout() const;
    void setConnectionAddress(const std",49.824423329917785,4.2412565340058626,41.39790020029942,53.65853658536586,100.0
69,cpp,"void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener,
                                           const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);

   std::weak_ptr<DBusProxy> itsdbusProxy = dbusProxy_->shared_from_this();
    dbusProxy_->getDBusConnection()->proxyPushFunctionToMainLoop<DBusConnection>(
            DBusProxy::notifySpecificListener,
            itsdbusProxy,
            _listener,
            _subscription);
}","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(_listener);
    itsSubscriptions.push_back(_subscription);
    itsListenerAdded.notify_one();
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"",","void DBusProxyStatusEvent::onListenerAdded(const Listener &_listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    itsListeners.push_back(_listener);
    itsSubscriptions.push_back(_subscription);
    itsListenerAdded.notify_one();
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    std::sort(names.begin(), names.end());

    // Print the sorted names
    std::cout << ""Sorted names:"" << std::endl;
    for (const auto& name : names) {
        std::cout << name << std::endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> names = {""Alice"",",50.33757759041482,2.3143664548372347,39.03594390682206,60.0,100.0
70,cpp,"void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener,
                                             const Subscription _subscription) {
    std::lock_guard<std::recursive_mutex> listenersLock(listenersMutex_);
    (void)_listener;
    auto listenerIt = listeners_.begin();
    while(listenerIt != listeners_.end()) {
        if(listenerIt->first == _subscription)
            listenerIt = listeners_.erase(listenerIt);
        else
            ++listenerIt;
    }
}","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener, &_subscription](const Listener& listener) {
                               return listener.itsListener == _listener && listener.itsSubscription == _subscription;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <thread>
#include <mutex>
#include <condition_variable>

class Listener {
public:
    std::string itsListener;
    std::string itsSubscription;
};

class Subscription {
public:
    std::string itsSubscription;
};

class DBusProxyStatusEvent {
public:
    void onListenerRemoved(const Listener& _listener, const Subscription _subscription);
private:
    std::vector<Listener> itsListeners;
    std::mutex itsMutex;
};

void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener, &_subscription](const Listener& listener) {
                               return listener.itsListener == _listener && listener.itsSubscription == _subscription;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}

int main() {
    DBusProxyStatusEvent event;
    Listener listener1;
    listener1.itsListener = ""listener1"";
    listener1.itsSubscription = ""subscription1"";
    Listener listener2;
    listener2.itsListener = ""listener2"";
    listener2.itsSubscription = ""subscription2"";
    event.itsListeners.push_back(listener1);
    event.itsListeners.push_back(listener2);

    event.onListenerRemoved(listener1, Subscription{""subscription1""});
    event.onListenerRemoved(listener2, Subscription{""subscription2""});

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <thread>
#include <mutex>
#include <condition_variable>

class Listener {
public:
    std::string itsListener;
    std::string itsSubscription;
};

class Subscription {
public:
    std::string itsSubscription;
};

class DBusProxyStatusEvent {
public:
    void onListenerRemoved(const Listener& _listener, const Subscription _subscription);
private:
    std::vector<Listener> itsListeners;
    std::mutex itsMutex;
};

void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener, &_subscription](const Listener& listener) {
                               return listener.itsListener == _listener && listener.itsSubscription == _subscription;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }","void DBusProxyStatusEvent::onListenerRemoved(const Listener& _listener, const Subscription _subscription) {
    std::lock_guard<std::mutex> itsLock(itsMutex);
    auto it = std::find_if(itsListeners.begin(), itsListeners.end(),
                           [&_listener, &_subscription](const Listener& listener) {
                               return listener.itsListener == _listener && listener.itsSubscription == _subscription;
                           });
    if (it != itsListeners.end()) {
        itsListeners.erase(it);
    }
}",47.66537197585212,3.437534811969349,29.783476900962913,64.58333333333334,92.85714285714286
71,cpp,"void DBusProxyBase::addSignalStateHandler(
            std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler,
            const uint32_t _subscription) {
    connection_->addSignalStateHandler(_handler, _subscription);
}","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    if (!_handler) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler == NULL"");
        return;
    }
    if (!_handler->getHandler()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getInterface()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getInterface() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getMember()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getMember() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0) == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()->getDBusType()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()->getDBusType() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()->getDBusType()->getDBusType()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()->getDBusType()->getDBusType() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature","void DBusProxyBase::addSignalStateHandler(std::shared_ptr<DBusProxyConnection::DBusSignalHandler> _handler, const uint32_t _subscription) {
    if (!_handler) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler == NULL"");
        return;
    }
    if (!_handler->getHandler()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getInterface()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getInterface() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getMember()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getMember() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0) == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()->getDBusType()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()->getDBusType() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()->getDBusType()->getDBusType()) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""handler->getHandler()->getHandler()->getHandlerType()->getSignature()->getArguments()->getArgument(0)->getType()->getDBusType()->getDBusType() == NULL"");
        return;
    }
    if (!_handler->getHandler()->getHandler()->getHandlerType()->getSignature",52.515148607848914,3.1172073010712804,40.27672046365773,66.66666666666666,100.0
72,cpp,"void
DBusProxyManager::instancesAsyncCallback(
        std::shared_ptr<Proxy> _proxy,
        const CommonAPI::CallStatus &_status,
        const std::vector<DBusAddress> &_availableServiceInstances,
        GetAvailableInstancesCallback &_call) {
    (void)_proxy;
    std::vector<std::string> itsAvailableInstances;
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        translate(_availableServiceInstances, itsAvailableInstances);
    }
    _call(_status, itsAvailableInstances);
}","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> addresses;
        for (const auto &_address : _availableServiceInstances) {
            addresses.push_back(_address.toString());
        }
        _call(addresses);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <functional>

namespace CommonAPI {
    enum class CallStatus {
        SUCCESS,
        ERROR
    };
}

namespace DBus {
    class Proxy {
    public:
        Proxy() = default;
        virtual ~Proxy() = default;
    };

    class DBusAddress {
    public:
        DBusAddress() = default;
        std::string toString() const {
            return ""DBusAddress"";
        }
    };

    class DBusMessage {
    public:
        DBusMessage() = default;
        DBusMessage(const DBusMessage&) = default;
        DBusMessage& operator=(const DBusMessage&) = default;
        ~DBusMessage() = default;
        DBusMessage* message_ = nullptr;
    };

    class DBusConnection {
    public:
        DBusConnection() = default;
        virtual ~DBusConnection() = default;
        bool isConnected() const {
            return true;
        }
        int connection_ = 0;
        int dbus_connection_send(int connection, DBusMessage* message, dbus_uint32_t* serial) const {
            return 0;
        }
    };
}

namespace {
    void COMMONAPI_ERROR(const std::string &_function, const std::string &_message) {
        std::cerr << ""ERROR: "" << _function << "" "" << _message << std::endl;
    }
}

class DBusProxyManager {
public:
    using GetAvailableInstancesCallback = std::function<void(const std::vector<std::string>&)>;
    void instancesAsyncCallback(std::shared_ptr<DBus::Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBus::DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call);
};

void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<DBus::Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBus::DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> addresses;
        for (const auto &_address : _availableServiceInstances) {
            addresses.push_back(_address.toString());
        }
        _call(addresses);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <functional>

namespace CommonAPI {
    enum class CallStatus {
        SUCCESS,
        ERROR
    };
}

namespace DBus {
    class Proxy {
    public:
        Proxy() = default;
        virtual ~Proxy() = default;
    };

    class DBusAddress {","void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> addresses;
        for (const auto &_address : _availableServiceInstances) {
            addresses.push_back(_address.toString());
        }
        _call(addresses);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <functional>

namespace CommonAPI {
    enum class CallStatus {
        SUCCESS,
        ERROR
    };
}

namespace DBus {
    class Proxy {
    public:
        Proxy() = default;
        virtual ~Proxy() = default;
    };

    class DBusAddress {
    public:
        DBusAddress() = default;
        std::string toString() const {
            return ""DBusAddress"";
        }
    };

    class DBusMessage {
    public:
        DBusMessage() = default;
        DBusMessage(const DBusMessage&) = default;
        DBusMessage& operator=(const DBusMessage&) = default;
        ~DBusMessage() = default;
        DBusMessage* message_ = nullptr;
    };

    class DBusConnection {
    public:
        DBusConnection() = default;
        virtual ~DBusConnection() = default;
        bool isConnected() const {
            return true;
        }
        int connection_ = 0;
        int dbus_connection_send(int connection, DBusMessage* message, dbus_uint32_t* serial) const {
            return 0;
        }
    };
}

namespace {
    void COMMONAPI_ERROR(const std::string &_function, const std::string &_message) {
        std::cerr << ""ERROR: "" << _function << "" "" << _message << std::endl;
    }
}

class DBusProxyManager {
public:
    using GetAvailableInstancesCallback = std::function<void(const std::vector<std::string>&)>;
    void instancesAsyncCallback(std::shared_ptr<DBus::Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBus::DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call);
};

void DBusProxyManager::instancesAsyncCallback(std::shared_ptr<DBus::Proxy> _proxy, const CommonAPI::CallStatus &_status, const std::vector<DBus::DBusAddress> &_availableServiceInstances, GetAvailableInstancesCallback &_call) {
    if (_status == CommonAPI::CallStatus::SUCCESS) {
        std::vector<std::string> addresses;
        for (const auto &_address : _availableServiceInstances) {
            addresses.push_back(_address.toString());
        }
        _call(addresses);
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <functional>

namespace CommonAPI {
    enum class CallStatus {
        SUCCESS,
        ERROR
    };
}

namespace DBus {
    class Proxy {
    public:
        Proxy() = default;
        virtual ~Proxy() = default;
    };

    class DBusAddress {
    public:",56.16737909370661,4.875282579594981,50.90534490634254,68.88888888888889,100.0
73,cpp,"bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    const char* objectPath = dbusMessage.getObjectPath();
    const char* interfaceName = dbusMessage.getInterface();

    if (NULL == objectPath) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" objectPath == NULL"");
    }
    if (NULL == interfaceName) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), "" interfaceName == NULL"");
    }

    DBusInterfaceHandlerPath handlerPath(objectPath, interfaceName);

    std::unique_lock<std::recursive_mutex> itsLock(objectPathLock_);

    auto handlerIterator = dbusRegisteredObjectsTable_.find(handlerPath);
    const bool foundDBusInterfaceHandler = handlerIterator != dbusRegisteredObjectsTable_.end();
    bool dbusMessageHandled = false;

    if (foundDBusInterfaceHandler) {
        std::shared_ptr<DBusInterfaceHandler> dbusStubAdapterBase = handlerIterator->second.front();
        itsLock.unlock();
        dbusMessageHandled = dbusStubAdapterBase->onInterfaceDBusMessage(dbusMessage);
        return dbusMessageHandled;
    } else if (dbusMessage.hasInterfaceName(""org.freedesktop.DBus.Introspectable"")) {
        dbusMessageHandled = onIntrospectableInterfaceDBusMessage(dbusMessage);
    }

    return dbusMessageHandled;
}","bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (!dbusMessage) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message == NULL"");
        return false;
    }

    if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_METHOD_CALL) {
        return handleMethodCall(dbusMessage);
    } else if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_SIGNAL) {
        return handleSignal(dbusMessage);
    } else if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_ERROR) {
        return handleError(dbusMessage);
    } else if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_REPLY) {
        return handleReply(dbusMessage);
    } else if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_INTROSPECT) {
        return handleIntrospection(dbusMessage);
    } else {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""unknown message type"");
        return false;
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main","bool DBusObjectManager::handleMessage(const DBusMessage& dbusMessage) {
    if (!dbusMessage) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""message == NULL"");
        return false;
    }

    if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_METHOD_CALL) {
        return handleMethodCall(dbusMessage);
    } else if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_SIGNAL) {
        return handleSignal(dbusMessage);
    } else if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_ERROR) {
        return handleError(dbusMessage);
    } else if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_REPLY) {
        return handleReply(dbusMessage);
    } else if (dbusMessage->getType() == DBUS_MESSAGE_TYPE_INTROSPECT) {
        return handleIntrospection(dbusMessage);
    } else {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""unknown message type"");
        return false;
    }
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<string> names = {""Alice"", ""Bob"", ""Charlie"", ""David"", ""Eve""};

    // Sort the names alphabetically
    sort(names.begin(), names.end());

    // Print the sorted names
    cout << ""Sorted names:"" << endl;
    for (const string& name : names) {
        cout << name << endl;
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int main()",32.60738555457618,2.4108199879742265,9.485903697511965,42.857142857142854,75.67567567567568
74,cpp,"bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath,
                                                std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    const auto& dbusRegisteredObjectsTableIter = dbusRegisteredObjectsTable_.find(dbusInterfaceHandlerPath);
    const bool isDBusInterfaceHandlerAlreadyAdded = (dbusRegisteredObjectsTableIter != dbusRegisteredObjectsTable_.end());

    if (isDBusInterfaceHandlerAlreadyAdded) {

        auto handler = find(dbusRegisteredObjectsTableIter->second.begin(), dbusRegisteredObjectsTableIter->second.end(), dbusInterfaceHandler);
        if (handler != dbusRegisteredObjectsTableIter->second.end()) {
            if (dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.ObjectManager"" ||
                    dbusInterfaceHandlerPath.second == ""org.freedesktop.DBus.Properties"") {
                return true;
            }
            return false;
        }
    }

    auto insertSuccess = addToRegisteredObjectsTable(dbusInterfaceHandlerPath, dbusInterfaceHandler);
    return insertSuccess;
}","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    std::lock_guard<std::mutex> itsLock(itsInterfaceHandlerMutex);
    if (dbusInterfaceHandlerPath.isValid()) {
        if (dbusInterfaceHandler) {
            if (dbusInterfaceHandlerPath.isStandardInterface()) {
                if (itsInterfaceHandlerMap.find(dbusInterfaceHandlerPath) == itsInterfaceHandlerMap.end()) {
                    itsInterfaceHandlerMap[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                }
            } else {
                if (itsInterfaceHandlerMap.find(dbusInterfaceHandlerPath) == itsInterfaceHandlerMap.end()) {
                    itsInterfaceHandlerMap[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                } else {
                    COMMONAPI_ERROR(std::string(__FUNCTION__), ""Interface handler already registered for path: "" + dbusInterfaceHandlerPath.toString());
                    return false;
                }
            }
        } else {
            COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbusInterfaceHandler == NULL"");
            return false;
        }
    } else {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbusInterfaceHandlerPath is invalid"");
        return false;
    }
    return true;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""is""
    auto it = std::find(words.begin(), words.end(), ""is"");
    if (it != words.end()) {
        std::cout << ""Index of 'is': "" << std::distance(words.begin(), it) << std::endl;
    } else {
        std::cout << ""'is' not found in the vector."" << std::endl;
    }

    // Remove the word ""a""
    words.erase(std::remove(words.begin(), words.end(), ""a""), words.end());

    // Print the updated vector
    std::cout << ""Updated vector: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    // Find the index of ""is""
    auto","bool DBusObjectManager::addDBusInterfaceHandler(const DBusInterfaceHandlerPath& dbusInterfaceHandlerPath, std::shared_ptr<DBusInterfaceHandler> dbusInterfaceHandler) {
    std::lock_guard<std::mutex> itsLock(itsInterfaceHandlerMutex);
    if (dbusInterfaceHandlerPath.isValid()) {
        if (dbusInterfaceHandler) {
            if (dbusInterfaceHandlerPath.isStandardInterface()) {
                if (itsInterfaceHandlerMap.find(dbusInterfaceHandlerPath) == itsInterfaceHandlerMap.end()) {
                    itsInterfaceHandlerMap[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                }
            } else {
                if (itsInterfaceHandlerMap.find(dbusInterfaceHandlerPath) == itsInterfaceHandlerMap.end()) {
                    itsInterfaceHandlerMap[dbusInterfaceHandlerPath] = dbusInterfaceHandler;
                } else {
                    COMMONAPI_ERROR(std::string(__FUNCTION__), ""Interface handler already registered for path: "" + dbusInterfaceHandlerPath.toString());
                    return false;
                }
            }
        } else {
            COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbusInterfaceHandler == NULL"");
            return false;
        }
    } else {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""dbusInterfaceHandlerPath is invalid"");
        return false;
    }
    return true;
}",43.02933662996201,4.200166141728709,21.290196251135214,51.388888888888886,95.23809523809523
75,cpp,"bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    auto handlerRecord = dbusRegisteredObjectsTable_.find(ifpath);
    if (handlerRecord == dbusRegisteredObjectsTable_.end()) {
        dbusRegisteredObjectsTable_.insert({
            ifpath,
            std::vector<std::shared_ptr<DBusInterfaceHandler>>({handler})
        });
    }
    else {
        std::vector<std::shared_ptr<DBusInterfaceHandler>> handlerList = handlerRecord->second;
        auto adapter = find(handlerList.begin(), handlerList.end(), handler);
        if (adapter != handlerList.end()) {
            return false;
        }
        else {
            handlerList.push_back(handler);
            handlerRecord->second = handlerList;
        }
    }
    return true;
}","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    std::lock_guard<std::mutex> itsLock(registeredObjectsMutex_);
    if (registeredObjects_.count(ifpath)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""already registered"");
        return false;
    }
    registeredObjects_[ifpath] = handler;
    return true;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word","bool DBusObjectManager::addToRegisteredObjectsTable(DBusInterfaceHandlerPath ifpath, std::shared_ptr<DBusInterfaceHandler> handler) {
    std::lock_guard<std::mutex> itsLock(registeredObjectsMutex_);
    if (registeredObjects_.count(ifpath)) {
        COMMONAPI_ERROR(std::string(__FUNCTION__), ""already registered"");
        return false;
    }
    registeredObjects_[ifpath] = handler;
    return true;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word << "" "";
    }
    std::cout << std::endl;

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::string> words = {""hello"", ""world"", ""this"", ""is"", ""a"", ""test""};

    // Sort the words alphabetically
    std::sort(words.begin(), words.end());

    // Print the sorted words
    std::cout << ""Sorted words: "";
    for (const auto& word : words) {
        std::cout << word",34.2824064532447,2.6632378473010707,15.863978327123512,50.602409638554214,68.0
78,c,"void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t positive_sid = UDS_SID_ECU_RESET + 0x40;

  uint8_t tx_data[] = {positive_sid, reset_type};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_POSITIVE_RESPONSE, UDS_SID_ECU_RESET, reset_type};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the CANopen stack.

## Usage

The CANopen stack is a library that can be used in a variety of applications. The following is a list of the most common use cases:

*   **Embedded systems:** The CANopen stack can be used in embedded systems to implement CANopen devices.
*   **Test and simulation:** The CANopen stack can be used to test and simulate CANopen networks.
*   **Development:** The CANopen stack can be used to develop CANopen applications.

## Installation

The CANopen stack can be installed on a variety of platforms. The following is a list of the most common platforms:

*   **Linux:** The CANopen stack can be installed on Linux using the following command:

    ```bash
    make install
    ```

*   **Windows:** The CANopen stack can be installed on Windows using the following command:

    ```bash
    make install
    ```

*   **macOS:** The CANopen stack can be installed on macOS using the following command:

    ```bash
    make install
    ```

## Usage

The CANopen stack can be used in a variety of ways. The following is a list of the most common ways to use the CANopen stack:

*   **Command line:** The CANopen stack can be used from the command line to perform a variety of tasks.
*   **API:** The CANopen stack can be used from a variety of programming languages.
*   **GUI:** The CANopen stack can be used to create a graphical user interface.

## Command line

The CANopen stack can be used from the command line to perform a variety of tasks. The following is a list of the most common tasks:

*   **Start a CANopen network:** The CANopen stack can be used to start a CANopen network.
*   **Stop a CANopen network:** The CANopen stack can be used to stop a CANopen network.
*   **Add a CANopen device:** The CANopen stack can be used to add a CANopen device to a CANopen network.
*   **Remove a CANopen device:** The CANopen stack can be used to remove a CANopen device from a CANopen network.
*   **Send a CANopen message:** The CANopen stack can be used to send a CANopen message to a CANopen device.
*   **Receive a CANopen message:** The CANopen stack can be used to receive a CANopen message from a CANopen device.
*   **Read a CANopen object:** The CANopen stack can be used to read a CANopen object from a CANopen device.
*   **Write a CANopen object:** The CANopen stack can be used to write a CANopen object to a CANopen device.
*   **List CANopen devices:** The CANopen stack can be used to list the CANopen devices on a CANopen network.
*   **List CANopen messages:** The CANopen stack can","void send_positive_reset_response(uint8_t reset_type) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_POSITIVE_RESPONSE, UDS_SID_ECU_RESET, reset_type};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the CANopen stack.

## Usage

The CANopen stack is a library that can be used in a variety of applications. The following is a list of the most common use cases:

*   **Embedded systems:** The CANopen stack can be used in embedded systems to implement CANopen devices.
*   **Test and simulation:** The CANopen stack can be used to test and simulate CANopen networks.
*   **Development:** The CANopen stack can be used to develop CANopen applications.

## Installation

The CANopen stack can be installed on a variety of platforms. The following is a list of the most common platforms:

*   **Linux:** The CANopen stack can be installed on Linux using the following command:

    ```bash
    make install
    ```

*   **Windows:** The CANopen stack can be installed on Windows using the following command:

    ```bash
    make install
    ```

*   **macOS:** The CANopen stack can be installed on macOS using the following command:

    ```bash
    make install
    ```

## Usage

The CANopen stack can be used in a variety of ways. The following is a list of the most common ways to use the CANopen stack:

*   **Command line:** The CANopen stack can be used from the command line to perform a variety of tasks.
*   **API:** The CANopen stack can be used from a variety of programming languages.
*   **GUI:** The CANopen stack can be used to create a graphical user interface.

## Command line

The CANopen stack can be used from the command line to perform a variety of tasks. The following is a list of the most common tasks:

*   **Start a CANopen network:** The CANopen stack can be used to start a CANopen network.
*   **Stop a CANopen network:** The CANopen stack can be used to stop a CANopen network.
*   **Add a CANopen device:** The CANopen stack can be used to add a CANopen device to a CANopen network.
*   **Remove a CANopen device:** The CANopen stack can be used to remove a CANopen device from a CANopen network.
*   **Send a CANopen message:** The CANopen stack can be used to send a CANopen message to a CANopen device.
*   **Receive a CANopen message:** The CANopen stack can be used to receive a CANopen message from a CANopen device.
*   **Read a CANopen object:** The CANopen stack can be used to read a CANopen object from a CANopen device.
*   **Write a CANopen object:** The CANopen stack can be used to write a CANopen object to a CANopen device.
*   **List CANopen devices:** The CANopen stack can be used to list the CANopen devices on a CANopen network.
*   **List CANopen messages:** The CANopen stack can",57.26154204382324,6.833792866124151,78.89686728777843,72.72727272727273,70.58823529411765
79,c,"void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len != 2) {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT);
    return;
  }

  uint8_t reset_type = data[1];

  if (reset_type == UDS_RESET_TYPE_HARD) {
    send_positive_reset_response(UDS_RESET_TYPE_HARD);

    k_sleep(K_MSEC(100));

    LOG_DBG(""Hard reset\n"");
    sys_reboot(SYS_REBOOT_COLD);
  } else {
    send_negative_response(UDS_SID_ECU_RESET,
                           UDS_NRC_SUBFUNCTION_NOT_SUPPORTED);
  }
}","void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len < 2) {
    LOG_ERR(""Invalid ECU reset request length\n"");
    return;
  }

  if (data[0] != UDS_SID_ECU_RESET) {
    LOG_ERR(""Invalid ECU reset request\n"");
    return;
  }

  if (data[1] != ECU_RESET_HARD) {
    LOG_ERR(""Unsupported ECU reset sub-function\n"");
    return;
  }

  LOG_INFO(""Received ECU reset request\n"");
  system_reboot();
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the CANopen stack.

## Usage

The CANopen stack is a library that can be used in embedded systems to implement the CANopen protocol. The library provides a set of functions that can be used to send and receive CAN messages, manage CANopen objects, and handle CANopen events.

## API Reference

### `canopen_init()`

Initializes the CANopen stack.

### `canopen_deinit()`

Deinitializes the CANopen stack.

### `canopen_start()`

Starts the CANopen stack.

### `canopen_stop()`

Stops the CANopen stack.

### `canopen_send_message()`

Sends a CANopen message.

### `canopen_receive_message()`

Receives a CANopen message.

### `canopen_register_message_handler()`

Registers a message handler function.

### `canopen_unregister_message_handler()`

Unregisters a message handler function.

### `canopen_register_event_handler()`

Registers an event handler function.

### `canopen_unregister_event_handler()`

Unregisters an event handler function.

### `canopen_get_node_id()`

Returns the CANopen node ID of the CANopen stack.

### `canopen_set_node_id()`

Sets the CANopen node ID of the CANopen stack.

### `canopen_get_bitrate()`

Returns the CANopen bitrate of the CANopen stack.

### `canopen_set_bitrate()`

Sets the CANopen bitrate of the CANopen stack.

### `canopen_get_baudrate()`

Returns the CANopen baudrate of the CANopen stack.

### `canopen_set_baudrate()`

Sets the CANopen baudrate of the CANopen stack.

### `canopen_get_can_id()`

Returns the CANopen CAN ID of the CANopen stack.

### `canopen_set_can_id()`

Sets the CANopen CAN ID of the CANopen stack.

### `canopen_get_can_mask()`

Returns the CANopen CAN mask of the CANopen stack.

### `canopen_set_can_mask()`

Sets the CANopen CAN mask of the CANopen stack.

### `canopen_get_can_filter()`

Returns the CANopen CAN filter of the CANopen stack.

### `canopen_set_can_filter()`

Sets the CANopen CAN filter of the CANopen stack.

### `canopen_get_can_extended()`

Returns the CANopen CAN extended flag of the CANopen stack.

### `canopen_set_can_extended()`

Sets the CANopen CAN extended flag of the CANopen stack.

### `canopen_get_can_rtr()`

Returns the CANopen CAN remote transmission request flag of the CANopen stack.

### `canopen_set_","void handle_ecu_reset(uint8_t *data, size_t len) {
  if (len < 2) {
    LOG_ERR(""Invalid ECU reset request length\n"");
    return;
  }

  if (data[0] != UDS_SID_ECU_RESET) {
    LOG_ERR(""Invalid ECU reset request\n"");
    return;
  }

  if (data[1] != ECU_RESET_HARD) {
    LOG_ERR(""Unsupported ECU reset sub-function\n"");
    return;
  }

  LOG_INFO(""Received ECU reset request\n"");
  system_reboot();
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the CANopen stack.

## Usage

The CANopen stack is a library that can be used in embedded systems to implement the CANopen protocol. The library provides a set of functions that can be used to send and receive CAN messages, manage CANopen objects, and handle CANopen events.

## API Reference

### `canopen_init()`

Initializes the CANopen stack.

### `canopen_deinit()`

Deinitializes the CANopen stack.

### `canopen_start()`

Starts the CANopen stack.

### `canopen_stop()`

Stops the CANopen stack.

### `canopen_send_message()`

Sends a CANopen message.

### `canopen_receive_message()`

Receives a CANopen message.

### `canopen_register_message_handler()`

Registers a message handler function.

### `canopen_unregister_message_handler()`

Unregisters a message handler function.

### `canopen_register_event_handler()`

Registers an event handler function.

### `canopen_unregister_event_handler()`

Unregisters an event handler function.

### `canopen_get_node_id()`

Returns the CANopen node ID of the CANopen stack.

### `canopen_set_node_id()`

Sets the CANopen node ID of the CANopen stack.

### `canopen_get_bitrate()`

Returns the CANopen bitrate of the CANopen stack.

### `canopen_set_bitrate()`

Sets the CANopen bitrate of the CANopen stack.

### `canopen_get_baudrate()`

Returns the CANopen baudrate of the CANopen stack.

### `canopen_set_baudrate()`

Sets the CANopen baudrate of the CANopen stack.

### `canopen_get_can_id()`

Returns the CANopen CAN ID of the CANopen stack.

### `canopen_set_can_id()`

Sets the CANopen CAN ID of the CANopen stack.

### `canopen_get_can_mask()`

Returns the CANopen CAN mask of the CANopen stack.

### `canopen_set_can_mask()`

Sets the CANopen CAN mask of the CANopen stack.

### `canopen_get_can_filter()`

Returns the CANopen CAN filter of the CANopen stack.

### `canopen_set_can_filter()`

Sets the CANopen CAN filter of the CANopen stack.

### `canopen_get_can_extended()`

Returns the CANopen CAN extended flag of the CANopen stack.

### `canopen_set_can_extended()`

Sets the CANopen CAN extended flag of the CANopen stack.

### `canopen_get_can_rtr()`

Returns the CANopen CAN remote transmission request flag of the CANopen stack.

### `canopen_set_can",40.09023465076168,2.5001901346014437,25.302608933561544,32.55813953488372,100.0
80,c,"void send_request_download_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_DOWNLOAD + 0x40;


  uint8_t tx_data[] = {
    positive_sid,
    0x20,  // positive response code
    0x00,
    0xD2,  // block size = 258 - 2
  };

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","void send_request_download_response() {
  int ret;
  uint8_t tx_data[] = {UDS_SID_REQUEST_DOWNLOAD_RESPONSE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include ""can.h""
#include ""isotp.h""
#include ""uds.h""
#include ""ecu_diag.h""
#include ""ecu_diag_cfg.h""
#include ""ecu_diag_cfg_internal.h""
#include ""ecu_diag_cfg_types.h""
#include ""ecu_diag_cfg_macros.h""
#include ""ecu_diag_cfg_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h","void send_request_download_response() {
  int ret;
  uint8_t tx_data[] = {UDS_SID_REQUEST_DOWNLOAD_RESPONSE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include ""can.h""
#include ""isotp.h""
#include ""uds.h""
#include ""ecu_diag.h""
#include ""ecu_diag_cfg.h""
#include ""ecu_diag_cfg_internal.h""
#include ""ecu_diag_cfg_types.h""
#include ""ecu_diag_cfg_macros.h""
#include ""ecu_diag_cfg_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#include ""ecu_diag_cfg_internal_types.h""
#include ""ecu_diag_cfg_internal_utils.h""
#include ""ecu_diag_cfg_internal_macros.h""
#",51.646722904082154,24.18643073322298,57.192127549772295,71.875,53.333333333333336
81,c,"static void send_transfer_data_response(uint8_t block_sequence_counter) {
  int ret;
  uint8_t positive_sid = UDS_SID_TRANSFER_DATA + 0x40;

  uint8_t tx_data[] = {positive_sid, block_sequence_counter};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_TRANSFER_DATA_POSITIVE_RESPONSE, block_sequence_counter};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transfer_data_response(uint8_t block_sequence_counter) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_TRANSFER_DATA_POSITIVE_RESPONSE, block_sequence_counter};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}",74.68664784376332,78.03288795169722,79.53723283512079,82.35294117647058,58.82352941176471
82,c,"static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
  int ret;
  uint8_t positive_sid = UDS_SID_ROUTINE_CONTROL + 0x40;

  uint8_t tx_data[] = {positive_sid, 0x1, (routine_id >> 8) & 0xFF,
                       routine_id & 0xFF, result};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_ROUTINE_CONTROL_RESULT, routine_id, result};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_routine_control_result(uint16_t routine_id, uint8_t result) {
  int ret;
  uint8_t tx_data[] = {UDS_SID_ROUTINE_CONTROL_RESULT, routine_id, result};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}",64.64227398851618,63.930947200332945,67.97148208706516,66.66666666666666,60.0
83,c,"static void send_transer_exit_positive_response() {
  int ret;
  uint8_t positive_sid = UDS_SID_REQUEST_TRANSFER_EXIT + 0x40;

  uint8_t tx_data[] = {positive_sid};

  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transer_exit_positive_response() {
  int ret;
  uint8_t tx_data[] = {UDS_SID_TRANSFER_EXIT_POSITIVE_RESPONSE};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}","static void send_transer_exit_positive_response() {
  int ret;
  uint8_t tx_data[] = {UDS_SID_TRANSFER_EXIT_POSITIVE_RESPONSE};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
}",72.6615796455045,76.93719648315638,78.55760694734649,81.81818181818183,53.333333333333336
85,c,"static inline uint8_t map_from_can_id(uint32_t can_id) {
  for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
    if (id_mapping[i] == can_id) {
      return i;
    }
  }

  return 0xff;
}","static inline uint8_t map_from_can_id(uint32_t can_id) {
  uint8_t index = 0;
  while (can_id != ecu_can_id_map[index]) {
    if (index == ECU_CAN_ID_MAP_SIZE) {
      return ECU_CAN_ID_MAP_SIZE;
    }
    index++;
  }
  return index;
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the CANopen stack.

## Usage

The CANopen stack is a library that can be used in a variety of applications. The following is a list of the most common use cases:

*   **Embedded systems:** The CANopen stack can be used in embedded systems to implement CANopen devices.
*   **Test automation:** The CANopen stack can be used in test automation to simulate CANopen devices.
*   **Network analysis:** The CANopen stack can be used in network analysis to analyze CANopen traffic.

## Installation

The CANopen stack can be installed on a variety of platforms. The following is a list of the most common platforms:

*   **Linux:** The CANopen stack can be installed on Linux using the following command:

    ```bash
    make install
    ```

*   **Windows:** The CANopen stack can be installed on Windows using the following command:

    ```bash
    make install
    ```

*   **macOS:** The CANopen stack can be installed on macOS using the following command:

    ```bash
    make install
    ```

## Usage

The CANopen stack can be used in a variety of ways. The following is a list of the most common ways to use the CANopen stack:

*   **Command line:** The CANopen stack can be used from the command line to perform a variety of tasks.
*   **API:** The CANopen stack can be used from a variety of programming languages.

## Command line

The CANopen stack can be used from the command line to perform a variety of tasks. The following is a list of the most common tasks:

*   **Start a CANopen stack:** The CANopen stack can be started using the following command:

    ```bash
    canopen-stack start
    ```

*   **Stop a CANopen stack:** The CANopen stack can be stopped using the following command:

    ```bash
    canopen-stack stop
    ```

*   **List the CANopen stack devices:** The CANopen stack devices can be listed using the following command:

    ```bash
    canopen-stack list
    ```

*   **Get the CANopen stack device information:** The CANopen stack device information can be obtained using the following command:

    ```bash
    canopen-stack get-info
    ```

*   **Set the CANopen stack device configuration:** The CANopen stack device configuration can be set using the following command:

    ```bash
    canopen-stack set-config
    ```

*   **Get the CANopen stack device configuration:** The CANopen stack device configuration can be obtained using the following command:

    ```bash
    canopen-stack get-config
    ```

*   **Send a CANopen message:** The CANopen message can be sent using the following command:

    ```bash
    canopen-stack send
    ```

*   **Receive a CANopen message:** The CANopen message can be received using the following command:

    ```bash
    canopen-stack receive
    ```

*   **Send a CANopen service request:** The CANopen service request can be sent using the following command:","static inline uint8_t map_from_can_id(uint32_t can_id) {
  uint8_t index = 0;
  while (can_id != ecu_can_id_map[index]) {
    if (index == ECU_CAN_ID_MAP_SIZE) {
      return ECU_CAN_ID_MAP_SIZE;
    }
    index++;
  }
  return index;
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the CANopen stack.

## Usage

The CANopen stack is a library that can be used in a variety of applications. The following is a list of the most common use cases:

*   **Embedded systems:** The CANopen stack can be used in embedded systems to implement CANopen devices.
*   **Test automation:** The CANopen stack can be used in test automation to simulate CANopen devices.
*   **Network analysis:** The CANopen stack can be used in network analysis to analyze CANopen traffic.

## Installation

The CANopen stack can be installed on a variety of platforms. The following is a list of the most common platforms:

*   **Linux:** The CANopen stack can be installed on Linux using the following command:

    ```bash
    make install
    ```

*   **Windows:** The CANopen stack can be installed on Windows using the following command:

    ```bash
    make install
    ```

*   **macOS:** The CANopen stack can be installed on macOS using the following command:

    ```bash
    make install
    ```

## Usage

The CANopen stack can be used in a variety of ways. The following is a list of the most common ways to use the CANopen stack:

*   **Command line:** The CANopen stack can be used from the command line to perform a variety of tasks.
*   **API:** The CANopen stack can be used from a variety of programming languages.

## Command line

The CANopen stack can be used from the command line to perform a variety of tasks. The following is a list of the most common tasks:

*   **Start a CANopen stack:** The CANopen stack can be started using the following command:

    ```bash
    canopen-stack start
    ```

*   **Stop a CANopen stack:** The CANopen stack can be stopped using the following command:

    ```bash
    canopen-stack stop
    ```

*   **List the CANopen stack devices:** The CANopen stack devices can be listed using the following command:

    ```bash
    canopen-stack list
    ```

*   **Get the CANopen stack device information:** The CANopen stack device information can be obtained using the following command:

    ```bash
    canopen-stack get-info
    ```

*   **Set the CANopen stack device configuration:** The CANopen stack device configuration can be set using the following command:

    ```bash
    canopen-stack set-config
    ```

*   **Get the CANopen stack device configuration:** The CANopen stack device configuration can be obtained using the following command:

    ```bash
    canopen-stack get-config
    ```

*   **Send a CANopen message:** The CANopen message can be sent using the following command:

    ```bash
    canopen-stack send
    ```

*   **Receive a CANopen message:** The CANopen message can be received using the following command:

    ```bash
    canopen-stack receive
    ```

*   **Send a CANopen service request:** The CANopen service request can be sent using the following command:",46.01171157352586,1.4001926576261594,25.50379649362014,57.14285714285714,100.0
86,c,"static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
  struct lin2can_data *data = dev->data;

 if (filter_id == TRANSLATABLE_ADDRESSES_LEN) {
    for (int i = 0; i < TRANSLATABLE_ADDRESSES_LEN; i++) {
      data->incoming_callbacks[i].callback = 0;
    }

    return;
  }

  if (filter_id >= TRANSLATABLE_ADDRESSES_LEN) {
    return;
  }
  data->incoming_callbacks[filter_id].callback = 0;
}","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev->data;
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			if (data->rx_filters[i].cb) {
				kfree(data->rx_filters[i].cb);
				data->rx_filters[i].cb = NULL;
			}
		}
	} else {
		if (data->rx_filters[filter_id].cb) {
			kfree(data->rx_filters[filter_id].cb);
			data->rx_filters[filter_id].cb = NULL;
		}
	}
}
docs/doxygen/doxygen_config.cmake
# Doxygen configuration file for the Linux kernel documentation

# Project name
PROJECT_NAME           = ""Linux Kernel Documentation""

# Project number
PROJECT_NUMBER         = ""5.15""

# Project brief
PROJECT_BRIEF         = ""Documentation for the Linux kernel""

# Project version
PROJECT_VERSION       = ""5.15""

# Project release date
PROJECT_RELEASE_DATE  = ""2021-12-13""

# Project copyright notice
PROJECT_COPYRIGHT_NOTICE = ""Copyright (C) 2021 The Linux Foundation""

# Project logo
PROJECT_LOGO_FILE     = ""doxygen_logo.png""

# Project image path
PROJECT_IMAGE_PATH    = ""images""

# Project HTML path
PROJECT_HTML_PATH     = ""html""

# Project HTML style sheet
PROJECT_HTML_FILE     = ""doxygen.css""

# Project HTML theme
HTML_THEME            = ""gcc""

# Project HTML color scheme
HTML_COLOR_CLASS      = ""gcc""

# Project HTML output directory
HTML_OUTPUT           = ""html""

# Project HTML file extension
HTML_FILE_EXTENSION   = "".html""

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix","static void lin2can_remove_rx_filter(const struct device *dev, int filter_id) {
	struct lin2can_data *data = dev->data;
	int i;

	if (filter_id < 0) {
		for (i = 0; i < ARRAY_SIZE(data->rx_filters); i++) {
			if (data->rx_filters[i].cb) {
				kfree(data->rx_filters[i].cb);
				data->rx_filters[i].cb = NULL;
			}
		}
	} else {
		if (filter_id >= 0 && filter_id < ARRAY_SIZE(data->rx_filters)) {
			if (data->rx_filters[filter_id].cb) {
				kfree(data->rx_filters[filter_id].cb);
				data->rx_filters[filter_id].cb = NULL;
			}
		}
	}
}
docs/doxygen/doxygen_config.cmake
# Doxygen configuration file for the Linux kernel documentation

# Project name
PROJECT_NAME           = ""Linux Kernel Documentation""

# Project number
PROJECT_NUMBER         = ""5.15""

# Project brief
PROJECT_BRIEF         = ""Documentation for the Linux kernel""

# Project version
PROJECT_VERSION       = ""5.15""

# Project release date
PROJECT_RELEASE_DATE  = ""2021-12-13""

# Project copyright notice
PROJECT_COPYRIGHT_NOTICE = ""Copyright (C) 2021 The Linux Foundation""

# Project logo
PROJECT_LOGO_FILE     = ""doxygen_logo.png""

# Project image path
PROJECT_IMAGE_PATH    = ""images""

# Project HTML path
PROJECT_HTML_PATH     = ""html""

# Project HTML style sheet
PROJECT_HTML_FILE     = ""doxygen.css""

# Project HTML theme
HTML_THEME            = ""gcc""

# Project HTML color scheme
HTML_COLOR_CLASS      = ""gcc""

# Project HTML output directory
HTML_OUTPUT           = ""html""

# Project HTML file extension
HTML_FILE_EXTENSION   = "".html""

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_NAME_EXTENSION = """"

# Project HTML file name suffix
HTML_FILE_NAME_SUFFIX = """"

# Project HTML file name prefix
HTML_FILE_NAME_PREFIX = """"

# Project HTML file name extension
HTML_FILE_",37.41051747242844,5.174369489641169,41.87970868164609,54.761904761904766,47.82608695652174
87,c,"static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  struct lin2can_data *data = dev->data;
  struct k_msgq *outgoing_frame_buffer = data->outgoing_frame_queue;

  struct lin2can_outgoing_frame_t outgoing;
  if (k_msgq_get(outgoing_frame_buffer, &outgoing, K_NO_WAIT)) {
    return false;
  }

  memcpy(frame, &outgoing.frame, sizeof(*frame));

  LOG_DBG(""Calling can tx callback"");

  outgoing.callback(dev, 0, outgoing.user_data);

  return true;
}","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
  struct lin_context *ctx = user_data;
  struct list_head *list = &ctx->outgoing_frames;
  struct list_head *tmp;
  struct lin_frame *tmp_frame;

  tmp = list_pop_front(list);
  if (tmp == NULL) {
    return false;
  }
  tmp_frame = list_entry(tmp, struct lin_frame, list);

  if (tmp_frame->completion_cb) {
    tmp_frame->completion_cb(tmp_frame->user_data, tmp_frame->status);
  }
  return true;
}
docs/api/c/README.md
# API Reference

## Overview

This document describes the API of the CANopen stack.

## Usage

The CANopen stack is a library that can be used in a variety of applications. It is designed to be modular and extensible, so it can be used in a variety of different environments.

## API Reference

### `canopen_init()`

Initializes the CANopen stack.

### `canopen_deinit()`

Deinitializes the CANopen stack.

### `canopen_register_device()`

Registers a CANopen device with the CANopen stack.

### `canopen_unregister_device()`

Unregisters a CANopen device with the CANopen stack.

### `canopen_send_message()`

Sends a CANopen message.

### `canopen_receive_message()`

Receives a CANopen message.

### `canopen_get_device()`

Gets a CANopen device.

### `canopen_get_device_id()`

Gets the CANopen device ID.

### `canopen_get_device_type()`

Gets the CANopen device type.

### `canopen_get_device_state()`

Gets the CANopen device state.

### `canopen_get_device_error()`

Gets the CANopen device error.

### `canopen_get_device_error_message()`

Gets the CANopen device error message.

### `canopen_get_device_error_code()`

Gets the CANopen device error code.

### `canopen_get_device_error_info()`

Gets the CANopen device error info.

### `canopen_get_device_error_info_length()`

Gets the CANopen device error info length.

### `canopen_get_device_error_info_data()`

Gets the CANopen device error info data.

### `canopen_get_device_error_info_data_length()`

Gets the CANopen device error info data length.

### `canopen_get_device_error_info_data_type()`

Gets the CANopen device error info data type.

### `canopen_get_device_error_info_data_value()`

Gets the CANopen device error info data value.

### `canopen_get_device_error_info_data_value_length()`

Gets the CANopen device error info data value length.

### `canopen_get_device_error_info_data_value_type()`

Gets the CANopen device error info data value type.

### `canopen_get_device_error_info_data_value_data()`

Gets the CANopen device error info data value data.

### `canopen_get_device_error_info_data_value_data_length()`

Gets the CANopen device error info data value data length.

### `canopen_get_","static bool lin_outgoing_cb(struct lin_frame *frame, void *user_data) {
  struct lin_context *ctx = user_data;
  struct list_head *list = &ctx->outgoing_frames;
  struct list_head *tmp;
  struct lin_frame *tmp_frame;

  tmp = list_pop_front(list);
  if (tmp == NULL) {
    return false;
  }
  tmp_frame = list_entry(tmp, struct lin_frame, list);

  if (tmp_frame->completion_cb) {
    tmp_frame->completion_cb(tmp_frame->user_data, tmp_frame->status);
  }
  return true;
}
docs/api/c/README.md
# API Reference

## Overview

This document describes the API of the CANopen stack.

## Usage

The CANopen stack is a library that can be used in a variety of applications. It is designed to be modular and extensible, so it can be used in a variety of different environments.

## API Reference

### `canopen_init()`

Initializes the CANopen stack.

### `canopen_deinit()`

Deinitializes the CANopen stack.

### `canopen_register_device()`

Registers a CANopen device with the CANopen stack.

### `canopen_unregister_device()`

Unregisters a CANopen device with the CANopen stack.

### `canopen_send_message()`

Sends a CANopen message.

### `canopen_receive_message()`

Receives a CANopen message.

### `canopen_get_device()`

Gets a CANopen device.

### `canopen_get_device_id()`

Gets the CANopen device ID.

### `canopen_get_device_type()`

Gets the CANopen device type.

### `canopen_get_device_state()`

Gets the CANopen device state.

### `canopen_get_device_error()`

Gets the CANopen device error.

### `canopen_get_device_error_message()`

Gets the CANopen device error message.

### `canopen_get_device_error_code()`

Gets the CANopen device error code.

### `canopen_get_device_error_info()`

Gets the CANopen device error info.

### `canopen_get_device_error_info_length()`

Gets the CANopen device error info length.

### `canopen_get_device_error_info_data()`

Gets the CANopen device error info data.

### `canopen_get_device_error_info_data_length()`

Gets the CANopen device error info data length.

### `canopen_get_device_error_info_data_type()`

Gets the CANopen device error info data type.

### `canopen_get_device_error_info_data_value()`

Gets the CANopen device error info data value.

### `canopen_get_device_error_info_data_value_length()`

Gets the CANopen device error info data value length.

### `canopen_get_device_error_info_data_value_type()`

Gets the CANopen device error info data value type.

### `canopen_get_device_error_info_data_value_data()`

Gets the CANopen device error info data value data.

### `canopen_get_device_error_info_data_value_data_length()`

Gets the CANopen device error info data value data length.
### `canopen_get_",31.72782544132412,3.840085479936284,24.96776800949814,43.103448275862064,55.00000000000001
88,c,"static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
  const struct device *dev = (const struct device *)user_data;
  const struct lin2can_data *data = dev->data;

 uint8_t mapped_id = frame->data[0] >> 6;

  __ASSERT(mapped_id < TRANSLATABLE_ADDRESSES_LEN, ""Unexpected LIN-ID: %x"",
           mapped_id);

  LOG_DBG(""Incoming can frame with can id %x"", id_mapping[mapped_id]);

 if (!data->incoming_callbacks[mapped_id].callback) {
    return;
  }

  struct can_frame translated = {
    .id = id_mapping[mapped_id],
    .dlc = 8,
  };
  memcpy(translated.data, frame->data, frame->len);

  translated.data[0] = frame->data[0] & 0x3f;

  LOG_DBG(""Calling according can callback"");

  data->incoming_callbacks[mapped_id].callback(
      dev, &translated, data->incoming_callbacks[mapped_id].user_data);
}","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
  struct can_frame can_frame;
  uint32_t ecu_id;
  uint32_t apid;
  uint32_t dlc;
  uint8_t *data;
  int ret;

  ecu_id = frame->ecu_id;
  apid = frame->apid;
  dlc = frame->dlc;
  data = frame->data;

  can_frame.can_id = ecu_id | (apid << 17);
  can_frame.dlc = dlc;
  memcpy(can_frame.data, data, dlc);

  ret = can_send_frame(can_dev, &can_frame);
  if (ret != CAN_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", can_frame.can_id, ret);
  }

  if (user_data) {
    uint8_t *user_data_ptr = (uint8_t *)user_data;
    uint32_t handler_id = *(uint32_t *)user_data_ptr;
    uint8_t *handler = handlers[handler_id].handler;
    uint8_t *handler_data = handlers[handler_id].data;
    uint32_t handler_len = handlers[handler_id].len;

    if (handler) {
      if (handler_len > 0) {
        memcpy(handler_data, data, handler_len);
      }
      handler();
    }
  }
}
docs/README.md
# README

## Introduction

This is a collection of documentation for the CANopen stack.

## Structure

The documentation is divided into the following sections:

* [CANopen](canopen)
* [UDS](uds)
* [LIN](lin)
examples/canopen/canopen_client.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>

#include <can.h>
#include <canopen.h>
#include <canopen_cfg.h>

#include <linux/can/raw.h>

#define CAN_INTERFACE ""can0""
#define CAN_ID 0x123

#define CAN_MSG_SIZE 8

#define CAN_MSG_DATA_SIZE 6

#define CAN_MSG_DATA ""Hello""

#define CAN_MSG_DATA_SIZE_HEX ""0x48656c6c6f""

#define CAN_MSG_DATA_SIZE_DEC 10

#define CAN_MSG_DATA_SIZE_STR ""10""

#define CAN_MSG_DATA_SIZE_HEX_STR ""0x06""

#define CAN_MSG_DATA_SIZE_HEX_STR_2 ""0x06""

#define CAN_MSG_DATA_SIZE_HEX_STR_3 ""0x06""

#define CAN_MSG_DATA_SIZE_HEX_STR_4 ""0x06""

#define CAN_MSG_DATA_SIZE_HEX_STR_5 ""0x06""

#define CAN_MSG_DATA_SIZE_HEX_STR_6 ""0x06""

#define CAN_MSG","static void lin_incoming_cb(const struct lin_frame *frame, void *user_data) {
  struct can_frame can_frame;
  uint32_t ecu_id;
  uint32_t apid;
  uint32_t dlc;
  uint8_t *data;
  int ret;

  ecu_id = frame->ecu_id;
  apid = frame->apid;
  dlc = frame->dlc;
  data = frame->data;

  can_frame.can_id = ecu_id | (apid << 17);
  can_frame.dlc = dlc;
  memcpy(can_frame.data, data, dlc);

  ret = can_send_frame(can_dev, &can_frame);
  if (ret != CAN_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", can_frame.can_id, ret);
  }

  if (user_data) {
    uint8_t *user_data_ptr = (uint8_t *)user_data;
    uint32_t handler_id = *(uint32_t *)user_data_ptr;
    uint8_t *handler = handlers[handler_id].handler;
    uint8_t *handler_data = handlers[handler_id].data;
    uint32_t handler_len = handlers[handler_id].len;

    if (handler) {
      if (handler_len > 0) {
        memcpy(handler_data, data, handler_len);
      }
      handler();
    }
  }
}
docs/canopen/README.md
# README

## Introduction

This is a collection of documentation for the CANopen stack.

## Structure

The documentation is divided into the following sections:

* [CANopen](canopen)
* [UDS](uds)
* [LIN](lin)
docs/canopen/canopen.md
# CANopen

## Introduction

This is a collection of documentation for the CANopen stack.

## Structure

The documentation is divided into the following sections:

* [UDS](uds)
* [LIN](lin)
docs/canopen/canopen_client.md
# CANopen Client

## Introduction

This is a collection of documentation for the CANopen stack.

## Structure

The documentation is divided into the following sections:

* [UDS](uds)
* [LIN](lin)
docs/canopen/canopen_server.md
# CANopen Server

## Introduction

This is a collection of documentation for the CANopen stack.

## Structure

The documentation is divided into the following sections:

* [UDS](uds)
* [LIN](lin)
docs/canopen/canopen_server.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>

#include <can.h>
#include <canopen.h>
#include <canopen_cfg.h>

#include <linux/can/raw.h>

#define CAN_INTERFACE ""can0""
#define CAN_ID 0x123

#define CAN_MSG_SIZE 8

#define CAN_MSG_DATA_SIZE 6

#define CAN_MSG_DATA ""Hello""

#define CAN_MSG_DATA_SIZE_HEX",29.069279182814046,4.868997416133903,13.477084832363659,37.93103448275862,60.0
89,c,"static int hv_shield_init(const struct device* dev) {
  const struct hv_shield_config_t* config = dev->config;
  struct hv_shield_data_t* data = dev->data;

  int err = gpio_pin_configure_dt(&config->oe_gpio_spec, GPIO_OUTPUT_INACTIVE);
  if (err) {
    LOG_ERR(""Error setting up Output enable pin (%d)"", err);
    return err;
  }

  memset(&data->registers, 0, sizeof(data->registers));

  err = _hv_shield_update(dev);
  if (err) {
    LOG_ERR(""Error writing registers (%d)"", err);
    return err;
  }

  err = gpio_pin_set_dt(&config->oe_gpio_spec, 1);
  if (err) {
    LOG_ERR(""Error setting enabling output (%d)"", err);
  }

  return err;
}","static int hv_shield_init(const struct device* dev) {
	int ret;
	struct hv_shield_data *data = dev->data;

	data->reg = dev_read_bitfield(dev, HV_SHIELD_REG_ADDR, HV_SHIELD_REG_OFFSET,
				      HV_SHIELD_REG_SIZE);

	data->reg |= HV_SHIELD_REG_ENABLE;
	dev_write_bitfield(dev, HV_SHIELD_REG_ADDR, HV_SHIELD_REG_OFFSET,
			   HV_SHIELD_REG_SIZE, data->reg);

	data->reg = dev_read_bitfield(dev, HV_SHIELD_REG_ADDR, HV_SHIELD_REG_OFFSET,
				      HV_SHIELD_REG_SIZE);

	data->reg |= HV_SHIELD_REG_OUTPUT_ENABLE;
	dev_write_bitfield(dev, HV_SHIELD_REG_ADDR, HV_SHIELD_REG_OFFSET,
			   HV_SHIELD_REG_SIZE, data->reg);

	return ret;
}
docs/dlt_user_guide.md
# DLT User Guide

## Introduction

The DLT (Diagnostic Layer Transport) is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

## DLT Protocol

The DLT protocol is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

## DLT Protocol

The DLT protocol is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

## DLT Protocol

The DLT protocol is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

## DLT Protocol

The DLT protocol is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-","static int hv_shield_init(const struct device* dev) {
	int ret;
	struct hv_shield_data *data = dev->data;

	data->reg = dev_read_bitfield(dev, HV_SHIELD_REG_ADDR, HV_SHIELD_REG_OFFSET,
				      HV_SHIELD_REG_SIZE);

	data->reg |= HV_SHIELD_REG_ENABLE;
	dev_write_bitfield(dev, HV_SHIELD_REG_ADDR, HV_SHIELD_REG_OFFSET,
			   HV_SHIELD_REG_SIZE, data->reg);

	data->reg = dev_read_bitfield(dev, HV_SHIELD_REG_ADDR, HV_SHIELD_REG_OFFSET,
				      HV_SHIELD_REG_SIZE);

	data->reg |= HV_SHIELD_REG_OUTPUT_ENABLE;
	dev_write_bitfield(dev, HV_SHIELD_REG_ADDR, HV_SHIELD_REG_OFFSET,
			   HV_SHIELD_REG_SIZE, data->reg);

	return ret;
}
docs/dlt_user_guide.md
# DLT User Guide

## Introduction

The DLT (Diagnostic Layer Transport) is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

## DLT Protocol

The DLT protocol is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

## DLT Protocol

The DLT protocol is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

## DLT Protocol

The DLT protocol is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

The DLT protocol is used to transmit diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2 standard.

## DLT Protocol

The DLT protocol is a standard protocol for transmitting diagnostic messages between a diagnostic tool and an ECU. The DLT protocol is defined in the ISO 22343-2",27.93150705241187,1.6450783508673679,10.782212130869876,34.78260869565217,64.51612903225806
90,c,"static int hvs_set_dac_gain(const struct device* dev,
                            uint8_t dac,
                            enum hv_shield_dac_gains_t gain) {
  if (dac > 1) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;
  switch (dac) {
    case 0:
      data->registers.dac0 = gain;
      break;
    case 1:
      data->registers.dac1 = gain;
      break;
    default:
      return -EINVAL;
  }

  return _hv_shield_update(dev);
}","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
	int ret;
	uint8_t data[2];
	uint8_t dac_id = dac;
	uint8_t gain_value = gain;
	data[0] = dac_id;
	data[1] = gain_value;
	ret = i2c_transfer(dev, &hvs_i2c_dev, data, 2, NULL, 0);
	if (ret) {
		LOG_ERR(""Failed to set DAC gain for DAC %d\n"", dac);
	}
	return ret;
}
docs/doxygen/doxygen.conf
# Doxygen configuration file for the CANopen stack

# Project information
PROJECT_NAME           = ""CANopen Stack""
PROJECT_NUMBER         = ""1.0""
PROJECT_BRIEF          = ""CANopen Stack""
PROJECT_LOGO           = ""images/canopen_logo.png""
HTML_LOGO              = ""images/canopen_logo.png""
HTML_LOGO_WIDTH        = ""200""
HTML_LOGO_ALT          = ""CANopen Stack""
HTML_COLOR_TITLE       = ""#000000""
HTML_COLOR_SUBTITLE    = ""#000000""
HTML_COLOR_LINK        = ""#000000""
HTML_COLOR_SUBMENU     = ""#000000""
HTML_COLOR_SUBMENUBG   = ""#FFFFFF""
HTML_COLOR_BG          = ""#FFFFFF""
HTML_COLOR_BG2         = ""#F0F0F0""
HTML_COLOR_BG3         = ""#FFFFFF""
HTML_COLOR_BG4         = ""#FFFFFF""
HTML_COLOR_BG5         = ""#FFFFFF""
HTML_COLOR_BG6         = ""#FFFFFF""
HTML_COLOR_BG7         = ""#FFFFFF""
HTML_COLOR_BG8         = ""#FFFFFF""
HTML_COLOR_BG9         = ""#FFFFFF""
HTML_COLOR_BG10        = ""#FFFFFF""
HTML_COLOR_BG11        = ""#FFFFFF""
HTML_COLOR_BG12        = ""#FFFFFF""
HTML_COLOR_BG13        = ""#FFFFFF""
HTML_COLOR_BG14        = ""#FFFFFF""
HTML_COLOR_BG15        = ""#FFFFFF""
HTML_COLOR_BG16        = ""#FFFFFF""
HTML_COLOR_BG17        = ""#FFFFFF""
HTML_COLOR_BG18        = ""#FFFFFF""
HTML_COLOR_BG19        = ""#FFFFFF""
HTML_COLOR_BG20        = ""#FFFFFF""
HTML_COLOR_BG21        = ""#FFFFFF""
HTML_COLOR_BG22        = ""#FFFFFF""
HTML_COLOR_BG23        = ""#FFFFFF""
HTML_COLOR_BG24        = ""#FFFFFF""
HTML_COLOR_BG25        = ""#FFFFFF""
HTML_COLOR_BG26        = ""#FFFFFF""
HTML_COLOR_BG27        = ""#FFFFFF""
HTML_COLOR_BG28        = ""#FFFFFF""
HTML_COLOR_BG29        = ""#FFFFFF""
HTML_COLOR_BG30        = ""#FFFFFF""
HTML_COLOR_BG31        = ""#FFFFFF""
HTML_COLOR_BG32        = ""#FFFFFF""
HTML_COLOR_BG33        = ""#FFFFFF""
HTML_COLOR_BG","static int hvs_set_dac_gain(const struct device* dev, uint8_t dac, enum hv_shield_dac_gains_t gain) {
	int ret;
	uint8_t data[2];
	uint8_t dac_id = dac;
	uint8_t gain_value = gain;
	data[0] = dac_id;
	data[1] = gain_value;
	ret = i2c_transfer(dev, &hvs_i2c_dev, data, 2, NULL, 0);
	if (ret) {
		LOG_ERR(""Failed to set DAC gain for DAC %d\n"", dac);
	}
	return ret;
}
docs/doxygen/doxygen.conf
# Doxygen configuration file for the CANopen stack

# Project information
PROJECT_NAME           = ""CANopen Stack""
PROJECT_NUMBER         = ""1.0""
PROJECT_BRIEF          = ""CANopen Stack""
PROJECT_LOGO           = ""images/canopen_logo.png""
HTML_LOGO              = ""images/canopen_logo.png""
HTML_LOGO_WIDTH        = ""200""
HTML_LOGO_ALT          = ""CANopen Stack""
HTML_COLOR_TITLE       = ""#000000""
HTML_COLOR_SUBTITLE    = ""#000000""
HTML_COLOR_LINK        = ""#000000""
HTML_COLOR_SUBMENU     = ""#000000""
HTML_COLOR_SUBMENUBG   = ""#FFFFFF""
HTML_COLOR_BG          = ""#FFFFFF""
HTML_COLOR_BG2         = ""#F0F0F0""
HTML_COLOR_BG3         = ""#FFFFFF""
HTML_COLOR_BG4         = ""#FFFFFF""
HTML_COLOR_BG5         = ""#FFFFFF""
HTML_COLOR_BG6         = ""#FFFFFF""
HTML_COLOR_BG7         = ""#FFFFFF""
HTML_COLOR_BG8         = ""#FFFFFF""
HTML_COLOR_BG9         = ""#FFFFFF""
HTML_COLOR_BG10        = ""#FFFFFF""
HTML_COLOR_BG11        = ""#FFFFFF""
HTML_COLOR_BG12        = ""#FFFFFF""
HTML_COLOR_BG13        = ""#FFFFFF""
HTML_COLOR_BG14        = ""#FFFFFF""
HTML_COLOR_BG15        = ""#FFFFFF""
HTML_COLOR_BG16        = ""#FFFFFF""
HTML_COLOR_BG17        = ""#FFFFFF""
HTML_COLOR_BG18        = ""#FFFFFF""
HTML_COLOR_BG19        = ""#FFFFFF""
HTML_COLOR_BG20        = ""#FFFFFF""
HTML_COLOR_BG21        = ""#FFFFFF""
HTML_COLOR_BG22        = ""#FFFFFF""
HTML_COLOR_BG23        = ""#FFFFFF""
HTML_COLOR_BG24        = ""#FFFFFF""
HTML_COLOR_BG25        = ""#FFFFFF""
HTML_COLOR_BG26        = ""#FFFFFF""
HTML_COLOR_BG27        = ""#FFFFFF""
HTML_COLOR_BG28        = ""#FFFFFF""
HTML_COLOR_BG29        = ""#FFFFFF""
HTML_COLOR_BG30        = ""#FFFFFF""
HTML_COLOR_BG31        = ""#FFFFFF""
HTML_COLOR_BG32        = ""#FFFFFF""
HTML_COLOR_BG33        = ""#FFFFFF""
HTML_COLOR_BG3",32.365860132639355,6.152383944810042,29.052683380005767,36.36363636363637,57.89473684210527
91,c,"static int hvs_set_gpio_output_enable(const struct device* dev,
                                      uint8_t index,
                                      bool enable) {
  if (index > 31) return -EINVAL;

  struct hv_shield_data_t* data = dev->data;

  if (index % 8 < 4) {
    index += 4;
  } else {
    index -= 4;
  }

  if (enable) {
    data->registers.gpio_output |= 1 << index;
  } else {
    data->registers.gpio_output &= ~(1 << index);
  }

  return _hv_shield_update(dev);
}","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
	uint8_t reg = enable ? 0x0f : 0xf0;
	uint8_t mask = (index & 0x0f) << 4 | ((index >> 4) & 0x0f);
	return gpio_set_reg(dev, mask, reg);
}
docs/doxygen/doxygen.conf
# Doxygen configuration file for the Linux kernel

# Project configuration
PROJECT_NAME           = ""Linux Kernel""
PROJECT_NUMBER         = ""5.15""
PROJECT_BRIEF          = ""The Linux Kernel""
PROJECT_LOGO           = ""logo.png""
PROJECT_START_URL      = ""https://www.kernel.org""
PROJECT_VERSION        = ""5.15""
PROJECT_SOURCE_DIR     = "".""
PROJECT_BINARY_DIR     = ""doxygen-out""
PROJECT_GENERATE_HTML  = YES
PROJECT_GENERATE_LATEX = NO
PROJECT_GENERATE_MAN   = NO
PROJECT_GENERATE_RTF   = NO
PROJECT_GENERATE_PDF   = NO
PROJECT_GENERATE_DOCSET = NO
PROJECT_GENERATE_HTMLHELP = NO
PROJECT_GENERATE_CHMDOC = NO
PROJECT_GENERATE_TREEVIEW = YES
PROJECT_GENERATE_DEPGRAPH = YES
PROJECT_GENERATE_DOT = YES
PROJECT_GENERATE_CALLGRAPH = YES
PROJECT_GENERATE_UML = NO
PROJECT_GENERATE_TAGFILE = YES
PROJECT_GENERATE_LATEX_PDF = NO
PROJECT_GENERATE_HTML_PDF = NO
PROJECT_GENERATE_HTML_PDF_LINK = NO
PROJECT_GENERATE_HTML_PDF_BOOK = NO
PROJECT_GENERATE_HTML_PDF_BOOK_LINK = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_","static int hvs_set_gpio_output_enable(const struct device* dev, uint8_t index, bool enable) {
	uint8_t reg = enable ? 0x0f : 0xf0;
	uint8_t mask = (index & 0x0f) << 4 | ((index >> 4) & 0x0f);
	return gpio_set_reg(dev, mask, reg);
}
docs/doxygen/doxygen.conf
# Doxygen configuration file for the Linux kernel

# Project configuration
PROJECT_NAME           = ""Linux Kernel""
PROJECT_NUMBER         = ""5.15""
PROJECT_BRIEF          = ""The Linux Kernel""
PROJECT_LOGO           = ""logo.png""
PROJECT_START_URL      = ""https://www.kernel.org""
PROJECT_VERSION        = ""5.15""
PROJECT_SOURCE_DIR     = "".""
PROJECT_BINARY_DIR     = ""doxygen-out""
PROJECT_GENERATE_HTML  = YES
PROJECT_GENERATE_LATEX = NO
PROJECT_GENERATE_MAN   = NO
PROJECT_GENERATE_RTF   = NO
PROJECT_GENERATE_PDF   = NO
PROJECT_GENERATE_DOCSET = NO
PROJECT_GENERATE_HTMLHELP = NO
PROJECT_GENERATE_CHMDOC = NO
PROJECT_GENERATE_TREEVIEW = YES
PROJECT_GENERATE_DEPGRAPH = YES
PROJECT_GENERATE_DOT = YES
PROJECT_GENERATE_CALLGRAPH = YES
PROJECT_GENERATE_UML = NO
PROJECT_GENERATE_TAGFILE = YES
PROJECT_GENERATE_LATEX_PDF = NO
PROJECT_GENERATE_HTML_PDF = NO
PROJECT_GENERATE_HTML_PDF_LINK = NO
PROJECT_GENERATE_HTML_PDF_BOOK = NO
PROJECT_GENERATE_HTML_PDF_BOOK_LINK = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GENERATE_HTML_PDF_BOOK_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF_LINK_TO_PDF = NO
PROJECT_GEN",25.78253041150965,6.4333584769139724,18.7879581376781,32.075471698113205,45.83333333333333
92,c,"static void can_router_frame_cb(const struct device *dev,
                                struct can_frame *frame,
                                void *user_data) {
  const struct device *to = user_data;

  const int err = can_send(to, frame, K_NO_WAIT, can_router_tx_cb, NULL);
  if (err) {
    LOG_WRN(""Can send failed (%d)"", err);
    return;
  }

  LOG_DBG(""Routed frame from %s to %s"", dev->name, to->name);
}","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
  isotp_send(dev, frame->data, frame->dlc, frame->std_id, frame->extended,
             isotp_get_ecu_id(dev), ISOTP_N_OK, NULL, NULL);
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the CANopen stack.

## Overview

The CANopen stack is a set of libraries that provide a complete CANopen implementation. The stack is designed to be modular and extensible, so that it can be used in a variety of applications.

The CANopen stack is divided into three main layers:

* **The CANopen application layer:** This layer provides the CANopen protocol and the CANopen service layer.
* **The CANopen device layer:** This layer provides the CANopen device layer, which is responsible for managing the CANopen network.
* **The CANopen physical layer:** This layer provides the CANopen physical layer, which is responsible for communicating with the CAN bus.

## API Reference

### CANopen application layer

The CANopen application layer provides the CANopen protocol and the CANopen service layer. The CANopen protocol is a set of rules that define how CANopen devices communicate with each other. The CANopen service layer provides a set of services that can be used to manage CANopen devices.

The CANopen application layer is divided into two main modules:

* **The CANopen protocol module:** This module provides the CANopen protocol.
* **The CANopen service layer module:** This module provides the CANopen service layer.

### CANopen device layer

The CANopen device layer provides the CANopen device layer, which is responsible for managing the CANopen network. The CANopen device layer is divided into two main modules:

* **The CANopen network module:** This module provides the CANopen network.
* **The CANopen device module:** This module provides the CANopen device.

### CANopen physical layer

The CANopen physical layer provides the CANopen physical layer, which is responsible for communicating with the CAN bus. The CANopen physical layer is divided into two main modules:

* **The CANopen physical layer module:** This module provides the CANopen physical layer.
* **The CANopen physical layer driver module:** This module provides the CANopen physical layer driver.

## CANopen protocol module

The CANopen protocol module provides the CANopen protocol. The CANopen protocol is a set of rules that define how CANopen devices communicate with each other.

The CANopen protocol module is divided into two main modules:

* **The CANopen protocol module:** This module provides the CANopen protocol.
* **The CANopen protocol driver module:** This module provides the CANopen protocol driver.

### CANopen protocol module

The CANopen protocol module provides the CANopen protocol. The CANopen protocol is a set of rules that define how CANopen devices communicate with each other.

The CANopen protocol module is divided into two main modules:

* **The CANopen protocol module:** This module provides the CANopen protocol.
* **The CANopen protocol driver module:** This module provides the CANopen protocol driver.

### CANopen protocol driver module

The CANopen protocol driver module provides the CANopen protocol driver. The CANopen protocol driver is responsible for communicating with the CAN bus.

The CANopen protocol driver module is divided into two main modules:

* **The CANopen protocol driver module:** This module provides the CANopen protocol driver.
* **The CANopen protocol driver driver module:** This module provides the CANopen protocol driver driver.

### CANopen service layer module

The CANopen service layer module provides the","static void can_router_frame_cb(const struct device *dev, struct can_frame *frame, void *user_data) {
  isotp_send(dev, frame->data, frame->dlc, frame->std_id, frame->extended,
             isotp_get_ecu_id(dev), ISOTP_N_OK, NULL, NULL);
}
docs/api/c/README.md
# API Reference

## Introduction

This document describes the API of the CANopen stack.

## Overview

The CANopen stack is a set of libraries that provide a complete CANopen implementation. The stack is designed to be modular and extensible, so that it can be used in a variety of applications.

The CANopen stack is divided into three main layers:

* **The CANopen application layer:** This layer provides the CANopen protocol and the CANopen service layer.
* **The CANopen device layer:** This layer provides the CANopen device layer, which is responsible for managing the CANopen network.
* **The CANopen physical layer:** This layer provides the CANopen physical layer, which is responsible for communicating with the CAN bus.

## API Reference

### CANopen application layer

The CANopen application layer provides the CANopen protocol and the CANopen service layer. The CANopen protocol is a set of rules that define how CANopen devices communicate with each other. The CANopen service layer provides a set of services that can be used to manage CANopen devices.

The CANopen application layer is divided into two main modules:

* **The CANopen protocol module:** This module provides the CANopen protocol.
* **The CANopen service layer module:** This module provides the CANopen service layer.

### CANopen device layer

The CANopen device layer provides the CANopen device layer, which is responsible for managing the CANopen network. The CANopen device layer is divided into two main modules:

* **The CANopen network module:** This module provides the CANopen network.
* **The CANopen device module:** This module provides the CANopen device.

### CANopen physical layer

The CANopen physical layer provides the CANopen physical layer, which is responsible for communicating with the CAN bus. The CANopen physical layer is divided into two main modules:

* **The CANopen physical layer module:** This module provides the CANopen physical layer.
* **The CANopen physical layer driver module:** This module provides the CANopen physical layer driver.

## CANopen protocol module

The CANopen protocol module provides the CANopen protocol. The CANopen protocol is a set of rules that define how CANopen devices communicate with each other.

The CANopen protocol module is divided into two main modules:

* **The CANopen protocol module:** This module provides the CANopen protocol.
* **The CANopen protocol driver module:** This module provides the CANopen protocol driver.

### CANopen protocol module

The CANopen protocol module provides the CANopen protocol. The CANopen protocol is a set of rules that define how CANopen devices communicate with each other.

The CANopen protocol module is divided into two main modules:

* **The CANopen protocol module:** This module provides the CANopen protocol.
* **The CANopen protocol driver module:** This module provides the CANopen protocol driver.

### CANopen protocol driver module

The CANopen protocol driver module provides the CANopen protocol driver. The CANopen protocol driver is responsible for communicating with the CAN bus.

The CANopen protocol driver module is divided into two main modules:

* **The CANopen protocol driver module:** This module provides the CANopen protocol driver.
* **The CANopen protocol driver driver module:** This module provides the CANopen protocol driver driver.

### CANopen service layer module

The CANopen service layer module provides the",43.99536922617908,2.0679497149476136,26.413527189768722,47.5,100.0
93,c,"int can_router_register(const struct can_router_entry_t *entries,
                        int entry_count) {
  LOG_DBG(""Registering %d can router entries"", entry_count);
  for (int i = 0; i < entry_count; i++) {
    const int err =
        can_add_rx_filter(*entries[i].from, can_router_frame_cb,
                          (void *)*entries[i].to, &entries[i].filter);
    if (err) {
      return err;
    }
  }

  LOG_DBG(""Registered %d can router entries"", entry_count);

  return 0;
}","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
  int ret;
  for (int i = 0; i < entry_count; i++) {
    ret = can_router_add_entry(entries[i].ifname, entries[i].std_id,
                               entries[i].extended_id, entries[i].mask,
                               entries[i].ecu_id, entries[i].ecu_type);
    if (ret != 0) {
      return -1;
    }
  }
  return 0;
}
docs/api/c/can_router.md
# CAN Router API

The CAN router API provides a way to route CAN frames between specified interfaces.

## Functions

### `can_router_register()`

Registers a set of rules to route CAN frames between specified interfaces.

```c
int can_router_register(const struct can_router_entry_t *entries, int entry_count);
```

#### Parameters

* `entries`: A pointer to an array of `can_router_entry_t` structures.
* `entry_count`: The number of entries in the `entries` array.

#### Return Value

* 0: Success
* -1: Failure

#### Example

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/can/raw/can-raw.h>
#include <linux/can/can.h>
#include <linux/can/can-raw.h>
#include <linux/if_link.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <linux/rtnetlink.h>
#include <linux/netlink/netlink.h>
#include <linux/netlink/can/can-netlink.h>
#include <linux/netlink/can/can-raw.h>
#include <linux/netlink/can/can-sock.h>
#include <linux/netlink/can/can-if.h>
#include <linux/netlink/can/can-ioctl.h>
#include <linux/netlink/can/can-skb.h>
#include <linux/netlink/can/can-raw.h>
#include <linux/netlink/can/can-sock.h>
#include <linux/netlink/can/can-if.h>
#include <linux/netlink/can/can-ioctl.h>
#include <linux/netlink/can/can-skb.h>
#include <linux/netlink/can/can-raw.h>
#include <linux/netlink/can/can-sock.h>
#include <linux/netlink/can/can-if.h>
#include <linux/netlink/can/can-ioctl.h>
#include <linux/netlink","int can_router_register(const struct can_router_entry_t *entries, int entry_count) {
  int ret;
  for (int i = 0; i < entry_count; i++) {
    ret = can_router_add_entry(entries[i].ifname, entries[i].std_id,
                               entries[i].extended_id, entries[i].mask,
                               entries[i].ecu_id, entries[i].ecu_type);
    if (ret != 0) {
      return -1;
    }
  }
  return 0;
}
docs/api/c/can_router.md
# CAN Router API

The CAN router API provides a way to route CAN frames between specified interfaces.

## Functions

### `can_router_register()`

Registers a set of rules to route CAN frames between specified interfaces.

```c
int can_router_register(const struct can_router_entry_t *entries, int entry_count);
```

#### Parameters

* `entries`: A pointer to an array of `can_router_entry_t` structures.
* `entry_count`: The number of entries in the `entries` array.

#### Return Value

* 0: Success
* -1: Failure

#### Example

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <linux/can/raw/can-raw.h>
#include <linux/can/can.h>
#include <linux/can/can-raw.h>
#include <linux/if_link.h>
#include <linux/if_ether.h>
#include <linux/if_arp.h>
#include <linux/ip.h>
#include <linux/ipv6.h>
#include <linux/rtnetlink.h>
#include <linux/netlink/netlink.h>
#include <linux/netlink/can/can-netlink.h>
#include <linux/netlink/can/can-raw.h>
#include <linux/netlink/can/can-sock.h>
#include <linux/netlink/can/can-if.h>
#include <linux/netlink/can/can-ioctl.h>
#include <linux/netlink/can/can-skb.h>
#include <linux/netlink/can/can-raw.h>
#include <linux/netlink/can/can-sock.h>
#include <linux/netlink/can/can-if.h>
#include <linux/netlink/can/can-ioctl.h>
#include <linux/netlink/can/can-skb.h>
#include <linux/netlink/can/can-raw.h>
#include <linux/netlink/can/can-sock.h>
#include <linux/netlink/can/can-if.h>
#include <linux/netlink/can/can-ioctl.h>
#include <linux/netlink/",43.70398207259579,9.417432805623491,39.883621342883245,41.30434782608695,84.21052631578947
94,c,"static int can_router_sysinit() {
  LOG_DBG(""Initializing can router"");

  STRUCT_SECTION_FOREACH (can_router_table_t, table) {
    int err = can_router_register(table->entries, table->entry_count);
    if (err) {
      LOG_ERR(""could not register can router"");
      return err;
    }
  }

  return 0;
}","static int can_router_sysinit() {
  int ret;
  ret = can_router_init();
  if (ret < 0) {
    LOG_ERR(""Failed to initialize CAN router\n"");
    return -1;
  }
  return 0;
}
docs/api/README.md
# API Documentation

This directory contains the API documentation for the CANopen stack.

## How to use

The documentation is generated from the source code using Doxygen.

To generate the documentation, you need to have Doxygen installed.

```bash
sudo apt-get install doxygen
```

Then, run the following command in the root directory of the repository:

```bash
doxygen Doxyfile
```

This will generate the documentation in the `docs/api/html` directory.

## Doxyfile

The Doxyfile is a configuration file that tells Doxygen how to generate the documentation.

The Doxyfile is located in the `docs/api` directory.

## Documentation

The documentation is generated from the source code using Doxygen.

The documentation is located in the `docs/api/html` directory.

## How to contribute

If you want to contribute to the documentation, you can do so by:

*   Adding new documentation to the source code.
*   Fixing errors in the documentation.
*   Improving the documentation.

Please submit a pull request with your changes.
src/canopen/canopen_stack/canopen_stack.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <poll.h>

#include ""canopen_stack.h""
#include ""canopen_stack_internal.h""
#include ""canopen_stack_config.h""
#include ""canopen_stack_types.h""
#include ""canopen_stack_utils.h""
#include ""canopen_stack_log.h""
#include ""canopen_stack_macros.h""
#include ""canopen_stack_assert.h""
#include ""canopen_stack_memory.h""
#include ""canopen_stack_mutex.h""
#include ""canopen_stack_thread.h""
#include ""canopen_stack_socket.h""
#include ""canopen_stack_socket_internal.h""
#include ""canopen_stack_socket_utils.h""
#include ""canopen_stack_socket_types.h""
#include ""canopen_stack_socket_macros.h""
#include ""canopen_stack_socket_assert.h""
#include ""canopen_stack_socket_memory.h""
#include ""canopen_stack_socket_mutex.h""
#include ""canopen_stack_socket_thread.h""
#include ""canopen_stack_socket_io.h""
#include ""canopen_stack_socket_io_internal.h""
#include ""canopen_stack_","static int can_router_sysinit() {
  int ret;
  ret = can_router_init();
  if (ret < 0) {
    LOG_ERR(""Failed to initialize CAN router\n"");
    return -1;
  }
  return 0;
}
src/canopen/canopen_stack/canopen_stack_socket.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <poll.h>

#include ""canopen_stack.h""
#include ""canopen_stack_internal.h""
#include ""canopen_stack_config.h""
#include ""canopen_stack_types.h""
#include ""canopen_stack_utils.h""
#include ""canopen_stack_log.h""
#include ""canopen_stack_macros.h""
#include ""canopen_stack_assert.h""
#include ""canopen_stack_memory.h""
#include ""canopen_stack_mutex.h""
#include ""canopen_stack_thread.h""
#include ""canopen_stack_socket.h""
#include ""canopen_stack_socket_internal.h""
#include ""canopen_stack_socket_utils.h""
#include ""canopen_stack_socket_types.h""
#include ""canopen_stack_socket_macros.h""
#include ""canopen_stack_socket_assert.h""
#include ""canopen_stack_socket_memory.h""
#include ""canopen_stack_socket_mutex.h""
#include ""canopen_stack_socket_thread.h""
#include ""canopen_stack_socket_io.h""
#include ""canopen_stack_socket_io_internal.h""
#ifndef __linux__
#include <winsock2.h>
#include <ws2tcpip.h>
#endif
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <poll.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <poll.h>
#include <errno.h>
#include <unistd.h>
#include <string.",20.641712941954253,2.031305703793607,19.61600583413835,27.586206896551722,33.33333333333333
95,c,"static int hvs_set_masked_raw(const struct device* port,
                              gpio_port_pins_t mask,
                              gpio_port_value_t value) {
  const struct hv_shield_gpio_config_t* config = port->config;

  for (int i = 0; i < config->lv_gpios_count; i++) {
    if (!(mask & BIT(i))) continue;

    int ret = gpio_pin_set(config->lv_gpios[i].port, config->lv_gpios[i].pin,
                           !!(value & BIT(i)));
    if (ret < 0) {
      LOG_ERR(""Error settings gpio %d (error %d)"", i, ret);
      return ret;
    }
  }

  return 0;
}","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
	int ret;
	int i;

	for (i = 0; i < GPIO_NUM_PINS; i++) {
		if ((mask >> i) & 0x01) {
			ret = gpio_set_pin(port, i, value);
			if (ret < 0) {
				return ret;
			}
		}
	}

	return 0;
}
docs/api/c/index.rst
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <syslog.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/signal.h>
#include <sys/statvfs.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/utsname.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/vfs.h>
#include <sys/vnode.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/vfs.h>
#include <sys/vnode.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/vfs.h>
#include <sys/vnode.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/time.h>","static int hvs_set_masked_raw(const struct device* port, gpio_port_pins_t mask, gpio_port_value_t value) {
	int ret;
	int i;

	for (i = 0; i < GPIO_NUM_PINS; i++) {
		if ((mask >> i) & 0x01) {
			ret = gpio_set_pin(port, i, value);
			if (ret < 0) {
				return ret;
			}
		}
	}

	return 0;
}
docs/api/c/index.rst
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <syslog.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/signal.h>
#include <sys/statvfs.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/utsname.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/vfs.h>
#include <sys/vnode.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/vfs.h>
#include <sys/vnode.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/vfs.h>
#include <sys/vnode.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/time.h>",35.587987203468344,12.819540942613047,40.093033686123434,35.59322033898305,53.84615384615385
96,c,"static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
  struct abstract_lin_data *data = dev->data;

  if (free_slots == NULL) {
    return -EINVAL;
  }

  *free_slots = CONFIG_ABSTRACT_LIN_MAX_FRAME_COUNT - data->used_callbacks;

  return 0;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
	return dev->data->free_cb_slots;
}","static int al_get_free_cb_slots(const struct device *dev, uint8_t *free_slots) {
	*free_slots = dev->data->free_cb_slots;
	return 0;
}",27.606754855628466,17.162292056450916,29.93139403272963,43.333333333333336,20.0
97,c,"static int al_register_incoming_cb(const struct device *dev,
                                   abstract_lin_incoming_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = INCOMING;
  data->callbacks[free_index].incoming_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
	struct al_lin_incoming_cb *cb = NULL;
	int ret = -EINVAL;

	if (dev == NULL || callback == NULL) {
		return ret;
	}

	cb = kzalloc(sizeof(*cb), GFP_KERNEL);
	if (cb == NULL) {
		return -ENOMEM;
	}

	cb->callback = callback;
	cb->user_data = user_data;
	cb->frame_id = frame_id;
	cb->frame_size = frame_size;

	ret = mutex_lock(&dev->incoming_cb_mutex);
	if (ret < 0) {
		kfree(cb);
		return ret;
	}

	list_add_tail(&cb->list, &dev->incoming_cb_list);

	ret = mutex_unlock(&dev->incoming_cb_mutex);
	if (ret < 0) {
		kfree(cb);
		return ret;
	}

	return 0;
}
docs/doxygen/doxygen_config.py
# Doxygen configuration file for the Linux kernel documentation

# Project configuration
PROJECT_NAME           = ""Linux Kernel""
PROJECT_NUMBER         = ""5.15""
PROJECT_BRIEF          = ""The Linux Kernel""
PROJECT_LOGO           = ""logo.png""
PROJECT_START_URL      = ""https://www.kernel.org""
PROJECT_VERSION        = ""5.15""
PROJECT_SOURCE_DIR     = "".""
PROJECT_HTML_OUTPUT    = ""html""
PROJECT_GENERATE_HTML  = YES
PROJECT_HTML_EXTRA_STYLESHEET = ""doxygen-awesome.css""
PROJECT_HTML_EXTRA_FILES = ""doxygen-awesome.css""
PROJECT_HTML_FILE_EXTENSION = "".html""
PROJECT_HTML_USE_INDEX = YES
PROJECT_HTML_USE_NUMBERED_REFERENCES = YES
PROJECT_HTML_USE_RST_FORMAT = YES
PROJECT_HTML_USE_MATHLAX = YES
PROJECT_HTML_USE_MATHJAX = YES
PROJECT_HTML_USE_SEARCHBOX = YES
PROJECT_HTML_USE_TREEVIEW = YES
PROJECT_HTML_USE_TABLEOFCONTENTS = YES
PROJECT_HTML_USE_FULLWIDTH_TABLES = YES
PROJECT_HTML_USE_FULLWIDTH_LINKS = YES
PROJECT_HTML_USE_FULLWIDTH_CODE = YES
PROJECT_HTML_USE_FULLWIDTH_HEADINGS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_","static int al_register_incoming_cb(const struct device *dev, abstract_lin_incoming_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
	struct al_lin_incoming_cb *cb = NULL;
	int ret = -EINVAL;

	if (dev == NULL || callback == NULL) {
		return ret;
	}

	cb = kzalloc(sizeof(*cb), GFP_KERNEL);
	if (cb == NULL) {
		return -ENOMEM;
	}

	cb->callback = callback;
	cb->user_data = user_data;
	cb->frame_id = frame_id;
	cb->frame_size = frame_size;

	ret = mutex_lock(&dev->incoming_cb_mutex);
	if (ret < 0) {
		kfree(cb);
		return ret;
	}

	list_add_tail(&cb->list, &dev->incoming_cb_list);

	ret = mutex_unlock(&dev->incoming_cb_mutex);
	if (ret < 0) {
		kfree(cb);
		return ret;
	}

	return 0;
}
docs/doxygen/doxygen_config.py
# Doxygen configuration file for the Linux kernel documentation

# Project configuration
PROJECT_NAME           = ""Linux Kernel""
PROJECT_NUMBER         = ""5.15""
PROJECT_BRIEF          = ""The Linux Kernel""
PROJECT_LOGO           = ""logo.png""
PROJECT_START_URL      = ""https://www.kernel.org""
PROJECT_VERSION        = ""5.15""
PROJECT_SOURCE_DIR     = "".""
PROJECT_HTML_OUTPUT    = ""html""
PROJECT_GENERATE_HTML  = YES
PROJECT_HTML_EXTRA_STYLESHEET = ""doxygen-awesome.css""
PROJECT_HTML_EXTRA_FILES = ""doxygen-awesome.css""
PROJECT_HTML_FILE_EXTENSION = "".html""
PROJECT_HTML_USE_INDEX = YES
PROJECT_HTML_USE_NUMBERED_REFERENCES = YES
PROJECT_HTML_USE_RST_FORMAT = YES
PROJECT_HTML_USE_MATHLAX = YES
PROJECT_HTML_USE_MATHJAX = YES
PROJECT_HTML_USE_SEARCHBOX = YES
PROJECT_HTML_USE_TREEVIEW = YES
PROJECT_HTML_USE_TABLEOFCONTENTS = YES
PROJECT_HTML_USE_FULLWIDTH_TABLES = YES
PROJECT_HTML_USE_FULLWIDTH_LINKS = YES
PROJECT_HTML_USE_FULLWIDTH_CODE = YES
PROJECT_HTML_USE_FULLWIDTH_HEADINGS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_HTML_USE_FULLWIDTH_FOOTERS = YES
PROJECT_",38.30147752560007,10.621528966139792,34.531159847745066,48.529411764705884,59.523809523809526
98,c,"static int al_register_outgoing_cb(const struct device *dev,
                                   abstract_lin_outgoing_callback_t callback,
                                   uint8_t frame_id,
                                   uint8_t frame_size,
                                   void *user_data) {
  struct abstract_lin_data *data = dev->data;

  if (callback == NULL || frame_id > 0x3F || frame_size < 1 || frame_size > 8) {
    return -EINVAL;
  }

  int free_index = allocate_callback(data, frame_id);
  if (free_index < 0) {
    return free_index;
  }

  data->callbacks[free_index].frame_id = frame_id;
  data->callbacks[free_index].frame_size = frame_size;
  data->callbacks[free_index].type = OUTGOING;
  data->callbacks[free_index].outgoing_cb = callback;
  data->callbacks[free_index].user_data = user_data;

  return 0;
}","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
	struct al_lin_outgoing_cb *cb = dev->data;
	if (cb == NULL) {
		return -ENODEV;
	}
	cb->outgoing_cb[frame_id] = callback;
	cb->outgoing_frame_size[frame_id] = frame_size;
	cb->outgoing_user_data[frame_id] = user_data;
	return 0;
}
docs/doxygen/doxygen.conf
# Doxygen configuration file for the Linux kernel documentation

# Project configuration
PROJECT_NAME           = ""Linux Kernel""
PROJECT_NUMBER         = ""5.15""
PROJECT_BRIEF          = ""The Linux Kernel""
PROJECT_LOGO           = ""logo.png""
PROJECT_START_URL      = ""https://www.kernel.org""
PROJECT_VERSION        = ""5.15""
PROJECT_SOURCE_DIR     = "".""
PROJECT_HTML_OUTPUTDIR = ""html""
PROJECT_GENERATE_HTML  = YES
PROJECT_HTML_COCOA     = NO
PROJECT_HTML_LATEX     = NO
PROJECT_HTML_RESPIF    = NO
PROJECT_HTML_FILE_EXTENSION = "".html""
PROJECT_HTML_EXTRA_STYLESHEET = ""doxygen-awesome-dark.css""
PROJECT_HTML_EXTRA_STYLESHEET_BEFORE = ""doxygen-awesome.css""
PROJECT_HTML_EXTRA_STYLESHEET_AFTER = ""doxygen-awesome-dark.css""
PROJECT_HTML_NAVBAR_2_LEVEL = YES
PROJECT_HTML_NAVBAR_3_LEVEL = NO
PROJECT_HTML_NAVBAR_TOGGLE_ON_LOAD = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_CLICK = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_SCROLL = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_HOVER = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_KEYPRESS = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_TOUCH = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_DRAG = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_DOUBLE_TAP = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_LONG_PRESS = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_CONTEXT_MENU = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_DOWN = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_UP = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_MOVE = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_CANCEL = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_OUT = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_LEAVE = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_ENTER = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_OVER = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_HOVER = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_HOVER_MOVE = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_HOVER_","static int al_register_outgoing_cb(const struct device *dev, abstract_lin_outgoing_callback_t callback, uint8_t frame_id, uint8_t frame_size, void *user_data) {
	struct al_lin_outgoing_cb *cb = dev->data;
	if (cb == NULL) {
		return -ENODEV;
	}
	cb->outgoing_cb[frame_id] = callback;
	cb->outgoing_frame_size[frame_id] = frame_size;
	cb->outgoing_user_data[frame_id] = user_data;
	return 0;
}
docs/doxygen/doxygen.conf
# Doxygen configuration file for the Linux kernel documentation

# Project configuration
PROJECT_NAME           = ""Linux Kernel""
PROJECT_NUMBER         = ""5.15""
PROJECT_BRIEF          = ""The Linux Kernel""
PROJECT_LOGO           = ""logo.png""
PROJECT_START_URL      = ""https://www.kernel.org""
PROJECT_VERSION        = ""5.15""
PROJECT_SOURCE_DIR     = "".""
PROJECT_HTML_OUTPUTDIR = ""html""
PROJECT_GENERATE_HTML  = YES
PROJECT_HTML_COCOA     = NO
PROJECT_HTML_LATEX     = NO
PROJECT_HTML_RESPIF    = NO
PROJECT_HTML_FILE_EXTENSION = "".html""
PROJECT_HTML_EXTRA_STYLESHEET = ""doxygen-awesome-dark.css""
PROJECT_HTML_EXTRA_STYLESHEET_BEFORE = ""doxygen-awesome.css""
PROJECT_HTML_EXTRA_STYLESHEET_AFTER = ""doxygen-awesome-dark.css""
PROJECT_HTML_NAVBAR_2_LEVEL = YES
PROJECT_HTML_NAVBAR_3_LEVEL = NO
PROJECT_HTML_NAVBAR_TOGGLE_ON_LOAD = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_CLICK = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_SCROLL = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_HOVER = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_KEYPRESS = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_TOUCH = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_DRAG = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_DOUBLE_TAP = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_LONG_PRESS = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_CONTEXT_MENU = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_DOWN = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_UP = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_MOVE = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_CANCEL = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_OUT = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_LEAVE = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_ENTER = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_OVER = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_HOVER = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_HOVER_MOVE = YES
PROJECT_HTML_NAVBAR_TOGGLE_ON_POINTER_HOVER_",32.465552521019845,12.875096951399206,32.743415653688565,48.529411764705884,35.714285714285715
99,c,"int abstract_lin_scheduler_set_active_table(
    abstract_lin_scheduler_handle_t sched, size_t table_index) {
  if (table_index >= sched->table_count) {
    return -ENOENT;
  }

  bool active_before = sched->current_table != -1;

  if (active_before) {
    k_sem_take(&sched->active, K_FOREVER);
  }

  sched->current_table = table_index;
  sched->current_table_entry = 0;  // start from the beginning again.

  k_sem_give(&sched->active);

  return 0;
}","int abstract_lin_scheduler_set_active_table(uint8_t ecu_id,
                                            uint8_t schedule_id,
                                            uint8_t table_id) {
  int ret;
  uint8_t tx_data[] = {ecu_id, schedule_id, table_id};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
  return ret;
}
docs/README.md
# Documentation

This directory contains the documentation for the project.

## Build

The documentation is built using Sphinx.

To build the documentation, you need to have Sphinx installed.

```bash
pip install sphinx sphinx-rtd-theme
```

Then, you can build the documentation using the following command:

```bash
make docs
```

This will generate the documentation in the `_build` directory.

## Structure

The documentation is structured as follows:

- `index.rst`: The main page of the documentation.
- `conf.py`: The Sphinx configuration file.
- `_static`: The directory containing static files, such as CSS and JavaScript.
- `_templates`: The directory containing templates for the documentation.
- `_build`: The directory where the documentation is built.
- `api`: The directory containing the API documentation.
- `examples`: The directory containing the examples.
- `tutorials`: The directory containing the tutorials.
- `changelog`: The directory containing the changelog.
- `contributing`: The directory containing the contributing guidelines.
- `license`: The directory containing the license.
- `README.md`: This file.
- `Makefile`: The Makefile for building the documentation.
- `make.bat`: The batch file for building the documentation on Windows.
- `requirements.txt`: The file containing the Python requirements for building the documentation.
- `sphinx-conf.py`: The Sphinx configuration file.
- `sphinx-conf.py.bak`: The backup of the Sphinx configuration file.
- `sphinx-conf.py.swp`: The swap file for the Sphinx configuration file.
- `sphinx-conf.py~`: The backup of the Sphinx configuration file.
- `sphinx-conf.py.old`: The old version of the Sphinx configuration file.
- `sphinx-conf.py.old.bak`: The backup of the old version of the Sphinx configuration file.
- `sphinx-conf.py.old.swp`: The swap file for the old version of the Sphinx configuration file.
- `sphinx-conf.py.old~`: The backup of the old version of the Sphinx configuration file.
- `sphinx-conf.py.old.old`: The old version of the old version of the Sphinx configuration file.
- `sphinx-conf.py.old.old.bak`: The backup of the old version of the old version of the Sphinx configuration file.
- `sphinx-conf.py.old.old.swp`: The swap file for the old version of the old version of the Sphinx configuration file.
- `sphinx-conf.py.old.old~`: The backup of the old version of the old version of the Sphinx configuration file.
- `sphinx-conf.py.old.old.old`: The old version of the old version of the old version of the Sphinx configuration file.
-","int abstract_lin_scheduler_set_active_table(uint8_t ecu_id,
                                            uint8_t schedule_id,
                                            uint8_t table_id) {
  int ret;
  uint8_t tx_data[] = {ecu_id, schedule_id, table_id};
  ret = isotp_send(&send_ctx, can_dev, tx_data, sizeof(tx_data), &tx_addr,
                   &rx_addr, send_complete_cb, NULL);
  if (ret != ISOTP_N_OK) {
    LOG_ERR(""Error while sending data to ID %d [%d]\n"", tx_addr.std_id, ret);
  }
  return ret;
}
docs/examples/example_uds_client.md
# Example UDS Client

This example shows how to use the UDS client library to send a request to a UDS server.

## Prerequisites

- A UDS server is running on the same network as the client.
- The UDS server is configured to respond to the request.

## Usage

To run the example, you need to compile and link the UDS client library with the example code.

```bash
make example_uds_client
```

Then, you can run the example by executing the following command:

```bash
./example_uds_client
```

The example will send a request to the UDS server and print the response to the console.

## Code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <isotp.h>
#include <isotp_cfg.h>
#include <isotp_cfg_private.h>
#include <isotp_internal.h>

#include <uds.h>
#include <uds_cfg.h>
#include <uds_cfg_private.h>
#include <uds_internal.h>

#include <common/log.h>

#define CAN_ID 0x123

static uint8_t ecu_id = 0x11;
static uint8_t schedule_id = 0x22;
static uint8_t table_id = 0x33;

static uint8_t ecu_id_response = 0x44;
static uint8_t schedule_id_response = 0x55;
static uint8_t table_id_response = 0x66;

static uint8_t tx_data[] = {ecu_id, schedule_id, table_id};
static uint8_t rx_data[256];

static uint8_t ecu_id_response_data[] = {ecu_id_response, schedule_id_response, table_id_response};

static uint8_t ecu_id_response_data_2[] = {ecu_id_response, schedule_id_response, table_id_response};

static uint8_t ecu_id_response_data_3[] = {ecu_id_response, schedule_id_response, table_id_response};

static uint8_t ecu_id_response_data_4[] = {ecu_id_response, schedule_id_response, table_id_response};

static uint8_t ecu_id_response_data_5[] = {ecu_id_response, schedule_id_response, table_id_response};

static uint8_t ecu_",17.82119572532857,0.08066113067834932,0.8532445776534786,23.684210526315788,46.666666666666664
100,c,"void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
  if (sched->current_table == -1) {
    return;  // already stopped.
  }

  k_sem_take(&sched->active, K_FOREVER);

  sched->current_table = -1;
}","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
  if (sched) {
    pthread_mutex_lock(&sched->mutex);
    sched->running = false;
    pthread_mutex_unlock(&sched->mutex);
  }
}
docs/api/c/abstract_lin_scheduler_disable.md
# abstract_lin_scheduler_disable

## Description

Stops the LIN scheduler from processing its current schedule table

## Arguments

*   `sched` - The handle of the scheduler to disable.
docs/api/c/abstract_lin_scheduler_enable.md
# abstract_lin_scheduler_enable

## Description

Starts the LIN scheduler to process its current schedule table

## Arguments

*   `sched` - The handle of the scheduler to enable.
docs/api/c/abstract_lin_scheduler_init.md
# abstract_lin_scheduler_init

## Description

Initializes the abstract LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to initialize.
docs/api/c/abstract_lin_scheduler_new.md
# abstract_lin_scheduler_new

## Description

Creates a new abstract LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to create.
docs/api/c/abstract_lin_scheduler_remove.md
# abstract_lin_scheduler_remove

## Description

Removes a LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to remove.
docs/api/c/abstract_lin_scheduler_run.md
# abstract_lin_scheduler_run

## Description

Runs the abstract LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to run.
docs/api/c/abstract_lin_scheduler_stop.md
# abstract_lin_scheduler_stop

## Description

Stops the abstract LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to stop.
docs/api/c/abstract_lin_scheduler_wait_for_completion.md
# abstract_lin_scheduler_wait_for_completion

## Description

Waits for the abstract LIN scheduler to complete its current schedule

## Arguments

*   `sched` - The handle of the scheduler to wait for.
docs/api/c/abstract_lin_scheduler_wait_for_completion_timeout.md
# abstract_lin_scheduler_wait_for_completion_timeout

## Description

Waits for the abstract LIN scheduler to complete its current schedule

## Arguments

*   `sched` - The handle of the scheduler to wait for.
*   `timeout_ms` - The timeout in milliseconds to wait for the scheduler to complete.
docs/api/c/abstract_lin_scheduler_wait_for_completion_timeout_cb.md
# abstract_lin_scheduler_wait_for_completion_timeout_cb

## Description

Waits for the abstract LIN scheduler to complete its current schedule

## Arguments

*   `sched` - The handle of the scheduler to wait for.
*   `timeout_ms` - The timeout in milliseconds to wait for the scheduler to complete.
*   `cb` - The callback function to call when the scheduler completes or the timeout expires.
docs/api/c/abstract_lin_scheduler_wait_for_completion_timeout_cb_data.md
# abstract_lin_scheduler_wait_for_completion_timeout_cb_data

## Description

The data structure passed to the callback function of abstract_lin_scheduler_wait_for","void abstract_lin_scheduler_disable(abstract_lin_scheduler_handle_t sched) {
  if (sched) {
    pthread_mutex_lock(&sched->mutex);
    sched->running = false;
    pthread_mutex_unlock(&sched->mutex);
  }
}
docs/api/c/abstract_lin_scheduler_enable.md
# abstract_lin_scheduler_enable

## Description

Starts the LIN scheduler to process its current schedule

## Arguments

*   `sched` - The handle of the scheduler to enable.
docs/api/c/abstract_lin_scheduler_init.md
# abstract_lin_scheduler_init

## Description

Initializes the abstract LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to initialize.
docs/api/c/abstract_lin_scheduler_new.md
# abstract_lin_scheduler_new

## Description

Creates a new abstract LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to create.
docs/api/c/abstract_lin_scheduler_remove.md
# abstract_lin_scheduler_remove

## Description

Removes a LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to remove.
docs/api/c/abstract_lin_scheduler_run.md
# abstract_lin_scheduler_run

## Description

Runs the abstract LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to run.
docs/api/c/abstract_lin_scheduler_stop.md
# abstract_lin_scheduler_stop

## Description

Stops the abstract LIN scheduler

## Arguments

*   `sched` - The handle of the scheduler to stop.
docs/api/c/abstract_lin_scheduler_wait_for_completion.md
# abstract_lin_scheduler_wait_for_completion

## Description

Waits for the abstract LIN scheduler to complete its current schedule

## Arguments

*   `sched` - The handle of the scheduler to wait for.
docs/api/c/abstract_lin_scheduler_wait_for_completion_timeout.md
# abstract_lin_scheduler_wait_for_completion_timeout

## Description

Waits for the abstract LIN scheduler to complete its current schedule

## Arguments

*   `sched` - The handle of the scheduler to wait for.
*   `timeout_ms` - The timeout in milliseconds to wait for the scheduler to complete.
docs/api/c/abstract_lin_scheduler_wait_for_completion_timeout_cb.md
# abstract_lin_scheduler_wait_for_completion_timeout_cb

## Description

Waits for the abstract LIN scheduler to complete its current schedule

## Arguments

*   `sched` - The handle of the scheduler to wait for.
*   `timeout_ms` - The timeout in milliseconds to wait for the scheduler to complete.
*   `cb` - The callback function to call when the scheduler completes or the timeout expires.
docs/api/c/abstract_lin_scheduler_wait_for_completion_timeout_cb_data.md
# abstract_lin_scheduler_wait_for_completion_timeout_cb_data

## Description

The data structure passed to the callback function of abstract_lin_scheduler_wait_for_completion_timeout_cb
docs/api/c/abstract_lin_scheduler_wait_for_completion_timeout_cb_data_t.md
# abstract_lin_scheduler_wait_for_completion_timeout_cb_data_t

## Description

The data structure passed to the callback function of abstract_",27.140853894425916,1.188738500218075,22.374677077485583,35.0,50.0
