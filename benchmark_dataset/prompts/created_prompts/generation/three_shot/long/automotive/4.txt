Your task is to create a Python function based on a summary.
Below is an example of generating a Python function from a summary.

---

**[Examples]**
**[Example 1]**
**Summary:**
"Validates that 'check' and 'base' are known types, then returns true if the 'check' type is identical to the 'base' type or if its name is found within the 'base' type's predefined list of subtypes”

**Code:**
```python
def is_subtype_of(cls, check: str, base: str) -> bool:
    check_type = cls.get_type(check)
    if not check_type:
        raise DatatypesException(f"Not a valid type: '{check}'")
    base_type = cls.get_type(base)
    if not base_type:
        raise DatatypesException(f"Not a valid type: '{base}'")
    return check in base_type[2] or check == base
```

**[Example 2]**
**Summary:**
"Recursively traverses a VSS node tree to populate a dictionary with the occurrence count and a list of fully qualified paths for each unique node name”

**Code:**
```python
def populate_unique_node_names(node_names_dict: dict[str, Any], vss_node: VSSNode) -> None:
    if not node_names_dict.get(vss_node.name):
        node_names_dict.__setitem__(vss_node.name, {"counter": 1, "vss_paths": [vss_node.get_fqn()]})
    else:
        node_names_dict[vss_node.name]["counter"] += 1  # type: ignore
        node_names_dict[vss_node.name]["vss_paths"].append(vss_node.get_fqn())  # type: ignore

    if vss_node.children and len(vss_node.children) > 0:
        for vss_child_node in vss_node.children:
            populate_unique_node_names(node_names_dict, vss_child_node)
```

**[Example 3]**
**Summary:**
"Recursively parses a given specification file and any files it includes, returning a single, flattened list of all resulting VSpec objects”

**Code:**
```python
def get_vspecs(includes: list[Path], spec: Path, prefix: str | None = None) -> list[VSpec]:
    vspecs: list[VSpec] = []
    vspec = VSpec(spec, prefix)
    vspecs.append(vspec)

    for include in vspec.includes:
        include_spec = include.resolve_path(includes + [vspec.source.parent])
        vspecs.extend(get_vspecs(includes, include_spec, include.prefix))

    return vspecs
```

---

**[Target]**
**Based on the summary below, generate the full Python function, including the function signature and function body (do not provide any other output)**

**Summary:**
"Returns the type definition tuple from a class-level list of types that matches the provided 'datatype' name, or returns None if no match is found"

**Code:**
```python
def get_type(cls, datatype: str) -> tuple[str, Callable, list[str]] | None:
```