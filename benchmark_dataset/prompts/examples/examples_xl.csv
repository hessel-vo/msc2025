language,code,summary_short,summary_long
c,"int FindMaxSum(int arr[], int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}",Maximum sum such that no two elements are adjacent,Finds the maximum sum of a subsequence of non-adjacent elements by iteratively tracking the maximum sum including and excluding the current element
c,"bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = (n % 2) ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}",Check for Majority Element in a sorted array,Determines if a given element `x` is the majority in a sorted array by checking if `x` occupies both an index `i` and the index `n/2` positions ahead of it
c,"bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            printf(""Pair Found: (%d, %d)\n"", arr[i], arr[j]);
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    printf(""No such pair\n"");
    return false;
}",Find a pair with the given difference,Finds if a pair of elements with a given difference `n` exists in a sorted array by using a two-pointer approach.
cpp,"int FindMaxSum(vector<int> arr, int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }

    return ((incl > excl) ? incl : excl);
}",Maximum sum such that no two elements are adjacent,Finds the maximum sum of a subsequence of non-adjacent elements by iteratively tracking the maximum sum including and excluding the current element
cpp,"bool isMajority(int arr[], int n, int x) {
    int i;
    int last_index = n % 2 ? (n / 2 + 1) : (n / 2);

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}",Check for Majority Element in a sorted array,Determines if a given element `x` is the majority in a sorted array by checking if `x` occupies both an index `i` and the index `n/2` positions ahead of it
cpp,"bool findPair(int arr[], int size, int n) {
    int i = 0;
    int j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            cout << ""Pair Found: ("" << arr[i] << "", "" << arr[j] << "")"" << endl;
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    cout << ""No such pair"" << endl;
    return false;
}",Find a pair with the given difference,Finds if a pair of elements with a given difference `n` exists in a sorted array by using a two-pointer approach.
java,"int FindMaxSum(int arr[], int n) {
    int incl = arr[0];
    int excl = 0;
    int excl_new;
    int i;

    for (i = 1; i < n; i++) {
        excl_new = (incl > excl) ? incl : excl;
        incl = excl + arr[i];
        excl = excl_new;
    }
    return ((incl > excl) ? incl : excl);
}",Maximum sum such that no two elements are adjacent,Finds the maximum sum of a subsequence of non-adjacent elements by iteratively tracking the maximum sum including and excluding the current element
java,"static boolean isMajority(int arr[], int n, int x) {
    int i, last_index = 0;
    last_index = (n % 2 == 0) ? n / 2 : n / 2 + 1;

    for (i = 0; i < last_index; i++) {
        if (arr[i] == x && arr[i + n / 2] == x) {
            return true;
        }
    }
    return false;
}",Check for Majority Element in a sorted array,Determines if a given element `x` is the majority in a sorted array by checking if `x` occupies both an index `i` and the index `n/2` positions ahead of it
java,"static boolean findPair(int arr[], int n) {
    int size = arr.length;
    int i = 0, j = 1;

    while (i < size && j < size) {
        if (i != j && arr[j] - arr[i] == n) {
            System.out.print(""Pair Found: ("" + arr[i] + "", "" + arr[j] + "")"");
            return true;
        } else if (arr[j] - arr[i] < n) {
            j++;
        } else {
            i++;
        }
    }

    System.out.print(""No such pair"");
    return false;
}",Find a pair with the given difference,Finds if a pair of elements with a given difference `n` exists in a sorted array by using a two-pointer approach.
python,"def find_max_sum(arr):
    incl = 0
    excl = 0
    for i in arr:
        new_excl = excl if excl > incl else incl
        incl = excl + i
        excl = new_excl
    return excl if excl > incl else incl",Maximum sum such that no two elements are adjacent,Finds the maximum sum of a subsequence of non-adjacent elements by iteratively tracking the maximum sum including and excluding the current element
python,"def isMajority(arr, n, x):
    last_index = (n // 2 + 1) if n % 2 == 1 else (n // 2)
    for i in range(last_index):
        if arr[i] == x and arr[i + n // 2] == x:
            return 1
    return 0",Check for Majority Element in a sorted array,Determines if a given element `x` is the majority in a sorted array by checking if `x` occupies both an index `i` and the index `n/2` positions ahead of it
python,"def findPair(arr, n):
    size = len(arr)
    i, j = 0, 1

    while i < size and j < size:
        if i != j and arr[j] - arr[i] == n:
            print(f""Pair found ({arr[i]}, {arr[j]})"")
            return True
        elif arr[j] - arr[i] < n:
            j += 1
        else:
            i += 1

    print(""No pair found"")
    return False",Find a pair with the given difference,Finds if a pair of elements with a given difference `n` exists in a sorted array by using a two-pointer approach.